"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[5895],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),u=i,g=d["".concat(s,".").concat(u)]||d[u]||m[u]||r;return t?a.createElement(g,o(o({ref:n},c),{},{components:t})):a.createElement(g,o({ref:n},c))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2572:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const r={id:"index",title:"Introduction to the ZIO's Contextual Data Types",sidebar_label:"Introduction"},o=void 0,l={unversionedId:"datatypes/contextual/index",id:"datatypes/contextual/index",title:"Introduction to the ZIO's Contextual Data Types",description:"ZIO provides a contextual abstraction that encodes the environment of the running effect. This means, every effect can work within a specific context, called an environment.",source:"@site/docs/datatypes/contextual/index.md",sourceDirName:"datatypes/contextual",slug:"/datatypes/contextual/",permalink:"/next/datatypes/contextual/",editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/datatypes/contextual/index.md",tags:[],version:"current",frontMatter:{id:"index",title:"Introduction to the ZIO's Contextual Data Types",sidebar_label:"Introduction"},sidebar:"datatypes-sidebar",previous:{title:"Cause",permalink:"/next/datatypes/core/cause"},next:{title:"ZEnvironment",permalink:"/next/datatypes/contextual/zenvironment"}},s=[{value:"1. ZIO Environment",id:"1-zio-environment",children:[{value:"Motivation",id:"motivation",children:[],level:3},{value:"Advantage of Using ZIO Environment",id:"advantage-of-using-zio-environment",children:[],level:3},{value:"Accessing ZIO Environment",id:"accessing-zio-environment",children:[{value:"Service Accessor",id:"service-accessor",children:[],level:4},{value:"Service Member Accessors",id:"service-member-accessors",children:[],level:4}],level:3}],level:2},{value:"2. ZEnvironment",id:"2-zenvironment",children:[],level:2},{value:"3. ZLayer",id:"3-zlayer",children:[],level:2},{value:"Defining ZIO Services",id:"defining-zio-services",children:[{value:"Defining Services in OOP",id:"defining-services-in-oop",children:[],level:3},{value:"Defining Services in ZIO",id:"defining-services-in-zio",children:[],level:3},{value:"Service Pattern",id:"service-pattern",children:[],level:3},{value:"Defining Polymorphic Services in ZIO",id:"defining-polymorphic-services-in-zio",children:[],level:3},{value:"Generating Accessor Methods Using Macros",id:"generating-accessor-methods-using-macros",children:[{value:"Monomorphic Services",id:"monomorphic-services",children:[],level:4},{value:"Writing Polymorphic Services",id:"writing-polymorphic-services",children:[{value:"With Proper Type Parameters",id:"with-proper-type-parameters",children:[],level:5},{value:"With Higher-Kinded Type Parameters (<code>F[_]</code>)",id:"with-higher-kinded-type-parameters-f_",children:[],level:5},{value:"With Higher-Kinded Type Parameters (<code>F[_, _]</code>)",id:"with-higher-kinded-type-parameters-f_-_",children:[],level:5}],level:4},{value:"Support for Scala 3",id:"support-for-scala-3",children:[],level:4}],level:3},{value:"The Three Laws of ZIO Environment",id:"the-three-laws-of-zio-environment",children:[],level:3}],level:2}],p={toc:s};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"ZIO provides a contextual abstraction that encodes the environment of the running effect. This means, every effect can work within a specific context, called an environment."),(0,i.kt)("p",null,"So when we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[R, E, A]"),' effect, we can say "given ',(0,i.kt)("inlineCode",{parentName:"p"},"R")," as the environment of the effect, the effect may fail with an error type of ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),", or may succeed with a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),'".'),(0,i.kt)("p",null,"For example, when we have an effect of type ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[DatabaseConnection, IOException, String]"),", we can say that our effect works within the context of ",(0,i.kt)("inlineCode",{parentName:"p"},"DatabaseConnection"),". In other words, we can say that our effect requires the ",(0,i.kt)("inlineCode",{parentName:"p"},"DatabaseConnection")," service as a context to run."),(0,i.kt)("p",null,"We will see how layers can be used to eliminate the environment of an effect:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nimport java.io.IOException\n\ntrait DatabaseConnection\n\n// An effect which requires DatabaseConnection to run\nval effect: ZIO[DatabaseConnection, IOException, String] = ???\n\n// A layer that produces DatabaseConnection service\nval dbConnection: ZLayer[Any, IOException, DatabaseConnection] = ???\n\n// After applying dbConnection to our environmental effect the reurned\n// effect has no dependency on the DatabaseConnection\nval eliminated: ZIO[Any, IOException, String] = \n  dbConnection { // Provides DatabaseConnection context\n    effect       // An effect running within `DatabaseConnection` context\n  }\n")),(0,i.kt)("p",null,"ZIO provides this facility through the following concepts and data types:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#1-zio-environment"},"ZIO Environment")," \u2014 The ",(0,i.kt)("inlineCode",{parentName:"li"},"R")," type parameter of ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO[R, E, A]")," data type."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"/next/datatypes/contextual/zenvironment"},"ZEnvironment")," \u2014 Built-in type-level map for maintaining the environment of a ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO")," data type. "),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"/next/datatypes/contextual/zlayer"},"ZLayer")," \u2014 Describes how to build one or more services in our application.")),(0,i.kt)("p",null,"Next, we will discuss ",(0,i.kt)("em",{parentName:"p"},"ZIO Environment")," and ",(0,i.kt)("em",{parentName:"p"},"ZLayer")," and finally how to write ZIO services using the ",(0,i.kt)("em",{parentName:"p"},"Service Pattern"),"."),(0,i.kt)("h2",{id:"1-zio-environment"},"1. ZIO Environment"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[-R, +E, +A]")," data type describes an effect that requires an input of type ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),", as an environment, may fail with an error of type ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),", or succeed with a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,i.kt)("p",null,"The input type is also known as ",(0,i.kt)("em",{parentName:"p"},"environment type"),". This type-parameter indicates that to run an effect we need one or some services as an environment of that effect. In other word, ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," represents the ",(0,i.kt)("em",{parentName:"p"},"requirement")," for the effect to run, meaning we need to fulfill the requirement in order to make the effect ",(0,i.kt)("em",{parentName:"p"},"runnable"),"."),(0,i.kt)("p",null,"So we can think of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[R, E, A]")," as a mental model of a function from a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Either[E, A]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type ZIO[R, E, A] = R => Either[E, A]\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"R")," represents dependencies; whatever services, config, or wiring a part of a ZIO program depends upon to work. We will explore what we can do with ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),", as it plays a crucial role in ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),"."),(0,i.kt)("p",null,"We don't need to provide live layers for built-in services (Layers will be discussed later on this page). ZIO has a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnv")," type alias for the composition of all ZIO built-in services (",(0,i.kt)("inlineCode",{parentName:"p"},"Clock"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Console"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"System"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Random"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Blocking"),"). So we can run the above ",(0,i.kt)("inlineCode",{parentName:"p"},"effect")," as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = effect\n  \n  val effect: ZIO[Any, Nothing, Unit] = for {\n    r <- Random.nextInt\n    _ <- Console.printLine(s"random number: $r").orDie\n  } yield ()\n}\n')),(0,i.kt)("h3",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,'One might ask "What is the motivation behind encoding the dependency in the type parameter of ',(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),' data type"? What is the benefit of doing so?'),(0,i.kt)("p",null,"Let's see how writing an application which requires reading from or writing to the console. As part of making the application ",(0,i.kt)("em",{parentName:"p"},"modular")," and ",(0,i.kt)("em",{parentName:"p"},"testable")," we define a separate service called ",(0,i.kt)("inlineCode",{parentName:"p"},"Console")," which is responsible for reading from and writing to the console. We do that simply by writing an interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Console {\n  def print(line: Any): Task[Unit]\n\n  def printLine(line: Any): Task[Unit]\n\n  def readLine: Task[String]\n}\n")),(0,i.kt)("p",null,"Now we can write our application that accepts the ",(0,i.kt)("inlineCode",{parentName:"p"},"Console")," interface as a parameter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef myApp(c: Console): Task[Unit] =\n  for {\n    _    <- c.print("Please enter your name: ")\n    name <- c.readLine\n    _    <- c.printLine(s"Hello, $name!")\n  } yield ()\n')),(0,i.kt)("p",null,"Similar to the object-oriented paradigm we code to interface not implementation. In order to run the application, we need to implement a production version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Console"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject ConsoleLive extends Console {\n  override def print(line: Any): Task[Unit] =\n    Task.attemptBlocking(scala.Predef.print(line))\n\n  override def printLine(line: Any): Task[Unit] =\n    Task.attemptBlocking(scala.Predef.println(line))\n\n  override def readLine: Task[String] =\n    Task.attemptBlocking(scala.io.StdIn.readLine())\n}\n")),(0,i.kt)("p",null,"Finally, we can provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConsoleLive")," to our application and run the whole:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def myApp(c: Console): Task[Unit] =\n    for {\n      _    <- c.print("Please enter your name: ")\n      name <- c.readLine\n      _    <- c.printLine(s"Hello, $name!")\n    } yield ()\n\n  def run = myApp(ConsoleLive)\n}\n')),(0,i.kt)("p",null,"In the above example, we discard the fact that we could use the ZIO environment and utilize the ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," parameter of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," data type. So instead we tried to write the application with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Task")," data type, which ignores the ZIO environment. To create our application testable, we gathered all console functionalities into the same interface called ",(0,i.kt)("inlineCode",{parentName:"p"},"Console"),", and implemented that in another object called ",(0,i.kt)("inlineCode",{parentName:"p"},"ConsoleLive"),". Finally, at the end of the day, we provide the implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Console")," service, i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"ConsoleLive"),", to our application."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"While this technique works for small programs, it doesn't scale.")," Assume we have multiple services, and we use them in our application logic like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def foo(\n   s1: Service1,\n   s2: Service2,\n   s3: Service3\n)(arg1: String, arg2: String, arg3: Int): Task[Int] = ???\n\ndef bar(\n  s1: Service1,\n  s12: Service12,\n  s18: Service18, \n  sn: ServiceN\n)(arg1: Int, arg2: String, arg3: Double, arg4: Int): Task[Unit]\n\ndef myApp(s1: Service1, s2: Service2, ..., sn: ServiceN): Task[Unit] = \n  for {\n    a <- foo(s1, s2, s3)("arg1", "arg2", 4) \n    _ <- bar(s1, s12, s18, sn)(7, "arg2", 1.2, a)\n      ...\n  } yield ()\n')),(0,i.kt)("p",null,"Writing real applications using this technique is tedious and cumbersome because all dependencies have to be passed across all methods. We can simplify the process of writing our application by using the ZIO environment and ",(0,i.kt)("a",{parentName:"p",href:"#service-pattern"},"Service Pattern"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def foo(arg1: String, arg2: String, arg3: Int): ZIO[Service1 & Service2 & Service3, Throwable, Int] = \n  for {\n    s1 <- ZIO.service[Service1]\n    s2 <- ZIO.service[Service2] \n      ...\n  } yield ()\n\ndef bar(arg1: Int, arg2: String, arg3: Double, arg4: Int): ZIO[Service1 & Service12 & Service18 & ServiceN, Throwable, Unit] =\n  for {\n    s1  <- ZIO.service[Service1] \n    s12 <- ZIO.service[Service12]\n      ...\n  } yield ()\n")),(0,i.kt)("h3",{id:"advantage-of-using-zio-environment"},"Advantage of Using ZIO Environment"),(0,i.kt)("p",null,"ZIO environment facility enables us to:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Code to Interface")," \u2014 Like object-oriented paradigm, in ZIO we are encouraged to code to interface and defer the implementation. It is the best practice, but ZIO does not enforce us to do that.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Write a Testable Code")," \u2014 By coding to an interface, whenever we want to test our effects, we can easily mock any external services, by providing a ",(0,i.kt)("em",{parentName:"p"},"test")," version of those instead of the ",(0,i.kt)("em",{parentName:"p"},"live")," version.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Compose Services with Strong Type Inference Facility")," \u2014 We can compose multiple effects that require various services, so the final effect requires the intersection of all those services:"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait ServiceA\ntrait ServiceB\ntrait ServiceC\n\n// Requires ServiceA and produces a value of type Int\ndef foo: ZIO[ServiceA, Nothing, Int] = ???\n\n// Requires ServiceB and ServiceC and produces a value of type String\ndef bar: ZIO[ServiceB & ServiceC, Throwable, String] = ???\n\n// Requires ServicB and produces a value of type Double\ndef baz(a: Int, b: String): ZIO[ServiceB, Nothing, Double] = ???\n\n// Requires ServiceB and ServiceB and ServiceC and produces a value of type Double\nval myApp: ZIO[ServiceA & ServiceB & ServiceC, Throwable, Double] =\n  for {\n    a <- foo\n    b <- bar\n    c <- baz(a, b)\n  } yield c\n")),(0,i.kt)("p",null,"Another important note about the ZIO environment is that the type inference works well on effect composition. After we composed all the application logic together, the compiler and also IDE can infer the proper type for the environment of the final effect."),(0,i.kt)("p",null,"In the example above, the compiler can infer the environment type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"myApp")," effect which is ",(0,i.kt)("inlineCode",{parentName:"p"},"ServiceA & ServiceB & ServiceC"),"."),(0,i.kt)("h3",{id:"accessing-zio-environment"},"Accessing ZIO Environment"),(0,i.kt)("p",null,"We have two types of accessors for the ZIO environment:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Service Accessor (",(0,i.kt)("inlineCode",{parentName:"strong"},"ZIO.service"),")")," is used to access a specific service from the environment."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Service Member Accessors (",(0,i.kt)("inlineCode",{parentName:"strong"},"ZIO.serviceWith")," and ",(0,i.kt)("inlineCode",{parentName:"strong"},"ZIO.serviceWithZIO"),")")," are used to access capabilities of a specific service from the environment.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note"),":"),(0,i.kt)("p",{parentName:"blockquote"},"To access the entire ZIO environment we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.environment*"),", but we do not use these methods regularly to access ZIO services. Instead, we use service accessors and service member accessors.")),(0,i.kt)("h4",{id:"service-accessor"},"Service Accessor"),(0,i.kt)("p",null,"To access a service from the ZIO environment, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.service")," constructor. For example, in the following program we are going to access the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppConfig")," from the environment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval myApp: ZIO[AppConfig, Nothing, Unit] =\n  for {\n    config <- ZIO.service[AppConfig]\n    _      <- ZIO.logInfo(s"Application started with config: $config")\n  } yield ()\n')),(0,i.kt)("p",null,"To run the ",(0,i.kt)("inlineCode",{parentName:"p"},"myApp")," effect, we should provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppConfig")," layer (we will talk about ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer")," on the next section):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'object MainApp extends ZIOAppDefault {\n  def run = myApp.provide(ZLayer.succeed(AppConfig("localhost", 8080)))\n}\n')),(0,i.kt)("p",null,"To access multiple services from the ZIO environment, we can do the same:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Foo\ntrait Bar\ntrait Baz\n\nfor {\n  foo <- ZIO.service[Foo]  \n  bar <- ZIO.service[Bar]\n  bax <- ZIO.service[Baz]\n} yield ()\n")),(0,i.kt)("p",null,"When creating ZIO layers that have multiple dependencies, this can be helpful. We will discuss this pattern in the ",(0,i.kt)("a",{parentName:"p",href:"#service-pattern"},"Service Pattern")," section."),(0,i.kt)("h4",{id:"service-member-accessors"},"Service Member Accessors"),(0,i.kt)("p",null,"Sometimes instead of accessing a service, we need to access the capabilities (members) of a service. Based on the return type of each capability, we can use one of these accessors:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ZIO.serviceWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ZIO.serviceWithZIO"))),(0,i.kt)("p",null,"In ",(0,i.kt)("a",{parentName:"p",href:"#service-pattern"},"Service Pattern"),', we use these accessors to write "accessor methods" for ZIO services.'),(0,i.kt)("p",null,"Let's look at each one in more detail:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"ZIO.serviceWith")," \u2014 When we are accessing service members whose return type is an ordinary value, we should use the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.serviceWith"),".")),(0,i.kt)("p",null,"In the following example, we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWith")," to write accessor methods for all of the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppConfig")," members:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class AppConfig(host: String, port: Int, poolSize: Int)\n\nobject AppConfig {\n  // Accessor Methods\n  def host: ZIO[AppConfig, Nothing, String]  = ZIO.serviceWith(_.host) \n  def port: ZIO[AppConfig, Nothing, Int]     = ZIO.serviceWith(_.port)\n  def poolSize: ZIO[AppConfig, Nothing, Int] = ZIO.serviceWith(_.poolSize)\n}\n\nval myApp: ZIO[AppConfig, Nothing, Unit] =\n  for {\n    host     <- AppConfig.host\n    port     <- AppConfig.port\n    _        <- ZIO.logInfo(s"The service will be service at $host:$port")\n    poolSize <- AppConfig.poolSize\n    _        <- ZIO.logInfo(s"Application started with $poolSize pool size")\n  } yield ()\n')),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"ZIO.serviceWithZIO")," \u2014 When we are accessing service members whose return type is a ZIO effect, we should use the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.serviceWithZIO"),".")),(0,i.kt)("p",null,"For example, in order to write the accessor method for the ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," member of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," service, we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWithZIO")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ntrait Logging {\n  def log(line: String): Task[Unit]\n}\n\nobject Logging {\n  // Accessor Methods:\n  def log(line: String): ZIO[Logging, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.log(line))\n}\n\nval myApp: ZIO[Logging & Console, Throwable, Unit] =\n  for {\n    _    <- Logging.log("Application Started!")\n    _    <- Console.print("Please enter your name: ")\n    name <- Console.readLine\n    _    <- Console.printLine(s"Hello, $name!")\n    _    <- Logging.log("Application exited!")\n  } yield ()\n')),(0,i.kt)("h2",{id:"2-zenvironment"},"2. ZEnvironment"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZEnvironment")," is a built-in type-level map for maintaining the environment of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," data type. We don't typically use this data type directly. It's okay to skip learning it at the moment. We have a ",(0,i.kt)("a",{parentName:"p",href:"/next/datatypes/contextual/zenvironment"},"separate article")," about this data type."),(0,i.kt)("h2",{id:"3-zlayer"},"3. ZLayer"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer[-RIn, +E, +ROut]")," is a recipe to build an environment of type ",(0,i.kt)("inlineCode",{parentName:"p"},"ROut"),", starting from a value ",(0,i.kt)("inlineCode",{parentName:"p"},"RIn"),", and possibly producing an error ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," during creation."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer")," combined with the ",(0,i.kt)("em",{parentName:"p"},"ZIO Environment"),", allow us to use ZIO for ",(0,i.kt)("em",{parentName:"p"},"dependency injection"),". There are two parts of dependency injection:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Building Dependency Graph")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Dependency Propagation"))),(0,i.kt)("p",null,"ZIO has a full solution to the dependency injection problem. It solves the first problem by using ",(0,i.kt)("a",{parentName:"p",href:"/next/datatypes/contextual/zlayer#manual-layer-construction"},"compositional properties")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer"),". Assume we have several services with their dependencies, and we need a way to compose and wire up these dependencies to create the dependency graph of the application. ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer")," is a ZIO solution for this problem. It allows us to build up the whole application dependency graph by composing layers horizontally and vertically. "),(0,i.kt)("p",null,"ZIO also solves the second problem by using ",(0,i.kt)("a",{parentName:"p",href:"/next/datatypes/contextual/zlayer#dependency-propagation"},"ZIO Environment facilities like ",(0,i.kt)("inlineCode",{parentName:"a"},"ZIO#provide")),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note:")),(0,i.kt)("p",{parentName:"blockquote"},"By using ZLayer and ZIO Environment we can solve the propagation and wire-up problems in dependency injection. Note that we are not enforced to use this approach, as we can still use things like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/google/guice"},"Guice")," with ZIO, or we might like to use ",(0,i.kt)("a",{parentName:"p",href:"https://izumi.7mind.io/distage/index.html"},"izumi distage")," solution for dependency injection.")),(0,i.kt)("h2",{id:"defining-zio-services"},"Defining ZIO Services"),(0,i.kt)("p",null,"Defining services in ZIO is not very different from object-oriented style, it has the same principle: coding to an interface, not an implementation. Therefore, ZIO encourages us to implement this principle by using ",(0,i.kt)("em",{parentName:"p"},"Service Pattern"),", which is quite similar to the object-oriented style."),(0,i.kt)("p",null,"Before diving into writing services in ZIO style, let's review how we define them in an object-oriented fashion in the next section."),(0,i.kt)("h3",{id:"defining-services-in-oop"},"Defining Services in OOP"),(0,i.kt)("p",null,"Here are the steps we take to implement a service in object-oriented programming:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Service Definition")," \u2014 In object-oriented programming, we define services with traits. A service is a bundle of related functionality that is defined in a trait:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait FooService {\n\n}\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Service Implementation")," \u2014 We implement these services by using classes:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class FooServiceImpl extends FooService {\n    \n}\n")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Defining Dependencies")," \u2014 If the creation of a service depends on other services, we can define these dependencies by using constructors:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait ServiceA {\n\n}\n\ntrait ServiceB {\n\n}\n\nclass FooServiceImpl(a: ServiceA, b: ServiceB) {\n\n}\n")),(0,i.kt)("p",null,"In object-oriented programming, the best practice is to ",(0,i.kt)("em",{parentName:"p"},"program to an interface, not an implementation"),". So in the previous example, ",(0,i.kt)("inlineCode",{parentName:"p"},"ServiceA")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ServiceB")," are interfaces, not concrete classes."),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Injecting Dependencies")," \u2014 Now, the client of ",(0,i.kt)("inlineCode",{parentName:"li"},"FooServiceImpl")," service can provide its own implementation of ",(0,i.kt)("inlineCode",{parentName:"li"},"ServiceA")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"ServiceB"),", and inject them to the ",(0,i.kt)("inlineCode",{parentName:"li"},"FooServiceImpl")," constructor:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class ServiceAImpl extends ServiceA\nclass ServiceBImpl extends ServiceB\nval fooService = new FooServiceImpl(new ServiceAImpl, new ServiceBImpl)\n")),(0,i.kt)("p",null,"Sometimes, as the number of dependent services grows and the dependency graph of our application becomes complicated, we need an automatic way of wiring and providing dependencies into the services of our application. In these situations, we might use a dependency injection framework to do all its magic machinery for us."),(0,i.kt)("h3",{id:"defining-services-in-zio"},"Defining Services in ZIO"),(0,i.kt)("p",null,"A service is a group of functions that deals with only one concern. Keeping the scope of each service limited to a single responsibility improves our ability to understand code, in that we need to focus only on one topic at a time without juggling too many concepts together in our head."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," itself provides the basic capabilities through modules, e.g. see how ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnv")," is defined."),(0,i.kt)("p",null,"In functional Scala as well as in object-oriented programming the best practice is to ",(0,i.kt)("em",{parentName:"p"},"Program to an Interface, Not an Implementation"),". This is the most important design principle in software development and helps us to write maintainable code by:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Allowing the client to hold an interface as a contract and don't worry about the implementation. The interface signature determines all operations that should be done.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Enabling a developer to write more testable programs. When we write a test for our business logic we don't have to run and interact with real services like databases which makes our test run very slow. If our code is correct our test code should always pass, there should be no hidden variables or depend on outside sources. We can't know that the database is always running correctly. We don't want to fail our tests because of the failure of external service.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Providing the ability to write more modular applications. So we can plug in different implementations for different purposes without a major modification."))),(0,i.kt)("p",null,"It is not mandatory, but ZIO encourages us to follow this principle by bundling related functionality as an interface by using the ",(0,i.kt)("em",{parentName:"p"},"Service Pattern"),"."),(0,i.kt)("p",null,"The core idea is that a layer depends upon the interfaces exposed by the layers immediately below itself, but is completely unaware of its dependencies' internal implementations."),(0,i.kt)("p",null,"In object-oriented programming:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Service Definition")," is done by using ",(0,i.kt)("em",{parentName:"li"},"interfaces")," (Scala trait or Java Interface)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Service Implementation")," is done by implementing interfaces using ",(0,i.kt)("em",{parentName:"li"},"classes")," or creating ",(0,i.kt)("em",{parentName:"li"},"new object")," of the interface."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Defining Dependencies")," is done by using ",(0,i.kt)("em",{parentName:"li"},"constructors"),". They allow us to build classes, given their dependencies. This is called constructor-based dependency injection.")),(0,i.kt)("p",null,"We have a similar analogy in the Service Pattern, except instead of using ",(0,i.kt)("em",{parentName:"p"},"constructors")," we use ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"ZLayer"))," to define dependencies. So in ZIO fashion, we can think of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer")," as a service constructor."),(0,i.kt)("h3",{id:"service-pattern"},"Service Pattern"),(0,i.kt)("p",null,"Writing services in ZIO using the ",(0,i.kt)("em",{parentName:"p"},"Service Pattern")," is very similar to the object-oriented way of defining services. We use scala traits to define services, classes to implement services, and constructors to define service dependencies. Finally, we lift the class constructor into the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer"),"."),(0,i.kt)("p",null,"Let's start learning this service pattern by writing a ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," service:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Service Definition")," \u2014 Traits are how we define services. A service could be all the stuff that is related to one concept with singular responsibility. We define the service definition with a trait named ",(0,i.kt)("inlineCode",{parentName:"li"},"Logging"),":")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Logging {\n  def log(line: String): UIO[Unit]\n}\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Service Implementation")," \u2014 It is the same as what we did in an object-oriented fashion. We implement the service with the Scala class. By convention, we name the live version of its implementation as ",(0,i.kt)("inlineCode",{parentName:"li"},"LoggingLive"),":")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class LoggingLive() extends Logging {\n  override def log(line: String): UIO[Unit] = \n    ZIO.succeed(print(line))\n}\n")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Define Service Dependencies")," \u2014 We might need ",(0,i.kt)("inlineCode",{parentName:"li"},"Console")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Clock")," services to implement the ",(0,i.kt)("inlineCode",{parentName:"li"},"Logging")," service. Here, we put its dependencies into its constructor. All the dependencies are just interfaces, not implementation. Just like what we did in object-oriented style:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class LoggingLive(console: Console, clock: Clock) extends Logging {\n  override def log(line: String): UIO[Unit] = \n    for {\n      current <- clock.currentDateTime\n      _       <- console.printLine(s"$current--$line").orDie\n    } yield ()\n}\n')),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Defining ZLayer")," \u2014 Now, we create a companion object for ",(0,i.kt)("inlineCode",{parentName:"li"},"LoggingLive")," data type and lift the service implementation into the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZLayer"),":")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object LoggingLive {\n  val layer: URLayer[Any, Logging] =\n    ZLayer {\n      for {\n        console <- ZIO.console\n        clock   <- ZIO.clock\n      } yield LoggingLive(console, clock)\n    }\n}\n")),(0,i.kt)("p",null,"Note that the previous step is syntactic sugar of writing the layer directly in combination with for-comprehension style of accessing the ZIO environment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object LoggingLive {\n  val layer: ZLayer[Any, Nothing, Logging] =\n    ZLayer {\n      for {\n        console <- ZIO.service[Console]\n        clock   <- ZIO.service[Clock]\n      } yield LoggingLive(console, clock)\n    }\n}\n")),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Accessor Methods")," \u2014 Finally, to create the API more ergonomic, it's better to write accessor methods for all of our service methods using ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.serviceWithZIO")," constructor inside the companion object:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Logging {\n  def log(line: String): URIO[Logging, Unit] = ZIO.serviceWithZIO[Logging](_.log(line))\n}\n")),(0,i.kt)("p",null,"Accessor methods allow us to utilize all the features inside the service through the ZIO Environment. That means, if we call ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging.log"),", we don't need to pull out the ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," function from the ZIO Environment. The ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWithZIO")," constructor helps us to access the environment and reduce the redundant operations, every time."),(0,i.kt)("p",null,"This is how ZIO services are created. Let's use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," service in our application. We should provide the live layer of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," service to be able to run the application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val app: ZIO[Logging, IOException, Unit] =\n    for {\n      _    <- Logging.log("Application Started!")\n      _    <- Console.print("Enter your name:")\n      name <- Console.readLine\n      _    <- Console.printLine(s"Hello, $name!")\n      _    <- Logging.log("Application Exited!")\n    } yield ()\n\n  def run = app.provide(LoggingLive.layer)\n}\n')),(0,i.kt)("p",null,"During writing the application, we don't care which implementation version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," service will be injected into our ",(0,i.kt)("inlineCode",{parentName:"p"},"app"),", later at the end of the day, it will be provided by one of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provide*")," methods."),(0,i.kt)("p",null,"That's it! Very simple! ZIO encourages us to follow some of the best practices in object-oriented programming. So it doesn't require us to throw away all our object-oriented knowledge."),(0,i.kt)("h3",{id:"defining-polymorphic-services-in-zio"},"Defining Polymorphic Services in ZIO"),(0,i.kt)("p",null,"As we discussed ",(0,i.kt)("a",{parentName:"p",href:"/next/datatypes/contextual/zenvironment"},"here"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnvironment"),", which is the underlying data type used by ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer"),", is backed by a type-level mapping from types of services to implementations of those services. This functionality is backed by ",(0,i.kt)("inlineCode",{parentName:"p"},"izumi.reflect.Tag"),", which captures a type as a value. "),(0,i.kt)("p",null,"We just need to know what is the type of service when we put it in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnvironment")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnvironment")," is essentially a map from ",(0,i.kt)("em",{parentName:"p"},"service types (interfaces)")," to ",(0,i.kt)("em",{parentName:"p"},"implementation of those interfaces"),". To implement the map, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnvironment")," needs a type tag for the new service, and also needs a way to remove the old service from the type level map. So we should have service type information at the runtime. "),(0,i.kt)("p",null,"We can think of ",(0,i.kt)("inlineCode",{parentName:"p"},"Tag[A]")," as like a ",(0,i.kt)("inlineCode",{parentName:"p"},"TypeTag[A]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ClassTag[A]")," from the Scala standard library but available on a cross-version and cross-platform basis. Basically, it carries information about a certain type into runtime that was available at compile time. Methods that construct ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnvironment")," values generally require a tag for the value being included in the \u201cbundle of services\u201d. "),(0,i.kt)("p",null,"As a user, we should not normally interact with ",(0,i.kt)("inlineCode",{parentName:"p"},"Tag")," except where we define polymorphic services. In general, a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tag")," should always be available whenever we have a concrete type. The only time we should have to use it is when we have a ",(0,i.kt)("em",{parentName:"p"},"polymorphic service"),". If we are using polymorphic code, we need to provide implicit evidence that a tag exists for that type (",(0,i.kt)("inlineCode",{parentName:"p"},"implicit tag: Tag[A]"),") or as a context-bound for that type parameter: (",(0,i.kt)("inlineCode",{parentName:"p"},"A: Tag"),")."),(0,i.kt)("p",null,"Let's try to write a polymorphic service. Assume we have the following service interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait KeyValueStore[K, V, E, F[_, _]] {\n  def get(key: K): F[E, V]\n\n  def set(key: K, value: V): F[E, V]\n\n  def remove(key: K): F[E, Unit]\n}\n")),(0,i.kt)("p",null,"In the next step, we are going to write its accessors. We might end up with the following snippet code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject KeyValueStore {\n  def get[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n\n  def set[K, V, E](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n\n  def remove[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =\n    ZIO.serviceWithZIO(_.remove(key))\n}\n\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n//                                                   ^\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n//                                                   ^\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO(_.remove(key))\n//                       ^\n")),(0,i.kt)("p",null,"The compiler generates the following errors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n\n\n<trace>: \n  deriving Tag for K, dealiased: K:\n  could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n")),(0,i.kt)("p",null,"As the compiler says, we should put ",(0,i.kt)("inlineCode",{parentName:"p"},"Tag")," as a context-bound for ",(0,i.kt)("inlineCode",{parentName:"p"},"K"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"V"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," type parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject KeyValueStore {\n  def get[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n\n  def set[K: Tag, V: Tag, E: Tag](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n\n  def remove[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =\n    ZIO.serviceWithZIO(_.remove(key))\n}\n")),(0,i.kt)("p",null,"Now, we can continue and implement the in-memory version of this key-value store:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, String, IO] {\n\n  override def get(key: String): IO[String, Int] =\n    map.get.map(_.get(key)).someOrFail(s"$key not found")\n\n  override def set(key: String, value: Int): IO[String, Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def remove(key: String): IO[String, Unit] =\n    map.update(_.removed(key))\n}\n\nobject InmemoryKeyValueStore {\n  def layer: ULayer[KeyValueStore[String, Int, String, IO]] =\n    ZLayer {\n      Ref.make(Map[String, Int]()).map(InmemoryKeyValueStore.apply)\n    }\n}\n')),(0,i.kt)("p",null,"The last step is to use the service in a ZIO application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[KeyValueStore[String, Int, String, IO], String, Unit] =\n    for {\n      _ <- KeyValueStore.set[String, Int, String]("key1", 3).debug\n      _ <- KeyValueStore.get[String, Int, String]("key1").debug\n      _ <- KeyValueStore.remove[String, Int, String]("key1")\n      _ <- KeyValueStore.get[String, Int, String]("key1").either.debug\n    } yield ()\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer)\n  \n}\n')),(0,i.kt)("p",null,"Note that in the above example, one might want to write accessors more polymorphic. So in this case we should add ",(0,i.kt)("inlineCode",{parentName:"p"},"TagKK")," as a context-bound of the ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," type parameter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object KeyValueStore {\n  def get[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =\n    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.get(key))\n\n  def set[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K, value: V): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =\n    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.set(key, value))\n\n  def remove[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], E, Unit] =\n    ZIO.serviceWith(_.remove(key))\n}\n")),(0,i.kt)("h3",{id:"generating-accessor-methods-using-macros"},"Generating Accessor Methods Using Macros"),(0,i.kt)("p",null,"Writing accessor methods is a repetitive task and would be cumbersome in services with many methods. We can automate the generation of accessor methods using ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-macro")," module. "),(0,i.kt)("p",null,"To install the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-macro")," we should add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-macros" % "<zio-version>"\n')),(0,i.kt)("p",null,"Also, to enable macro expansion we need to setup our project:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"for Scala ",(0,i.kt)("inlineCode",{parentName:"p"},">= 2.13")," add compiler option:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'scalacOptions += "-Ymacro-annotations"\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"for Scala ",(0,i.kt)("inlineCode",{parentName:"p"},"< 2.13")," add macro paradise compiler plugin:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'compilerPlugin(("org.scalamacros" % "paradise"  % "2.1.1") cross CrossVersion.full)\n')))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note:")),(0,i.kt)("p",{parentName:"blockquote"},"At the moment these are only available for Scala versions ",(0,i.kt)("inlineCode",{parentName:"p"},"2.x"),", however their equivalents for Scala 3 are on our roadmap.")),(0,i.kt)("h4",{id:"monomorphic-services"},"Monomorphic Services"),(0,i.kt)("p",null,"We can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@accessible")," macro to generate ",(0,i.kt)("em",{parentName:"p"},"service member accessors"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait ServiceA {\n  def method(input: Something): UIO[Unit]\n}\n\n// below will be autogenerated\nobject ServiceA {\n  def method(input: Something) =\n    ZIO.serviceWithZIO[ServiceA](_.method(event))\n}\n")),(0,i.kt)("p",null,"For normal values, a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," on error channel is generated:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait ServiceB {\n  def pureMethod(input: Something): SomethingElse\n}\n\n// below will be autogenerated\nobject ServiceB {\n  def pureMethod(input: Something): ZIO[ServiceB, Nothing, SomethingElse] =\n    ZIO.serviceWith[ServiceB](_.pureMethod(input))\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"@throwing")," annotation will mark impure methods. Using this annotation will request ZIO to push the error on the error channel:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.macros.accessible\nimport zio.macros.throwing\n\n@accessible\ntrait ServiceC {\n  @throwing\n  def impureMethod(input: Something): SomethingElse\n}\n\n// below will be autogenerated\nobject ServiceC {\n  def impureMethod(input: Something): ZIO[ServiceC, Throwable, SomethingElse] =\n    ZIO.serviceWithZIO[ServiceC](s => ZIO(s.impureMethod(input)))\n}\n")),(0,i.kt)("p",null,"Below is a fully working example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait KeyValueStore {\n  def set(key: String, value: Int): Task[Int]\n\n  def get(key: String): Task[Int]\n}\n\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _   <- KeyValueStore.set("key", 5)\n      key <- KeyValueStore.get("key")\n    } yield key\n    \n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n')),(0,i.kt)("h4",{id:"writing-polymorphic-services"},"Writing Polymorphic Services"),(0,i.kt)("h5",{id:"with-proper-type-parameters"},"With Proper Type Parameters"),(0,i.kt)("p",null,"If the service is polymorphic for some proper types, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@accessible")," macro like previous examples."),(0,i.kt)("p",null,"Assume we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyValueStore")," like below, as we will see using ",(0,i.kt)("inlineCode",{parentName:"p"},"@accessible")," will generate us the accessor methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.macros.accessible\n\n\n@accessible\ntrait KeyValueStore[K, V] {\n  def set(key: K, value: V): Task[V]\n\n  def get(key: K): Task[V]\n}\n\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int] {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _ <- KeyValueStore.set("key", 5)\n      key <- KeyValueStore.get[String, Int]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n')),(0,i.kt)("h5",{id:"with-higher-kinded-type-parameters-f_"},"With Higher-Kinded Type Parameters (",(0,i.kt)("inlineCode",{parentName:"h5"},"F[_]"),")"),(0,i.kt)("p",null,"If a service has a higher-kinded type parameter like ",(0,i.kt)("inlineCode",{parentName:"p"},"F[_]")," we should use the ",(0,i.kt)("inlineCode",{parentName:"p"},"accessibleM")," macro. Here is an example of such a service:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.macros.accessibleM\n\n@accessibleM[Task]\ntrait KeyValueStore[K, V, F[_]] {\n  def set(key: K, value: V): F[V]\n\n  def get(key: K): F[V]\n}\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, Task] {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int, Task]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      key <- KeyValueStore.set[String, Int]("key", 5)\n      _   <- KeyValueStore.get[String, Int]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n\n')),(0,i.kt)("h5",{id:"with-higher-kinded-type-parameters-f_-_"},"With Higher-Kinded Type Parameters (",(0,i.kt)("inlineCode",{parentName:"h5"},"F[_, _]"),")"),(0,i.kt)("p",null,"If the service has a higher-kinded type parameter like ",(0,i.kt)("inlineCode",{parentName:"p"},"F[_, _]")," we should use the ",(0,i.kt)("inlineCode",{parentName:"p"},"accessibleMM")," macro. Let's see an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.macros.accessibleMM\n\n@accessibleMM[IO]\ntrait KeyValueStore[K, V, E, F[_, _]] {\n  def set(key: K, value: V): F[E, V]\n\n  def get(key: K): F[E, V]\n}\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, String, IO] {\n  override def set(key: String, value: Int): IO[String, Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): IO[String, Int] =\n    map.get.map(_.get(key)).someOrFail(s"key not found: $key")\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int, String, IO]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _   <- KeyValueStore.set[String, Int, String]("key", 5)\n      key <- KeyValueStore.get[String, Int, String]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n\n}\n')),(0,i.kt)("h4",{id:"support-for-scala-3"},"Support for Scala 3"),(0,i.kt)("p",null,"As we\u2019ve already mentioned, currently we have no macro support for Scala 3, instead we provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"Accessible")," trait that is a macro-less means of creating accessors from services. We can simply extend the companion object with ",(0,i.kt)("inlineCode",{parentName:"p"},"Accessible[ServiceName]")," and then call ",(0,i.kt)("inlineCode",{parentName:"p"},"Companion(_.someMethod)")," to return a ZIO effect that requires the service in its environment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait ServiceD {\n  def method(input: Int): Task[String]\n  def anotherMethod: UIO[Int]\n}\n\nobject ServiceD extends Accessible[ServiceD]\n\nval myApp: ZIO[ServiceD, Throwable, (String, Int)] =\n  for {\n    s <- ServiceD(_.method(3))\n    i <- ServiceD(_.anotherMethod)\n  } yield (s, i)\n")),(0,i.kt)("h3",{id:"the-three-laws-of-zio-environment"},"The Three Laws of ZIO Environment"),(0,i.kt)("p",null,'When we are working with the ZIO environment, one question might arise: "When should we use environment and when do we need to use constructors?".'),(0,i.kt)("p",null,"Using ZIO environment follows three laws:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Service Interface (Trait)")," \u2014 When we are defining service interfaces we should ",(0,i.kt)("em",{parentName:"li"},"never")," use the environment for dependencies of the service itself.")),(0,i.kt)("p",null,"For example, if the implementation of service ",(0,i.kt)("inlineCode",{parentName:"p"},"X")," depends on service ",(0,i.kt)("inlineCode",{parentName:"p"},"Y")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Z")," then these should never be reflected in the trait that defines service ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),". It's leaking implementation details."),(0,i.kt)("p",null,"So the following service definition is wrong because the ",(0,i.kt)("inlineCode",{parentName:"p"},"Console")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," service are dependencies of the  ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," service's implementation, not the ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," interface itself:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\ntrait Logging {\n  def log(line: String): ZIO[Any, Nothing, Unit]\n}\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Service Implementation (Class)")," \u2014 When implementing service interfaces, we should accept all dependencies in the class constructor.")),(0,i.kt)("p",null,"Again, let's see how ",(0,i.kt)("inlineCode",{parentName:"p"},"LoggingLive")," accepts ",(0,i.kt)("inlineCode",{parentName:"p"},"Console")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," dependencies from the class constructor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class LoggingLive(console: Console, clock: Clock) extends Logging {\n  override def log(line: String): UIO[Unit] =\n    for {\n      current <- clock.currentDateTime\n      _       <- console.printLine(s"$current--$line").orDie\n    } yield ()\n}\n')),(0,i.kt)("p",null,"So keep in mind, we can't do something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class LoggingLive() extends Logging {\n  override def log(line: String) =\n    for {\n      clock   <- ZIO.service[Clock]\n      console <- ZIO.service[Console]\n      current <- clock.currentDateTime\n      _       <- console.printLine(s"$current--$line").orDie\n    } yield ()\n}\n\n// error: type mismatch;\n//  found   : zio.ZIO[zio.Console & zio.Clock,Nothing,Unit]\n//     (which expands to)  zio.ZIO[zio.Console with zio.Clock,Nothing,Unit]\n//  required: zio.ZIO[Logging,Nothing,Unit]\n//   def log(line: String): URIO[Logging, Unit] = ZIO.serviceWithZIO[Logging](_.log(line))\n//                                                                            ^^^^^^^^^^^\n')),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Business Logic")," \u2014 Finally, in the business logic we should use the ZIO environment to consume services.")),(0,i.kt)("p",null,"Therefore, in the last example, if we inline all accessor methods whenever we are using services, we are using the ZIO environment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val app: ZIO[Logging, IOException, Unit] =\n    for {\n      _    <- ZIO.serviceWithZIO[Logging](_.log("Application Started!"))\n      _    <- Console.print("Enter your name: ")\n      name <- Console.readLine\n      _    <- Console.printLine(s"Hello, $name!")\n      _    <- ZIO.serviceWithZIO[Logging](_.log("Application Exited!"))\n    } yield ()\n\n  def run = app.provide(LoggingLive.layer)\n}\n')),(0,i.kt)("p",null,"That's it! These are the most important rules we need to know about the ZIO environment."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note"),":"),(0,i.kt)("p",{parentName:"blockquote"},"The remaining part of this section can be skipped if you are not an advanced ZIO user.")),(0,i.kt)("p",null,"Now let's elaborate more on the first rule. On rare occasions, all of which involve local context that is independent of implementation, it's ",(0,i.kt)("em",{parentName:"p"},"acceptable")," to use the environment in the definition of a service."),(0,i.kt)("p",null,"Here are two examples:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"In a web application, a service may be defined only to operate in the context of an HTTP request. In such a case, the request itself could be stored in the environment: ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO[HttpRequest, ...]"),". This is acceptable because this use of the environment is part of the semantics of the trait itself, rather than leaking an implementation detail of some particular class that implements the service trait:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\nimport java.net.URI\nimport java.nio.charset.StandardCharsets\n\ntype HttpApp = ZIO[HttpRequest, Throwable, HttpResponse]\ntype HttpRoute = Map[String, HttpApp]\n\ncase class HttpRequest(method: Int,\n                       uri: URI,\n                       headers: Map[String, String],\n                       body: UStream[Byte])\n\ncase class HttpResponse(status: Int,\n                        headers: Map[String, String],\n                        body: UStream[Byte])\n\nobject HttpResponse {\n  def apply(status: Int, message: String): HttpResponse =\n    HttpResponse(\n      status = status,\n      headers = Map.empty,\n      body = ZStream.fromChunk(\n        Chunk.fromArray(message.getBytes(StandardCharsets.UTF_8))\n      )\n    )\n\n  def ok(msg: String): HttpResponse = HttpResponse(200, msg)\n\n  def error(msg: String): HttpResponse = HttpResponse(800, msg)\n}\n\ntrait HttpServer {\n  def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit]\n}\n\nobject HttpServer {\n  def serve(map: HttpRoute, host: String, port: Int): ZIO[HttpServer, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.serve(map, host, port))\n}\n\ncase class HttpServerLive() extends HttpServer {\n  override def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit] = ???\n}\n\nobject HttpServerLive {\n  val layer: URLayer[Any, HttpServer] = ZLayer.succeed(HttpServerLive())\n}\n\nobject MainWebApp extends ZIOAppDefault {\n\n  val myApp: ZIO[HttpServer, Throwable, Unit] = for {\n    _ <- ZIO.unit\n    healthcheck: HttpApp = ZIO.service[HttpRequest].map { _ =>\n      HttpResponse.ok("up")\n    }\n\n    pingpong = ZIO.service[HttpRequest].flatMap { req =>\n      ZIO.ifZIO(\n        req.body.via(ZPipeline.utf8Decode).runHead.map(_.contains("ping"))\n      )(\n        onTrue = ZIO.attempt(HttpResponse.ok("pong")),\n        onFalse = ZIO.attempt(HttpResponse.error("bad request"))\n      )\n    }\n\n    map = Map(\n      "/healthcheck" -> healthcheck,\n      "/pingpong" -> pingpong\n    )\n    _ <- HttpServer.serve(map, "localhost", 8080)\n  } yield ()\n\n  def run = myApp.provideLayer(HttpServerLive.layer)\n\n}\n')),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"In a database application, a service may be defined only to operate in the context of a larger database transaction. In such a case, the transaction could be stored in the environment: ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO[DatabaseTransaction, ...]"),". As in the previous example, because this is part of the semantics of the trait itself (whose functionality all operates within a transaction), this is not leaking implementation details, and therefore it is valid:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'trait DatabaseTransaction {\n  def get(key: String): Task[Int]\n  def put(key: String, value: Int): Task[Unit]\n}\n\nobject DatabaseTransaction {\n  def get(key: String): ZIO[DatabaseTransaction, Throwable, Int] =\n    ZIO.serviceWithZIO(_.get(key))\n\n  def put(key: String, value: Int): ZIO[DatabaseTransaction, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.put(key, value))\n}\n\ntrait Database {\n  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A]\n}\n\nobject Database {\n  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Database, E, A] =\n    ZIO.serviceWithZIO(_.atomically(zio))\n}\n\ncase class DatabaseLive() extends Database {\n  override def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A] = ???\n}\n\nobject DatabaseLive {\n  val layer = ZLayer.succeed(DatabaseLive())\n}\n\nobject MainDatabaseApp extends ZIOAppDefault {\n  val myApp: ZIO[Database, Throwable, Unit] =\n    for {\n      _ <- Database.atomically(DatabaseTransaction.put("counter", 0))\n      _ <- ZIO.foreachPar(List(1 to 10)) { _ =>\n        Database.atomically(\n          for {\n            value <- DatabaseTransaction.get("counter")\n            _ <- DatabaseTransaction.put("counter", value + 1)\n          } yield ()\n        )\n      }\n    } yield ()\n\n  def run = myApp.provideLayer(DatabaseLive.layer)\n\n}\n')),(0,i.kt)("p",null,"So while it's better to err on the side of \"don't put things into the environment of service interface\", there are cases where it's acceptable."))}c.isMDXComponent=!0}}]);