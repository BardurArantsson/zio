"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[79915],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=d(a),h=o,c=u["".concat(s,".").concat(h)]||u[h]||p[h]||i;return a?n.createElement(c,r(r({ref:t},m),{},{components:a})):n.createElement(c,r({ref:t},m))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},6101:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=a(87462),o=(a(67294),a(3905));const i={id:"remote",title:"Remote"},r="Remote Values",l={unversionedId:"remote",id:"remote",title:"Remote",description:"The Remote data type forms the backbone of ZIO Flow and allows us to safely describe values that may be part of computations on multiple remote nodes.",source:"@site/node_modules/@zio.dev/zio-flow/remote.md",sourceDirName:".",slug:"/remote",permalink:"/zio-flow/remote",draft:!1,tags:[],version:"current",frontMatter:{id:"remote",title:"Remote"},sidebar:"sidebar",previous:{title:"DynamoDB Key-value Store",permalink:"/zio-flow/dynamodb-key-value-store"}},s={},d=[],m={toc:d};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"remote-values"},"Remote Values"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," data type forms the backbone of ZIO Flow and allows us to safely describe values that may be part of computations on multiple remote nodes."),(0,o.kt)("p",null,"In ordinary Scala we are used to working with values defined by the Scala library such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," as well as user defined data types such as a ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," and interfaces such as a ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService"),". The problem with using these data types in a distributed in a setting where we need to perform distributed or resilient workflows is that these data types may not actually be safely serializable and cause our programs to fail at runtime."),(0,o.kt)("p",null,"Even if we are extremely diligent about trying to avoid this, it can be easy to avoid accidentally closing over other variables, resulting in data that is either not serializable or takes up much more space than we intended. This is an infamous problem with frameworks like Spark despite their best efforts to avoid it."),(0,o.kt)("p",null,"ZIO Flow handles this issue in a principled way with its ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," data type, which is a ",(0,o.kt)("em",{parentName:"p"},"description")," of a value that may potentially exist on a remote node. This way you can easily look at any value and tell just from its type whether it is a ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," value that is safe to use in resilient, distributed computations or an ordinary value that is fine to use on a single node but does not provide these guarantees."),(0,o.kt)("p",null,"Generally ZIO Flow will require that the values we work with be ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," values so that it can safely replicate them across multiple nodes or reload them from durable storage in the event of a failure."),(0,o.kt)("p",null,"For example, compare the signature of the ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," operator on ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ZFlow"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.flow._\n\ntrait ZIO[-R, +E, +A] {\n  def map[B](f: A => B): ZIO[R, E, B]\n}\n\ntrait ZFlow[-R, +E, +A] {\n  def map[B](f: Remote[A] => Remote[B]): ZFlow[R, E, B]\n}\n")),(0,o.kt)("p",null,"There are a couple of things that should jump out at you from this."),(0,o.kt)("p",null,"First, the method signatures are nearly identical! You will find this frequently with ZIO Flow, where most of the operators you are familiar with from ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," like ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," also exist on ",(0,o.kt)("inlineCode",{parentName:"p"},"ZFlow")," so if you know ZIO you are already ready to go."),(0,o.kt)("p",null,"Second, you will notice that the one thing that differs between these type signatures is that whereas ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#map")," accepts a function ",(0,o.kt)("inlineCode",{parentName:"p"},"A => B"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ZFlow#map")," accepts a function ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote[A] => Remote[B]"),". This makes sense because ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," describes a workflow on a single machine whereas ",(0,o.kt)("inlineCode",{parentName:"p"},"ZFlow")," describes a resilient, distributed, computation, so the values we are working with must be of the form ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote[A]")," rather than ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,o.kt)("h1",{id:"working-with-remote-values"},"Working With Remote Values"),(0,o.kt)("p",null,"At this point you might be worried that despite these benefits, working with remote values could involve additional boilerplate. We know how to add two ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," values, but how do we add two ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote[Int]")," values?"),(0,o.kt)("p",null,"Fortunately, ZIO Flow goes to great lengths to make working with ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote"),' values as ergonomic as possible, so we can almost "forget" that we are working with something other than ordinary values at all.'),(0,o.kt)("p",null,"The main way ZIO Flow does this is by providing operators on remote values that mirror the operators on ordinary values. For example, we can add two ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote[Int]")," values by simply adding the two values together:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.flow._\n\nval left: Remote[Int] = Remote(1)\n// left: Remote[Int] = Literal(\n//   value = Primitive(value = 1, standardType = int)\n// )\nval right: Remote[Int] = Remote(1)\n// right: Remote[Int] = Literal(\n//   value = Primitive(value = 1, standardType = int)\n// )\n\nval sum: Remote[Int] = left + right\n// sum: Remote[Int] = Binary(\n//   left = Literal(value = Primitive(value = 1, standardType = int)),\n//   right = Literal(value = Primitive(value = 1, standardType = int)),\n//   operator = Numeric(\n//     operator = Add,\n//     numeric = zio.flow.remote.numeric.Numeric$NumericInt$@5cd848bc\n//   )\n// )\n")),(0,o.kt)("p",null,"We see here that we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," constructor on ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," to lift any existing value into a remote value as long as there is a ",(0,o.kt)("inlineCode",{parentName:"p"},"Schema")," for it. We'll talk more about schemas below but you can think of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Schema"),' as describing the "structure" of some Scala type as a value, allowing us to safely serialize it and deserialize it, among other things.'),(0,o.kt)("p",null,"In fact ZIO Flow will convert ordinary values into remote values for us automatically when needed. So we could also do this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val flow: ZFlow[Any, Nothing, Int] =\n  ZFlow.succeed(1)\n// flow: ZFlow[Any, Nothing, Int] = Return(\n//   value = Literal(value = Primitive(value = 1, standardType = int))\n// )\n\nval incrementedFlow: ZFlow[Any, Nothing, Int] =\n  flow.map(_ + 1)\n// incrementedFlow: ZFlow[Any, Nothing, Int] = Fold(\n//   value = Return(\n//     value = Literal(value = Primitive(value = 1, standardType = int))\n//   ),\n//   errorCase = None,\n//   successCase = Some(\n//     value = UnboundRemoteFunction(\n//       input = Unbound(identifier = bfcebd66-d758-4906-a9e2-c4fb55249376),\n//       result = Flow(\n//         flow = Return(\n//           value = Binary(\n//             left = Unbound(identifier = bfcebd66-d758-4906-a9e2-c4fb55249376),\n//             right = Literal(value = Primitive(value = 1, standardType = int)),\n//             operator = Numeric(\n//               operator = Add,\n//               numeric = zio.flow.remote.numeric.Numeric$NumericInt$@5cd848bc\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n")),(0,o.kt)("p",null,"Notice that here the function we provided to ",(0,o.kt)("inlineCode",{parentName:"p"},"ZFlow#map")," looked identical to the one we would provide to ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#map")," in a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO"),' application. This is exactly the interface we want and lets use "forget" in most cases that we are working with the world of ',(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," values instead of the world of normal values."),(0,o.kt)("p",null,"This also reflects the idea that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote"),' world is a "mirror" of the world of ordinary values and absent underlying implementation limitations (e.g. arbitrary Scala functions are not serializable) the interface for working with ',(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," values should look and feel as similar to the interface for working with ordinary values as possible."),(0,o.kt)("p",null,"This also means that if you know how to do something in ordinary Scala you also already know how to do it with ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," values."),(0,o.kt)("p",null,"We are definitely working on ensuring that the experience of working with ",(0,o.kt)("inlineCode",{parentName:"p"},"Remote")," values is as good as working with ordinary values. So if you see an area where this is not the case please reach out to us on Discord or open an issue so that we can improve it!"),(0,o.kt)("h1",{id:"working-with-schemas"},"Working With Schemas"),(0,o.kt)("p",null,"As discussed above, a ",(0,o.kt)("inlineCode",{parentName:"p"},"Schema"),' describes the "structure" of some Scala type as a value. This lets us know how to serialize and deserialize the value, as well as providing other useful functional like migrations between two versions of a data type.'),(0,o.kt)("p",null,"Schemas are provided by ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO Schema"),", a library that is exclusively focused on defining these schemas, providing schemas for various data types, and enabling useful functionality with them. When we are working with data types defined by the Scala or Java standard libraries schemas should already automatically be available as long as the data type can be safely serialized and deserialized."),(0,o.kt)("p",null,'ZIO Flow uses those schemas internally and as long as they exist things "just work". So you may have noticed that we didn\'t have to do anything with schemas when we did ',(0,o.kt)("inlineCode",{parentName:"p"},"Remote(1)")," because a schema for ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," values already exists."),(0,o.kt)("p",null,"The one time you will typically have to work with schemas directly is in defining schemas for your own custom data types. Fortunately this is very easy!"),(0,o.kt)("p",null,"In idiomatic Scala and in ZIO Flow we always define our data types as either a ",(0,o.kt)("inlineCode",{parentName:"p"},"case class")," to represent data that has one thing ",(0,o.kt)("em",{parentName:"p"},"and")," has another thing (e.g. a credit card has a name and a number) or a ",(0,o.kt)("inlineCode",{parentName:"p"},"sealed trait")," to represent data that is one ",(0,o.kt)("em",{parentName:"p"},"or")," is another thing (e.g. a payment method is either credit card or check)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait PaymentMethod\n\ncase class CreditCard(name: String, number: String) extends PaymentMethod\ncase class Check(name: String, routing: String) extends PaymentMethod\n")),(0,o.kt)("p",null,"Notice how even in this simple example we have combined these two techniques to model a more complex domain with both of these types."),(0,o.kt)("p",null,"As long as we model our data this way, we can automatically generate schemas for our data types using the ",(0,o.kt)("inlineCode",{parentName:"p"},"DeriveSchema.gen")," operator. For example, let's see how we could generate a schema for our ",(0,o.kt)("inlineCode",{parentName:"p"},"PaymentMethod")," data type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.schema._\n\nobject PaymentMethod {\n  implicit val schema: Schema[PaymentMethod] = DeriveSchema.gen\n}\n")),(0,o.kt)("p",null,"We should be sure to define our schemas in the companion objects of the data types they describe the structure of, like we did by putting the ",(0,o.kt)("inlineCode",{parentName:"p"},"schema")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"PaymentMethod")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"PaymentMethod")," companion object here. We should also declare it as an ",(0,o.kt)("inlineCode",{parentName:"p"},"implicit val")," so that the compiler can automatically find the schema when needed."),(0,o.kt)("p",null,"Other than that the hardest thing is remembering to import ZIO Schema!"),(0,o.kt)("p",null,"With the schema defined this way, we can construct remote versions of ",(0,o.kt)("inlineCode",{parentName:"p"},"PaymentMethod")," values just like we did for ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val remotePaymentMethod: Remote[PaymentMethod] =\n  Remote(CreditCard("John Doe", "123456789"))\n')),(0,o.kt)("p",null,"With this, you know everything you need to work with remote values as part of writing your resilient, distributed application!"))}p.isMDXComponent=!0}}]);