"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[3608],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function u(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){u(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,u=function(e,t){if(null==e)return{};var n,a,u={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(u[n]=e[n]);return u}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(u[n]=e[n])}return u}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,u=e.mdxType,r=e.originalType,o=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=s(n),m=u,f=c["".concat(o,".").concat(m)]||c[m]||d[m]||r;return n?a.createElement(f,l(l({ref:t},p),{},{components:n})):a.createElement(f,l({ref:t},p))}));function m(e,t){var n=arguments,u=t&&t.mdxType;if("string"==typeof e||u){var r=n.length,l=new Array(r);l[0]=c;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:u,l[1]=i;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3425:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var a=n(7462),u=(n(7294),n(3905));const r={id:"queue",title:"Queue"},l=void 0,i={unversionedId:"datatypes/concurrency/queue",id:"datatypes/concurrency/queue",title:"Queue",description:"Queue is a lightweight in-memory queue built on ZIO with composable and transparent back-pressure. It is fully asynchronous (no locks or blocking), purely-functional and type-safe.",source:"@site/docs/datatypes/concurrency/queue.md",sourceDirName:"datatypes/concurrency",slug:"/datatypes/concurrency/queue",permalink:"/datatypes/concurrency/queue",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/datatypes/concurrency/queue.md",tags:[],version:"current",frontMatter:{id:"queue",title:"Queue"},sidebar:"datatypes-sidebar",previous:{title:"Promise",permalink:"/datatypes/concurrency/promise"},next:{title:"Hub",permalink:"/datatypes/concurrency/hub"}},o={},s=[{value:"Creating a queue",id:"creating-a-queue",level:2},{value:"Adding items to a queue",id:"adding-items-to-a-queue",level:2},{value:"Consuming Items from a Queue",id:"consuming-items-from-a-queue",level:2},{value:"Shutting Down a Queue",id:"shutting-down-a-queue",level:2},{value:"Additional Resources",id:"additional-resources",level:2}],p={toc:s};function d(e){let{components:t,...n}=e;return(0,u.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,u.kt)("p",null,(0,u.kt)("inlineCode",{parentName:"p"},"Queue")," is a lightweight in-memory queue built on ZIO with composable and transparent back-pressure. It is fully asynchronous (no locks or blocking), purely-functional and type-safe."),(0,u.kt)("p",null,"A ",(0,u.kt)("inlineCode",{parentName:"p"},"Queue[A]")," contains values of type ",(0,u.kt)("inlineCode",{parentName:"p"},"A")," and has two basic operations: ",(0,u.kt)("inlineCode",{parentName:"p"},"offer"),", which places an ",(0,u.kt)("inlineCode",{parentName:"p"},"A")," in the ",(0,u.kt)("inlineCode",{parentName:"p"},"Queue"),", and ",(0,u.kt)("inlineCode",{parentName:"p"},"take")," which removes and returns the oldest value in the ",(0,u.kt)("inlineCode",{parentName:"p"},"Queue"),"."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval res: UIO[Int] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(1)\n  v1 <- queue.take\n} yield v1\n")),(0,u.kt)("h2",{id:"creating-a-queue"},"Creating a queue"),(0,u.kt)("p",null,"A ",(0,u.kt)("inlineCode",{parentName:"p"},"Queue")," can be bounded (with a limited capacity) or unbounded."),(0,u.kt)("p",null,"There are several strategies to process new values when the queue is full:"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"The default ",(0,u.kt)("inlineCode",{parentName:"li"},"bounded")," queue is back-pressured: when full, any offering fiber will be suspended until the queue is able to add the item"),(0,u.kt)("li",{parentName:"ul"},"A ",(0,u.kt)("inlineCode",{parentName:"li"},"dropping")," queue will drop new items when the queue is full"),(0,u.kt)("li",{parentName:"ul"},"A ",(0,u.kt)("inlineCode",{parentName:"li"},"sliding")," queue will drop old items when the queue is full")),(0,u.kt)("p",null,"To create a back-pressured bounded queue:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val boundedQueue: UIO[Queue[Int]] = Queue.bounded[Int](100)\n")),(0,u.kt)("p",null,"To create a dropping queue:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val droppingQueue: UIO[Queue[Int]] = Queue.dropping[Int](100)\n")),(0,u.kt)("p",null,"To create a sliding queue:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val slidingQueue: UIO[Queue[Int]] = Queue.sliding[Int](100)\n")),(0,u.kt)("p",null,"To create an unbounded queue:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val unboundedQueue: UIO[Queue[Int]] = Queue.unbounded[Int]\n")),(0,u.kt)("h2",{id:"adding-items-to-a-queue"},"Adding items to a queue"),(0,u.kt)("p",null,"The simplest way to add a value to the queue is ",(0,u.kt)("inlineCode",{parentName:"p"},"offer"),":"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val res1: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(1)\n} yield ()\n")),(0,u.kt)("p",null,"When using a back-pressured queue, offer might suspend if the queue is full: you can use ",(0,u.kt)("inlineCode",{parentName:"p"},"fork")," to wait in a different fiber."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val res2: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](1)\n  _ <- queue.offer(1)\n  f <- queue.offer(1).fork // will be suspended because the queue is full\n  _ <- queue.take\n  _ <- f.join\n} yield ()\n")),(0,u.kt)("p",null,"It is also possible to add multiple values at once with ",(0,u.kt)("inlineCode",{parentName:"p"},"offerAll"),":"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val res3: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](100)\n  items = Range.inclusive(1, 10).toList\n  _ <- queue.offerAll(items)\n} yield ()\n")),(0,u.kt)("h2",{id:"consuming-items-from-a-queue"},"Consuming Items from a Queue"),(0,u.kt)("p",null,"The ",(0,u.kt)("inlineCode",{parentName:"p"},"take")," operation removes the oldest item from the queue and returns it. If the queue is empty, this will suspend, and resume only when an item has been added to the queue. As with ",(0,u.kt)("inlineCode",{parentName:"p"},"offer"),", you can use ",(0,u.kt)("inlineCode",{parentName:"p"},"fork")," to wait for the value in a different fiber."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},'val oldestItem: UIO[String] = for {\n  queue <- Queue.bounded[String](100)\n  f <- queue.take.fork // will be suspended because the queue is empty\n  _ <- queue.offer("something")\n  v <- f.join\n} yield v\n')),(0,u.kt)("p",null,"You can consume the first item with ",(0,u.kt)("inlineCode",{parentName:"p"},"poll"),". If the queue is empty you will get ",(0,u.kt)("inlineCode",{parentName:"p"},"None"),", otherwise the top item will be returned wrapped in ",(0,u.kt)("inlineCode",{parentName:"p"},"Some"),"."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val polled: UIO[Option[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(10)\n  _ <- queue.offer(20)\n  head <- queue.poll\n} yield head\n")),(0,u.kt)("p",null,"You can consume multiple items at once with ",(0,u.kt)("inlineCode",{parentName:"p"},"takeUpTo"),". If the queue doesn't have enough items to return, it will return all the items without waiting for more offers."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val taken: UIO[Chunk[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(10)\n  _ <- queue.offer(20)\n  chunk  <- queue.takeUpTo(5)\n} yield chunk\n")),(0,u.kt)("p",null,"Similarly, you can get all items at once with ",(0,u.kt)("inlineCode",{parentName:"p"},"takeAll"),". It also returns without waiting (an empty collection if the queue is empty)."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val all: UIO[Chunk[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(10)\n  _ <- queue.offer(20)\n  chunk  <- queue.takeAll\n} yield chunk\n")),(0,u.kt)("h2",{id:"shutting-down-a-queue"},"Shutting Down a Queue"),(0,u.kt)("p",null,"It is possible with ",(0,u.kt)("inlineCode",{parentName:"p"},"shutdown")," to interrupt all the fibers that are suspended on ",(0,u.kt)("inlineCode",{parentName:"p"},"offer*")," or ",(0,u.kt)("inlineCode",{parentName:"p"},"take*"),". It will also empty the queue and make all future calls to ",(0,u.kt)("inlineCode",{parentName:"p"},"offer*")," and ",(0,u.kt)("inlineCode",{parentName:"p"},"take*")," terminate immediately."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val takeFromShutdownQueue: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](3)\n  f <- queue.take.fork\n  _ <- queue.shutdown // will interrupt f\n  _ <- f.join // Will terminate\n} yield ()\n")),(0,u.kt)("p",null,"You can use ",(0,u.kt)("inlineCode",{parentName:"p"},"awaitShutdown")," to execute an effect when the queue is shut down. This will wait until the queue is shut down. If the queue is already shut down, it will resume right away."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-scala"},"val awaitShutdown: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](3)\n  p <- Promise.make[Nothing, Boolean]\n  f <- queue.awaitShutdown.fork\n  _ <- queue.shutdown\n  _ <- f.join\n} yield ()\n")),(0,u.kt)("h2",{id:"additional-resources"},"Additional Resources"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",{parentName:"li",href:"https://www.slideshare.net/jdegoes/zio-queue"},"ZIO Queue Talk by John De Goes @ ScalaWave 2018")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",{parentName:"li",href:"https://www.slideshare.net/wiemzin/psug-zio-queue"},"ZIO Queue Talk by Wiem Zine El Abidine @ PSUG 2018")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",{parentName:"li",href:"https://medium.com/@wiemzin/elevator-control-system-using-zio-c718ae423c58"},"Elevator Control System using ZIO")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",{parentName:"li",href:"https://blog.softwaremill.com/scalaz-8-io-vs-akka-typed-actors-vs-monix-part-1-5672657169e1"},"Scalaz 8 IO vs Akka (typed) actors vs Monix"))))}d.isMDXComponent=!0}}]);