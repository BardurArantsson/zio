"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[24439],{19552:e=>{e.exports=JSON.parse('{"pluginId":"zio-prelude","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"sidebar":[{"type":"link","label":"ZIO Prelude","href":"/zio-prelude/","docId":"index"},{"type":"link","label":"Abstraction Diagrams","href":"/zio-prelude/abstraction-diagrams","docId":"abstraction-diagrams"},{"type":"category","label":"Functional Abstractions","collapsed":false,"items":[{"type":"category","label":"Concrete Types","collapsed":false,"items":[{"type":"link","label":"Associative","href":"/zio-prelude/functionalabstractions/concretetypes/associative","docId":"functionalabstractions/concretetypes/associative"},{"type":"link","label":"Commutative","href":"/zio-prelude/functionalabstractions/concretetypes/commutative","docId":"functionalabstractions/concretetypes/commutative"},{"type":"link","label":"Debug","href":"/zio-prelude/functionalabstractions/concretetypes/debug","docId":"functionalabstractions/concretetypes/debug"},{"type":"link","label":"Equal","href":"/zio-prelude/functionalabstractions/concretetypes/equal","docId":"functionalabstractions/concretetypes/equal"},{"type":"link","label":"Hash","href":"/zio-prelude/functionalabstractions/concretetypes/hash","docId":"functionalabstractions/concretetypes/hash"},{"type":"link","label":"Identity","href":"/zio-prelude/functionalabstractions/concretetypes/identity","docId":"functionalabstractions/concretetypes/identity"},{"type":"link","label":"Inverse","href":"/zio-prelude/functionalabstractions/concretetypes/inverse","docId":"functionalabstractions/concretetypes/inverse"},{"type":"link","label":"Ord","href":"/zio-prelude/functionalabstractions/concretetypes/ord","docId":"functionalabstractions/concretetypes/ord"}],"collapsible":true,"href":"/zio-prelude/functionalabstractions/concretetypes/"},{"type":"category","label":"Parameterized Types","collapsed":false,"items":[{"type":"link","label":"AssociativeBoth","href":"/zio-prelude/functionalabstractions/parameterizedtypes/associativeboth","docId":"functionalabstractions/parameterizedtypes/associativeboth"},{"type":"link","label":"AssociativeEither","href":"/zio-prelude/functionalabstractions/parameterizedtypes/associativeeither","docId":"functionalabstractions/parameterizedtypes/associativeeither"},{"type":"link","label":"AssociativeFlatten","href":"/zio-prelude/functionalabstractions/parameterizedtypes/associativeflatten","docId":"functionalabstractions/parameterizedtypes/associativeflatten"},{"type":"link","label":"CommutativeBoth","href":"/zio-prelude/functionalabstractions/parameterizedtypes/commutativeboth","docId":"functionalabstractions/parameterizedtypes/commutativeboth"},{"type":"link","label":"CommutativeEither","href":"/zio-prelude/functionalabstractions/parameterizedtypes/commutativeeither","docId":"functionalabstractions/parameterizedtypes/commutativeeither"},{"type":"link","label":"Contravariant","href":"/zio-prelude/functionalabstractions/parameterizedtypes/contravariant","docId":"functionalabstractions/parameterizedtypes/contravariant"},{"type":"link","label":"Covariant","href":"/zio-prelude/functionalabstractions/parameterizedtypes/covariant","docId":"functionalabstractions/parameterizedtypes/covariant"},{"type":"link","label":"ForEach","href":"/zio-prelude/functionalabstractions/parameterizedtypes/foreach","docId":"functionalabstractions/parameterizedtypes/foreach"},{"type":"link","label":"IdentityBoth","href":"/zio-prelude/functionalabstractions/parameterizedtypes/identityboth","docId":"functionalabstractions/parameterizedtypes/identityboth"},{"type":"link","label":"IdentityEither","href":"/zio-prelude/functionalabstractions/parameterizedtypes/identityeither","docId":"functionalabstractions/parameterizedtypes/identityeither"},{"type":"link","label":"IdentityFlatten","href":"/zio-prelude/functionalabstractions/parameterizedtypes/identityflatten","docId":"functionalabstractions/parameterizedtypes/identityflatten"},{"type":"link","label":"Invariant","href":"/zio-prelude/functionalabstractions/parameterizedtypes/invariant","docId":"functionalabstractions/parameterizedtypes/invariant"},{"type":"link","label":"NonEmptyForEach","href":"/zio-prelude/functionalabstractions/parameterizedtypes/nonemptyforeach","docId":"functionalabstractions/parameterizedtypes/nonemptyforeach"}],"collapsible":true,"href":"/zio-prelude/functionalabstractions/parameterizedtypes/"}],"collapsible":true,"href":"/zio-prelude/functionalabstractions/"},{"type":"category","label":"Functional Data Types","collapsed":false,"items":[{"type":"link","label":"Equivalence","href":"/zio-prelude/functionaldatatypes/equivalence","docId":"functionaldatatypes/equivalence"},{"type":"link","label":"NonEmptyList","href":"/zio-prelude/functionaldatatypes/nonemptylist","docId":"functionaldatatypes/nonemptylist"},{"type":"link","label":"These","href":"/zio-prelude/functionaldatatypes/these","docId":"functionaldatatypes/these"},{"type":"link","label":"Validation","href":"/zio-prelude/functionaldatatypes/validation","docId":"functionaldatatypes/validation"},{"type":"link","label":"ZSet","href":"/zio-prelude/functionaldatatypes/zset","docId":"functionaldatatypes/zset"},{"type":"link","label":"ZValidation","href":"/zio-prelude/functionaldatatypes/zvalidation","docId":"functionaldatatypes/zvalidation"}],"collapsible":true,"href":"/zio-prelude/functionaldatatypes/"},{"type":"link","label":"New Types","href":"/zio-prelude/newtypes/","docId":"newtypes/index"},{"type":"link","label":"ZPure","href":"/zio-prelude/zpure/","docId":"zpure/index"}]},"docs":{"abstraction-diagrams":{"id":"abstraction-diagrams","title":"Abstraction Diagrams","description":"Absorption hierarchy","sidebar":"sidebar"},"functionalabstractions/concretetypes/associative":{"id":"functionalabstractions/concretetypes/associative","title":"Associative","description":"Associative[A] describes a way of combining two values of type A that is associative.","sidebar":"sidebar"},"functionalabstractions/concretetypes/commutative":{"id":"functionalabstractions/concretetypes/commutative","title":"Commutative","description":"Commutative[A] describes a data type that has a combine operator that is commutative and associative.","sidebar":"sidebar"},"functionalabstractions/concretetypes/debug":{"id":"functionalabstractions/concretetypes/debug","title":"Debug","description":"Debug[A] describes the ability to render a value of type A to a human readable format for debugging purposes.","sidebar":"sidebar"},"functionalabstractions/concretetypes/equal":{"id":"functionalabstractions/concretetypes/equal","title":"Equal","description":"Equal[A] describes the ability to compare two values of type A for equality.","sidebar":"sidebar"},"functionalabstractions/concretetypes/hash":{"id":"functionalabstractions/concretetypes/hash","title":"Hash","description":"Hash[A] describes the ability to hash a value of type A.","sidebar":"sidebar"},"functionalabstractions/concretetypes/identity":{"id":"functionalabstractions/concretetypes/identity","title":"Identity","description":"Identity[A] describes a data type with an associative combining operation that also has an identity element.","sidebar":"sidebar"},"functionalabstractions/concretetypes/index":{"id":"functionalabstractions/concretetypes/index","title":"Introduction","description":"ZIO Prelude features a set of fundamental functional abstractions for working with concrete data types.","sidebar":"sidebar"},"functionalabstractions/concretetypes/inverse":{"id":"functionalabstractions/concretetypes/inverse","title":"Inverse","description":"Inverse[A] describes a type that has a combine operator and also has an inverse operator that is the inverse of the combine operator.","sidebar":"sidebar"},"functionalabstractions/concretetypes/ord":{"id":"functionalabstractions/concretetypes/ord","title":"Ord","description":"Ord[A] describes a total ordering on values of type A.","sidebar":"sidebar"},"functionalabstractions/index":{"id":"functionalabstractions/index","title":"Introduction","description":"ZIO Prelude features a next generation approach to functional abstractions. This approach is based on the following ideas:","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/associativeboth":{"id":"functionalabstractions/parameterizedtypes/associativeboth","title":"AssociativeBoth","description":"AssociativeBoth[F] describes a way of combining two values F[A] and F[B] into a value F[(A, B)] that is associative.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/associativeeither":{"id":"functionalabstractions/parameterizedtypes/associativeeither","title":"AssociativeEither","description":"AssociativeEither describes a way of combining two values F[A] and F[B] into a value F[Either[A, B]] that is associative.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/associativeflatten":{"id":"functionalabstractions/parameterizedtypes/associativeflatten","title":"AssociativeFlatten","description":"AssociativeFlatten[F] describes a way of combining two layers of a value of type F[F[A]] into a F[A] in a way that is associative.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/commutativeboth":{"id":"functionalabstractions/parameterizedtypes/commutativeboth","title":"CommutativeBoth","description":"CommutativeBoth[F] describes a way of combining two values F[A] and F[B] into a value F[(A, B)] that is commutative.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/commutativeeither":{"id":"functionalabstractions/parameterizedtypes/commutativeeither","title":"CommutativeEither","description":"CommutativeEither[F] describes a way of combining two parameterized types F[A] and F[B] that is commutative.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/contravariant":{"id":"functionalabstractions/parameterizedtypes/contravariant","title":"Contravariant","description":"Contravariant describes a parameterized type F[A] that potentially consumes but never produces A values.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/covariant":{"id":"functionalabstractions/parameterizedtypes/covariant","title":"Covariant","description":"Covariant[F] describes a parameterized type F[A] that potentially produces but never consumes A values.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/foreach":{"id":"functionalabstractions/parameterizedtypes/foreach","title":"ForEach","description":"ForEach[F] describes a parameterized type F[A] that contains zero or more values of type A.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/identityboth":{"id":"functionalabstractions/parameterizedtypes/identityboth","title":"IdentityBoth","description":"IdentityBoth[F] describes an associative way to combine two values F[A] and F[B] into a value F[(A, B)] that also has an identity element of type F[Any].","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/identityeither":{"id":"functionalabstractions/parameterizedtypes/identityeither","title":"IdentityEither","description":"IdentityEither[F] describes an associative way to combine two values F[A] and F[B] into a value F[Either[A, B]] with an identity value none of type F[Nothing].","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/identityflatten":{"id":"functionalabstractions/parameterizedtypes/identityflatten","title":"IdentityFlatten","description":"IdentityFlatten[F] describes a way of combining two layers of a value of type F[F[A]] into a F[A] in a way that is associative and has an identity value any of type F[Any].","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/index":{"id":"functionalabstractions/parameterizedtypes/index","title":"Introduction","description":"In addition to abstractions for concrete types, ZIO Prelude provides a set of functional abstractions to describe the common structure of parameterized types.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/invariant":{"id":"functionalabstractions/parameterizedtypes/invariant","title":"Invariant","description":"Invariant[F] describes a parameterized type F[A] that potentially both consumes and produces A values.","sidebar":"sidebar"},"functionalabstractions/parameterizedtypes/nonemptyforeach":{"id":"functionalabstractions/parameterizedtypes/nonemptyforeach","title":"NonEmptyForEach","description":"NomEmptyForEach[F] describes a parameterized type F[A] that contains one or more values of type A.","sidebar":"sidebar"},"functionaldatatypes/equivalence":{"id":"functionaldatatypes/equivalence","title":"Equivalence","description":"An Equivalence[A, B] describes an equivalence relationship between two types A and B.","sidebar":"sidebar"},"functionaldatatypes/index":{"id":"functionaldatatypes/index","title":"Summary","description":"ZIO Prelude includes several data types to help us model our domains more accurately and solve common problems.","sidebar":"sidebar"},"functionaldatatypes/nonemptylist":{"id":"functionaldatatypes/nonemptylist","title":"NonEmptyList","description":"NonEmptyList represents a List that is guaranteed not to be empty.","sidebar":"sidebar"},"functionaldatatypes/these":{"id":"functionaldatatypes/these","title":"These","description":"These[A, B] is a data type that models a value that can be either a Left with a value of type A, a Right with a value of type B, or a Both with both a value of type A and a value of type B.","sidebar":"sidebar"},"functionaldatatypes/validation":{"id":"functionaldatatypes/validation","title":"Validation","description":"A Validation[E, A] is a data type that is either a Success with a value of type A or a Failure with one or more errors of type E.","sidebar":"sidebar"},"functionaldatatypes/zset":{"id":"functionaldatatypes/zset","title":"ZSet","description":"ZSet is a version of a set that generalizes the measure of \\"how many times\\" each element appears in the set.","sidebar":"sidebar"},"functionaldatatypes/zvalidation":{"id":"functionaldatatypes/zvalidation","title":"ZValidation","description":"Like many other data types in ZIO, the Validation data type we learned about before is actually a type alias for a more general data type called ZValidation.","sidebar":"sidebar"},"index":{"id":"index","title":"Introduction to ZIO Prelude","description":"ZIO Prelude is a library focused on providing a core set of functional data types and abstractions that can help you solve a variety of day to day problems. The tools provided by ZIO Prelude fall into the following main categories:","sidebar":"sidebar"},"newtypes/index":{"id":"newtypes/index","title":"New Types","description":"ZIO Prelude provides functionality for creating zero overhead new types to allow you to increase the type safety of your application without compromising performance or ergonomics.","sidebar":"sidebar"},"resources/resources_index":{"id":"resources/resources_index","title":"Resources","description":"- Scaladoc of zio-prelude"},"zpure/index":{"id":"zpure/index","title":"ZPure","description":"A ZPure[W, S1, S2, R, E, A] is a description of a computation that requires an environment R and an initial state S1 and either fails with an error of type E or succeeds with an updated state of type S2 and a value of type A, in either case also producing a log of type W.","sidebar":"sidebar"}}}')}}]);