"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[4742],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var s=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},r=Object.keys(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=s.createContext({}),p=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return s.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},d=s.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),h=a,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return n?s.createElement(m,i(i({ref:t},c),{},{components:n})):s.createElement(m,i({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return s.createElement.apply(null,i)}return s.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4422:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var s=n(7462),a=(n(7294),n(3905));const r={id:"spec",title:"Spec"},i=void 0,o={unversionedId:"references/test/spec",id:"references/test/spec",title:"Spec",description:"A Spec[R, E] is the backbone of ZIO Test. All specs require an environment of type R and may potentially fail with an error of type E.",source:"@site/docs/references/test/spec.md",sourceDirName:"references/test",slug:"/references/test/spec",permalink:"/references/test/spec",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/references/test/spec.md",tags:[],version:"current",frontMatter:{id:"spec",title:"Spec"},sidebar:"references-sidebar",previous:{title:"Introduction",permalink:"/references/test/"},next:{title:"Assertion",permalink:"/references/test/assertion"}},l={},p=[{value:"Constructors",id:"constructors",level:2},{value:"Dependencies on Other Services",id:"dependencies-on-other-services",level:2},{value:"Using Standard Test Services",id:"using-standard-test-services",level:2},{value:"Providing Layers",id:"providing-layers",level:2},{value:"Sharing Layers Between Multiple Specs",id:"sharing-layers-between-multiple-specs",level:2},{value:"Sharing Layers Within The Same File",id:"sharing-layers-within-the-same-file",level:3},{value:"Sharing Layers Within Multiple Files",id:"sharing-layers-within-multiple-files",level:3},{value:"Operations",id:"operations",level:2},{value:"Test Aspects",id:"test-aspects",level:3},{value:"Smart Specs",id:"smart-specs",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,s.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"Spec[R, E]")," is the backbone of ZIO Test. All specs require an environment of type ",(0,a.kt)("inlineCode",{parentName:"p"},"R")," and may potentially fail with an error of type ",(0,a.kt)("inlineCode",{parentName:"p"},"E"),"."),(0,a.kt)("p",null,"We can think of a spec as just a collection of tests. It is essentially a recursive data structure where every spec is just one individual test or a suite that itself can have multiple specs inside that each could be tests or sub suites. We can go down as far as we want in a recursive tree-like data structure."),(0,a.kt)("h2",{id:"constructors"},"Constructors"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"A Single Test")," \u2014 The ",(0,a.kt)("inlineCode",{parentName:"p"},"test")," constructor creates one single spec (test):"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:silent:nest","mdoc:silent:nest":!0},'import zio.test._\n\nval mySpec = test("true is true") {\n  assertTrue(true)\n}\n')),(0,a.kt)("p",{parentName:"li"},"Real tests that run some logic and return testing result are created mostly with ",(0,a.kt)("inlineCode",{parentName:"p"},"test")," function. It expects two arguments, first one will be the label of test which will be used for visual reporting back to the user, and an assertion which contains some testable logic specified about a target under the test.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Collection of Multiple Tests")," \u2014 The ",(0,a.kt)("inlineCode",{parentName:"p"},"suite")," creates a suite which contains other specs (tests or suites):"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nval mySuite =\n  suite("A suite containing multiple tests")(\n    test("the first test") {\n      assertTrue(1 + 1 == 2)\n    },\n    test("the second test") {\n      assertTrue(2 * 2 == 4)\n    }\n  )\n')),(0,a.kt)("p",null,"  Suites can contain other suites. We can have multiple suites and one big suite that will aggregate them all:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nsuite("int and string")(\n  suite("int suite")(\n    test("minus")(assertTrue(2 - 1 == 1)),\n    test("plus")(assertTrue(1 + 1 == 2))\n  ),\n  suite("string suite")(\n    test("concat")(assertTrue("a" + "b" == "ab")),\n    test("length")(assertTrue("abc".length == 3))\n  )\n)\n')),(0,a.kt)("h2",{id:"dependencies-on-other-services"},"Dependencies on Other Services"),(0,a.kt)("p",null,"Just like the ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO")," data type, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Spec")," requires an environment of type ",(0,a.kt)("inlineCode",{parentName:"p"},"R"),". When we write tests, we might need to access a service through the environment. It can be a combination of the standard services such a ",(0,a.kt)("inlineCode",{parentName:"p"},"Clock"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Console"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Random")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"System")," or test services like ",(0,a.kt)("inlineCode",{parentName:"p"},"TestClock"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"TestConsole"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"TestRandom"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"TestSystem"),", or any user-defined services."),(0,a.kt)("h2",{id:"using-standard-test-services"},"Using Standard Test Services"),(0,a.kt)("p",null,"All standard test services are located at the ",(0,a.kt)("inlineCode",{parentName:"p"},"zio.test")," package. They are test implementation of standard ZIO services. The use of these test services enables us to test functionality that depends on printing to or reading from a console, randomness, timings, and, also the system properties."),(0,a.kt)("p",null,"Let's see how we can test the ",(0,a.kt)("inlineCode",{parentName:"p"},"sayHello")," function, which uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"Console")," service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\nimport java.io.IOException\n\ndef sayHello: ZIO[Any, IOException, Unit] =\n  Console.printLine("Hello, World!")\n\nsuite("HelloWorldSpec")(\n  test("sayHello correctly displays output") {\n    for {\n      _      <- sayHello\n      output <- TestConsole.output\n    } yield assertTrue(output == Vector("Hello, World!\\n"))\n  }\n)\n')),(0,a.kt)("p",null,"There is a separate section in the documentation pages that covers ",(0,a.kt)("a",{parentName:"p",href:"/references/test/environment/"},"all built-in test services"),"."),(0,a.kt)("h2",{id:"providing-layers"},"Providing Layers"),(0,a.kt)("p",null,"By using ",(0,a.kt)("inlineCode",{parentName:"p"},"Spec#provideXYZLayer"),", a test or suite of tests can be provided with any dependencies in a similar way to how a ZIO data type can."),(0,a.kt)("h2",{id:"sharing-layers-between-multiple-specs"},"Sharing Layers Between Multiple Specs"),(0,a.kt)("p",null,"ZIO Test has the ability to share layers between multiple specs. This is useful when we want to have some common services available for all tests. We have two ways to do this:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Using ",(0,a.kt)("inlineCode",{parentName:"li"},"Spec#provideXYZShared")," methods, which is useful to share layers between multiple specs that are residing in the same file."),(0,a.kt)("li",{parentName:"ol"},"Using the ",(0,a.kt)("inlineCode",{parentName:"li"},"bootstrap")," layer, which is useful to share layers between multiple specs that are residing in different files.")),(0,a.kt)("h3",{id:"sharing-layers-within-the-same-file"},"Sharing Layers Within The Same File"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Spec")," data type has a very nice mechanism to share layers within all tests in a suite. So instead of acquiring and releasing dependencies for each test, we can share the layer within all tests. The test framework acquires that layer for once and shares that between all tests. When the execution of all tests is finished, that layer will be released. To share layers between multiple specs we can use ",(0,a.kt)("inlineCode",{parentName:"p"},"Spec#provideXYZShared")," methods:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'{\n  test("test1")(???) +\n    test("test2")(???)\n}.provideZYZShared(sharedLayer)\n\nsuite("suite1")(\n  test("test1")(???),\n  test("test2")(???)\n).provideZYZShared(sharedLayer)\n\nsuite("all suites")(\n  suite("suite1")(\n    test("test1")(???),\n  ),\n  suite("suite2")(\n    test("test1")(???),\n    test("test2")(???),\n    test("test3")(???)\n  )\n).provideXYZShared(sharedLayer)\n')),(0,a.kt)("p",null,"To demonstrate this, let's try an example. In this example, instead of using the built-in features of the ZIO Test, we want to write our own basic solution to count the number of times tests are executed."),(0,a.kt)("p",null,"First, we need a counter service like the below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class Counter(value: Ref[Int]) {\n  def inc: UIO[Unit] = value.update(_ + 1)\n  def get: UIO[Int] = value.get\n}\n\nobject Counter {\n  val layer =\n    ZLayer.scoped(\n      ZIO.acquireRelease(\n        Ref.make(0).map(Counter(_)) <* ZIO.debug("Counter initialized!")\n      )(c => c.get.debug("Number of tests executed"))\n    )\n  def inc = ZIO.service[Counter].flatMap(_.inc)\n}\n')),(0,a.kt)("p",null,"We use this service to count the number of times the tests are executed, by calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter.inc")," operator after each test:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test._\n\nobject MySpecs extends ZIOSpecDefault {\n  def spec = {\n    suite("Spec1")(\n      test("test1") {\n        assertTrue(true)\n      } @@ TestAspect.after(Counter.inc),\n      test("test2") { assertTrue(true)\n      } @@ TestAspect.after(Counter.inc)\n    ) +\n      suite("Spec2") {\n        test("test1") {\n          assertTrue(true)\n        } @@ TestAspect.after(Counter.inc)\n      }\n  }.provideShared(Counter.layer)\n}\n')),(0,a.kt)("p",null,"If we execute all tests, we will see an output like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Counter initialized!\n+ Spec1\n  + test2\n  + test1\n+ Spec2\n  + test1\nNumber of tests executed: 3\n3 tests passed. 0 tests failed. 0 tests ignored.\n")),(0,a.kt)("p",null,"In the above example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter.layer")," is shared between all tests, and only acquired and released once."),(0,a.kt)("h3",{id:"sharing-layers-within-multiple-files"},"Sharing Layers Within Multiple Files"),(0,a.kt)("p",null,"In the previous example, we used the ",(0,a.kt)("inlineCode",{parentName:"p"},"Spec#provideXYZShared")," methods to share layers between multiple specs in one file. In most cases, when the number of tests and specs grows, this is not a good idea. We want a way to share layers between multiple specs in different files."),(0,a.kt)("p",null,"So in such situations, we can't use the previous pattern here, because specs are in entirely different files, and we don't want the boilerplate of creating a ",(0,a.kt)("em",{parentName:"p"},"master spec")," that references the other specs. ZIO has a solution to this problem. We can define the resource we want to share as part of the ",(0,a.kt)("inlineCode",{parentName:"p"},"bootstrap")," layer of ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIOApp"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"bootstrap")," layer is responsible for creating and managing any services that our ZIO tests need. Using ",(0,a.kt)("inlineCode",{parentName:"p"},"boostrap")," we can have one shared layer across multiple test specs."),(0,a.kt)("p",null,"Let's assume we have two specs in different files, and we want to share the ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," service between them. First, we need to create a base class that contains the shared bootstrap layer:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.test._\n\nabstract class SharedCounterSpec extends ZIOSpec[Counter] {\n  override val bootstrap: ZLayer[Any, Nothing, Counter] = Counter.layer\n}\n")),(0,a.kt)("p",null,"Now it's time to create the specs. Each spec is extending the ",(0,a.kt)("inlineCode",{parentName:"p"},"SharedCounterSpec")," class."),(0,a.kt)("p",null,"Spec1.scala:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test._\n\nobject Spec1 extends SharedCounterSpec {\n  override def spec =\n    test("test1") {\n      assertTrue(true)\n    } @@ TestAspect.after(Counter.inc)\n}\n')),(0,a.kt)("p",null,"Spec2.scala:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test._\n\nobject Spec2 extends SharedCounterSpec {\n  override def spec: Spec[Scope with Counter, Any] =\n    test("test2") {\n      assertTrue(true)\n    } @@ TestAspect.after(Counter.inc)\n}\n')),(0,a.kt)("p",null,"Now, when we run all specs (",(0,a.kt)("inlineCode",{parentName:"p"},"sbt testOnly org.example.*"),"), we will see an output like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Counter initialized!\n+ test1\n+ test2\nNumber of tests executed: 2\n")),(0,a.kt)("p",null,"The ZIO test runner will execute all specs with the shared bootstrap layer. This means that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," service will be created and managed only once, and will be shared between all specs."),(0,a.kt)("h2",{id:"operations"},"Operations"),(0,a.kt)("p",null,"In ZIO Test, specs are just values like other data types in ZIO. So we can filter, map or manipulate these data types. In this section, we are going to learn some of the most important operations on the ",(0,a.kt)("inlineCode",{parentName:"p"},"Spec")," data type:"),(0,a.kt)("h3",{id:"test-aspects"},"Test Aspects"),(0,a.kt)("p",null,"We can think of a test aspect as a polymorphic function from one test to another test. We use them to change existing tests or even entire suites or specs that we have already created."),(0,a.kt)("p",null,"Test aspects are applied to a test or suite using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@@")," operator:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.{test, _}\n\ntest("a single test") {\n  ???\n} @@ testAspect\n\nsuite("suite of multiple tests") {\n  ???\n} @@ testAspect\n')),(0,a.kt)("p",null,"The great thing about test aspects is that they are very composable. So we chain them one after another. We can even have test aspects that modify other test aspects."),(0,a.kt)("p",null,"So let's say we have a challenge that we need to run a test, and we want to make sure there is no flaky on the JVM, and then we want to make sure it doesn't take more than 60 seconds:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\ntest("a test with two aspects composed together") {\n  ???\n} @@ jvm(nonFlaky) @@ timeout(60.seconds)\n')),(0,a.kt)("p",null,"This is an example of a test suite showing the use of aspects to modify test behavior:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.{test => _, _}\nimport zio.test.TestAspect._\n\nobject MySpec extends ZIOSpecDefault {\n  def spec = suite("A Suite")(\n    test("A passing test") {\n      assertTrue(true)\n    },\n    test("A passing test run for JVM only") {\n      assertTrue(true)\n    } @@ jvmOnly, // @@ jvmOnly only runs tests on the JVM\n    test("A passing test run for JS only") {\n      assertTrue(true)\n    } @@ jsOnly, // @@ jsOnly only runs tests on Scala.js\n    test("A passing test with a timeout") {\n      assertTrue(true)\n    } @@ timeout(10.nanos), // @@ timeout will fail a test that doesn\'t pass within the specified time\n    test("A failing test... that passes") {\n      assertTrue(true)\n    } @@ failing, //@@ failing turns a failing test into a passing test\n    test("A ignored test") {\n      assertTrue(false)\n    } @@ ignore, //@@ ignore marks test as ignored\n    test("A flaky test that only works on the JVM and sometimes fails; let\'s compose some aspects!") {\n      assertTrue(false)\n    } @@ jvmOnly           // only run on the JVM\n      @@ eventually        // @@ eventually retries a test indefinitely until it succeeds\n      @@ timeout(20.nanos) // it\'s a good idea to compose `eventually` with `timeout`, or the test may never end\n  ) @@ timeout(60.seconds) // apply a timeout to the whole suite\n}\n')),(0,a.kt)("h2",{id:"smart-specs"},"Smart Specs"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"suite")," method creates a spec from a collection of specs. So what we can do is to provide it with a collection of specs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nobject ExampleSpec extends ZIOSpecDefault {\n\n  def spec =\n    suite("some suite")(\n      test("test 1") {\n        val stuff = 1\n        assertTrue(stuff == 1)\n      },\n      test("test 2") {\n        val stuff = Some(1)\n        assertTrue(stuff == Some(1))\n      }\n    )\n\n}\n')),(0,a.kt)("p",null,"But what if we wanted to have a suite of tests that work on a common value, e.g. the same ",(0,a.kt)("inlineCode",{parentName:"p"},"stuff"),"? ZIO provides the ",(0,a.kt)("inlineCode",{parentName:"p"},"suiteAll")," method that helps us to share the same ",(0,a.kt)("inlineCode",{parentName:"p"},"stuff")," between all tests:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nobject ExampleSpec extends ZIOSpecDefault {\n\n  def spec =\n    suiteAll("some suite") {\n\n      val stuff = "hello"\n\n      test("test 1") {\n        assertTrue(stuff.startsWith("h"))\n      }\n\n      val stuff2 = 5\n\n      test("test 2") {\n        assertTrue(stuff.length == stuff2)\n      }\n    }\n\n}\n')))}u.isMDXComponent=!0}}]);