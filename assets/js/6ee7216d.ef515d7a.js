"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[6386],{3905:(e,n,a)=>{a.d(n,{Zo:()=>c,kt:()=>u});var t=a(7294);function o(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){o(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var p=t.createContext({}),s=function(e){var n=t.useContext(p),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},c=function(e){var n=s(e.components);return t.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(a),u=o,h=m["".concat(p,".").concat(u)]||m[u]||d[u]||r;return a?t.createElement(h,i(i({ref:n},c),{},{components:a})):t.createElement(h,i({ref:n},c))}));function u(e,n){var a=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=m;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=a[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4787:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var t=a(7462),o=(a(7294),a(3905));const r={id:"zlayer",title:"ZLayer"},i=void 0,l={unversionedId:"reference/contextual/zlayer",id:"reference/contextual/zlayer",title:"ZLayer",description:"A ZLayer[-RIn, +E, +ROut] describes a layer of an application: every layer in an application requires some services as input RIn and produces some services as the output ROut.",source:"@site/docs/reference/contextual/zlayer.md",sourceDirName:"reference/contextual",slug:"/reference/contextual/zlayer",permalink:"/reference/contextual/zlayer",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/contextual/zlayer.md",tags:[],version:"current",frontMatter:{id:"zlayer",title:"ZLayer"},sidebar:"reference-sidebar",previous:{title:"ZEnvironment",permalink:"/reference/contextual/zenvironment"},next:{title:"RLayer",permalink:"/reference/contextual/rlayer"}},p={},s=[{value:"Creation",id:"creation",level:2},{value:"From a Simple Value or an Existing Service",id:"from-a-simple-value-or-an-existing-service",level:3},{value:"From Resourceful Effects (Scoped Resources)",id:"from-resourceful-effects-scoped-resources",level:3},{value:"From Non-resourceful Effects",id:"from-non-resourceful-effects",level:3},{value:"From Functions",id:"from-functions",level:3},{value:"Building Dependency Graph",id:"building-dependency-graph",level:2},{value:"Manual Layer Construction",id:"manual-layer-construction",level:2},{value:"Vertical and Horizontal Composition",id:"vertical-and-horizontal-composition",level:3},{value:"Hidden Versus Passed-through Dependencies",id:"hidden-versus-passed-through-dependencies",level:3},{value:"Updating Local Dependencies",id:"updating-local-dependencies",level:3},{value:"Cyclic Dependencies",id:"cyclic-dependencies",level:3},{value:"Automatic Layer Construction",id:"automatic-layer-construction",level:2},{value:"Providing Individual Layers to a ZIO Application",id:"providing-individual-layers-to-a-zio-application",level:3},{value:"Automatically Assembling Layers",id:"automatically-assembling-layers",level:3},{value:"ZLayer Debugging",id:"zlayer-debugging",level:3},{value:"Dependency Propagation",id:"dependency-propagation",level:2},{value:"Using <code>ZIO#provideEnvironment</code> Method",id:"using-zioprovideenvironment-method",level:4},{value:"Using <code>ZIO#provide</code> Method",id:"using-zioprovide-method",level:4},{value:"Using <code>ZIO#provideSome</code> Method",id:"using-zioprovidesome-method",level:4},{value:"Environment Scope",id:"environment-scope",level:2},{value:"Global Environment",id:"global-environment",level:3},{value:"Local Environment",id:"local-environment",level:3},{value:"Layer Memoization",id:"layer-memoization",level:2},{value:"Layers are Memoized by Default when Providing Globally",id:"layers-are-memoized-by-default-when-providing-globally",level:3},{value:"Acquiring a Fresh Version",id:"acquiring-a-fresh-version",level:4},{value:"Layers are not Memoized When Providing Locally",id:"layers-are-not-memoized-when-providing-locally",level:3},{value:"Manual Memoization",id:"manual-memoization",level:4},{value:"Other Operators",id:"other-operators",level:2},{value:"Converting a Layer to a Scoped Value",id:"converting-a-layer-to-a-scoped-value",level:3},{value:"Falling Back to an Alternate Layer",id:"falling-back-to-an-alternate-layer",level:3},{value:"Converting a Layer to a ZIO Application",id:"converting-a-layer-to-a-zio-application",level:3},{value:"Retrying",id:"retrying",level:3},{value:"Layer Projection",id:"layer-projection",level:3},{value:"Tapping",id:"tapping",level:3},{value:"Examples",id:"examples",level:2},{value:"An Example of a ZIO Application with a Simple Dependency",id:"an-example-of-a-zio-application-with-a-simple-dependency",level:3},{value:"An Example of Manually Generating a Dependency Graph",id:"an-example-of-manually-generating-a-dependency-graph",level:3},{value:"An Example of Automatically Generating a Dependency Graph",id:"an-example-of-automatically-generating-a-dependency-graph",level:3},{value:"An Example of Providing Different Implementations of the Same Service",id:"an-example-of-providing-different-implementations-of-the-same-service",level:3},{value:"An Example of How to Get Fresh Layers",id:"an-example-of-how-to-get-fresh-layers",level:3},{value:"An Example of Pass-through Dependencies",id:"an-example-of-pass-through-dependencies",level:3},{value:"An Example of Updating Hidden Dependencies",id:"an-example-of-updating-hidden-dependencies",level:3}],c={toc:s};function d(e){let{components:n,...a}=e;return(0,o.kt)("wrapper",(0,t.Z)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer[-RIn, +E, +ROut]")," describes a layer of an application: every layer in an application requires some services as input ",(0,o.kt)("inlineCode",{parentName:"p"},"RIn")," and produces some services as the output ",(0,o.kt)("inlineCode",{parentName:"p"},"ROut"),"."),(0,o.kt)("p",null,"We can think of a layer as mental model of an asynchronous function from ",(0,o.kt)("inlineCode",{parentName:"p"},"RIn")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Either[E, ROut]"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"type ZLayer[-RIn, +E, +ROut] = RIn => async Either[E, ROut]\n")),(0,o.kt)("p",null,"For example, a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer[Socket & Persistence, Throwable, Database]")," can be thought of as a function that map ",(0,o.kt)("inlineCode",{parentName:"p"},"Socket")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Persistence")," services into ",(0,o.kt)("inlineCode",{parentName:"p"},"Database")," service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"(Socket, Persistence) => Database\n")),(0,o.kt)("p",null,"So we can say that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Database")," service has two dependencies: ",(0,o.kt)("inlineCode",{parentName:"p"},"Socket")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Persistence")," services."),(0,o.kt)("p",null,"In some cases, a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," may not have any dependencies or requirements from the environment. In this case, we can specify ",(0,o.kt)("inlineCode",{parentName:"p"},"Any")," for the ",(0,o.kt)("inlineCode",{parentName:"p"},"RIn")," type parameter. The ",(0,o.kt)("a",{parentName:"p",href:"/reference/contextual/layer"},(0,o.kt)("inlineCode",{parentName:"a"},"Layer"))," type alias provided by ZIO is a convenient way to define a layer without requirements."),(0,o.kt)("p",null,"ZLayers are:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Recipes for Creating Services")," \u2014 They describe how to create services from given dependencies. For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer[Socket & Database, Throwable, UserRepo]")," is a recipe for building a service that requires ",(0,o.kt)("inlineCode",{parentName:"p"},"Socket")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Database")," service, and it produces a ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo")," service.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"An Alternative to Constructors")," \u2014 We can think of ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," as a more powerful version of a constructor, it is an alternative way to represent a constructor. Like a constructor, it allows us to build the ",(0,o.kt)("inlineCode",{parentName:"p"},"ROut")," service in terms of its dependencies (",(0,o.kt)("inlineCode",{parentName:"p"},"RIn"),").")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Composable")," \u2014 Because of their excellent ",(0,o.kt)("strong",{parentName:"p"},"composition properties"),", layers are the idiomatic way in ZIO to create services that depend on other services. We can define layers that are relying on each other.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Effectful and Resourceful")," \u2014 The construction of ZIO layers can be effectful and resourceful. They can be acquired effectfully and safely released when the services are done being utilized or even in case of failure, interruption, or defects in the application. "),(0,o.kt)("p",{parentName:"li"},"For example, to create a recipe for a ",(0,o.kt)("inlineCode",{parentName:"p"},"Database")," service, we should describe how the ",(0,o.kt)("inlineCode",{parentName:"p"},"Database")," will be initialized using an acquisition action. In addition, it may contain information about how the ",(0,o.kt)("inlineCode",{parentName:"p"},"Database")," releases its connection pools.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Asynchronous")," \u2014 Unlike class constructors which are blocking, ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," is fully asynchronous and non-blocking. Note that in non-blocking applications we typically want to avoid creating something that is blocking inside its constructor."),(0,o.kt)("p",{parentName:"li"},"For example, when we are constructing some sort of Kafka streaming service, we might want to connect to the Kafka cluster in the constructor of our service, which takes some time. So it wouldn't be a good idea to block inside the constructor. There are some workarounds for fixing this issue, but they are not as perfect as the ZIO solution which allows for asynchronous, non-blocking constructors.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Parallelism")," \u2014 ZIO layers can be acquired in parallel, unlike class constructors, which do not support parallelism. When we compose multiple layers and then acquire them, the construction of each layer will occur in parallel. This will reduce the initialization time of ZIO applications with a large number of dependencies."),(0,o.kt)("p",{parentName:"li"},"With ZIO ZLayer, our constructor could be asynchronous, but it could also block. We can acquire resources asynchronously or in a blocking fashion, and spend some time doing that, and we don't need to worry about it. That is not an anti-pattern. This is the best practice with ZIO. And that is because ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," has the full power of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," data type, and as a result, we have strictly more power on our constructors with ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Resilient")," \u2014 Layer construction can be resilient. So if the acquiring phase fails, we can have a schedule to retry the acquiring stage. This helps us write apps that are error-proof and respond appropriately to failures."))),(0,o.kt)("p",null,"Let's see how we can create a layer:"),(0,o.kt)("h2",{id:"creation"},"Creation"),(0,o.kt)("p",null,"There are four main ways to create a ZLayer:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"ZLayer.succeed")," for creating layers from simple values."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"ZLayer.scoped")," for creating layers with ",(0,o.kt)("em",{parentName:"li"},"for comprehension")," style from resourceful effects."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"ZLayer.apply"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"ZLayer.fromZIO")," for creating layers with ",(0,o.kt)("em",{parentName:"li"},"for comprehension")," style from effectual but not resourceful effects."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"ZLayer.fromFunction")," for creating layers that are neither effectual nor resourceful.")),(0,o.kt)("p",null,"Now let's look at each of these methods."),(0,o.kt)("h3",{id:"from-a-simple-value-or-an-existing-service"},"From a Simple Value or an Existing Service"),(0,o.kt)("p",null,"With ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.succeed")," we can construct a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," from a value. It returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"ULayer[A]")," value, which represents a layer of an application that has a service of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def succeed[A: Tag](a: A): ULayer[A]\n")),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.succeed")," we can create a layer containing ",(0,o.kt)("em",{parentName:"p"},"simple value")," or a ",(0,o.kt)("em",{parentName:"p"},"service"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"To create a layer from a ",(0,o.kt)("em",{parentName:"li"},"simple value"),":")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval configLayer: ULayer[AppConfig] = ZLayer.succeed(AppConfig("localhost", 8080))\n')),(0,o.kt)("p",null,"In the example above, we created a ",(0,o.kt)("inlineCode",{parentName:"p"},"configLayer")," that provides us an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"AppConfig"),"."),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"To create a layer from an ",(0,o.kt)("em",{parentName:"li"},"existing service"),":")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait EmailService {\n  def send(email: String, content: String): UIO[Unit]\n}\n\nobject EmailService {\n  val layer: ZLayer[Any, Nothing, EmailService] = \n    ZLayer.succeed( \n      new EmailService {\n        override def send(email: String, content: String): UIO[Unit] = ???\n      }\n    )\n}\n")),(0,o.kt)("h3",{id:"from-resourceful-effects-scoped-resources"},"From Resourceful Effects (Scoped Resources)"),(0,o.kt)("p",null,"Some components of our applications need to be scoped, meaning they undergo a resource acquisition phase before usage, and a resource release phase after usage (e.g. when the application shuts down). As we stated before, the construction of ZIO layers can be effectful and resourceful, this means they can be acquired and safely released when the services are done being utilized."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," relies on the powerful ",(0,o.kt)("inlineCode",{parentName:"p"},"Scope")," data type and this makes this process extremely simple. We can lift any scoped ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," by providing a scoped resource to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.apply")," constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport scala.io.BufferedSource\n\nval fileLayer: ZLayer[Any, Throwable, BufferedSource] =\n  ZLayer.scoped {\n    ZIO.fromAutoCloseable(\n      ZIO.attempt(scala.io.Source.fromFile("file.txt"))\n    )\n  }\n')),(0,o.kt)("p",null,"Let's see a real-world example of creating a layer from scoped resources. Assume we have the following ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository")," service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport scala.io.Source._\nimport java.io.{FileInputStream, FileOutputStream, Closeable}\n\ntrait DBConfig\ntrait Transactor\ntrait User\n\ndef dbConfig: Task[DBConfig] = ZIO.attempt(???)\ndef initializeDb(config: DBConfig): Task[Unit] = ZIO.attempt(???)\ndef makeTransactor(config: DBConfig): ZIO[Scope, Throwable, Transactor] = ZIO.attempt(???)\n\ntrait UserRepository {\n  def save(user: User): Task[Unit]\n}\n\ncase class UserRepositoryLive(xa: Transactor) extends UserRepository {\n  override def save(user: User): Task[Unit] = ZIO.attempt(???)\n}\n")),(0,o.kt)("p",null,"Assume we have written a scoped ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepository"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def scoped: ZIO[Scope, Throwable, UserRepository] = \n  for {\n    cfg <- dbConfig\n    _   <- initializeDb(cfg)\n    xa  <- makeTransactor(cfg)\n  } yield new UserRepositoryLive(xa)\n")),(0,o.kt)("p",null,"We can convert that to ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.apply"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val usersLayer : ZLayer[Any, Throwable, UserRepository] =\n  ZLayer.scoped(scoped)\n// usersLayer: ZLayer[Any, Throwable, UserRepository] = Suspend(\n//   self = zio.ZLayer$$$Lambda$10353/546973039@7273517d\n// )\n")),(0,o.kt)("h3",{id:"from-non-resourceful-effects"},"From Non-resourceful Effects"),(0,o.kt)("p",null,"We can create ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," from any ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," effect by using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.fromZIO"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.apply")," constructor."),(0,o.kt)("p",null,"For example, assume we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," effect that reads the application config from a file, we can create a layer from that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ncase class AppConfig(poolSize: Int)\n  \ndef loadConfig : Task[AppConfig] = \n  ZIO.attempt(???)\n\nobject AppConfig {\n  val layer: TaskLayer[AppConfig] = \n    ZLayer(loadConfig)  // or ZLayer.fromZIO(loadConfig)\n}\n")),(0,o.kt)("p",null,"This is the for-comprehension way of creating a ZIO service using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.apply"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait A\ntrait B\ntrait C\ncase class CLive(a: A, b: B) extends C\n\nobject CLive {\n  val layer: ZLayer[A & B, Nothing, C] =\n    ZLayer {\n      for {\n        a <- ZIO.service[A]\n        b <- ZIO.service[B]\n      } yield CLive(a, b)\n    }\n}\n")),(0,o.kt)("h3",{id:"from-functions"},"From Functions"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer[R, E, A]")," can be thought of as a function from ",(0,o.kt)("inlineCode",{parentName:"p"},"R")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),". So we can convert functions to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.fromFunction")," constructor."),(0,o.kt)("p",null,"In the following example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"CLive")," implementation requires two ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," services, and we can easily convert that case class to a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait A\ntrait B\ntrait C\ncase class CLive(a: A, b: B) extends C\n\nobject CLive {\n  val layer: ZLayer[A & B, Nothing, C] = \n    ZLayer.fromFunction(CLive.apply _)\n}\n")),(0,o.kt)("p",null,"Below is a complete working example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class DatabaseConfig()\n\nobject DatabaseConfig {\n  val live = ZLayer.succeed(DatabaseConfig())\n}\n\ncase class Database(databaseConfig: DatabaseConfig)\n\nobject Database {\n  val live: ZLayer[DatabaseConfig, Nothing, Database] =\n    ZLayer.fromFunction(Database.apply _)\n}\n\ncase class Analytics()\n\nobject Analytics {\n  val live: ULayer[Analytics] = ZLayer.succeed(Analytics())\n}\n\ncase class Users(database: Database, analytics: Analytics)\n\nobject Users {\n  val live = ZLayer.fromFunction(Users.apply _)\n}\n\ncase class App(users: Users, analytics: Analytics) {\n  def execute: UIO[Unit] =\n    ZIO.debug(s"This app is made from ${users} and ${analytics}")\n}\n\nobject App {\n  val live = ZLayer.fromFunction(App.apply _)\n}\n\nobject MainApp extends ZIOAppDefault {\n\n  def run =\n    ZIO\n      .serviceWithZIO[App](_.execute)\n      // Cannot use `provide` due to this dotty bug: https://github.com/lampepfl/dotty/issues/12498\n      .provideLayer(\n        (((DatabaseConfig.live >>> Database.live) ++ Analytics.live >>> Users.live) ++ Analytics.live) >>> App.live\n      )\n}\n')),(0,o.kt)("h2",{id:"building-dependency-graph"},"Building Dependency Graph"),(0,o.kt)("p",null,"We have two options to build a dependency graph:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Manual layer construction"),(0,o.kt)("li",{parentName:"ol"},"Automatic layer construction")),(0,o.kt)("p",null,"The first method uses ZIO's composition operators such as horizontal (",(0,o.kt)("inlineCode",{parentName:"p"},"++"),") and vertical (",(0,o.kt)("inlineCode",{parentName:"p"},">>>"),") compositions. The second one uses macro and automatically creates the dependency graph at compile time."),(0,o.kt)("h2",{id:"manual-layer-construction"},"Manual Layer Construction"),(0,o.kt)("p",null,"We said that we can think of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," as a more powerful ",(0,o.kt)("em",{parentName:"p"},"constructor"),". Constructors are not composable, because they are not values. While a constructor is not composable, ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," has a nice facility to compose with other ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer"),"s. So we can say that a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," turns a constructor into values."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),":"),(0,o.kt)("p",{parentName:"blockquote"},"In a regular ZIO application we are not required to build the dependency graph through composing layers tougher. Instead, we can provide all dependencies to the ZIO application using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provide"),", and the ZIO will create the dependency graph manually under the hood. Therefore, use manual layer composition if you know what you're doing.")),(0,o.kt)("h3",{id:"vertical-and-horizontal-composition"},"Vertical and Horizontal Composition"),(0,o.kt)("p",null,"Assume we have several services with their dependencies, and we need a way to compose and wire up these dependencies to create the dependency graph of our application. ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," is a ZIO solution for this problem, it allows us to build up the whole application dependency graph by composing layers horizontally and vertically."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Horizontal Composition")," \u2014 Layers can be composed together horizontally with the ",(0,o.kt)("inlineCode",{parentName:"li"},"++")," operator. When we compose layers horizontally, the new layer requires all the services that both of them require and produces all services that both of them produce. Horizontal composition is a way of composing two layers side-by-side. It is useful when we combine two layers that don't have any relationship with each other.")),(0,o.kt)("p",null,"We can compose ",(0,o.kt)("inlineCode",{parentName:"p"},"fooLayer")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"barLayer")," ",(0,o.kt)("em",{parentName:"p"},"horizontally")," to build a layer that has the requirements of both, to provide the capabilities of both, through ",(0,o.kt)("inlineCode",{parentName:"p"},"fooLayer ++ barLayer"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???        // A ==> B        // A ==> B\nval barLayer: ZLayer[C, Nothing  , D] = ???        // C ==> D        // C ==> D\n\nval horizontal: ZLayer[A & C, Throwable, B & D] =  // A & C ==> B & D\n  fooLayer ++ barLayer\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Vertical Composition")," \u2014 We can also compose layers ",(0,o.kt)("em",{parentName:"p"},"vertically")," using the ",(0,o.kt)("inlineCode",{parentName:"p"},">>>")," operator, meaning the output of one layer is used as input for the subsequent layer, resulting in one layer with the requirement of the first, and the output of the second.  "),(0,o.kt)("p",{parentName:"li"},"For example if we have a layer that requires ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and produces ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),", we can compose this with another layer that requires ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," and produces ",(0,o.kt)("inlineCode",{parentName:"p"},"C"),"; this composition produces a layer that requires ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and produces ",(0,o.kt)("inlineCode",{parentName:"p"},"C"),". The feed operator, ",(0,o.kt)("inlineCode",{parentName:"p"},">>>"),", stack them on top of each other by using vertical composition. This sort of composition is like ",(0,o.kt)("em",{parentName:"p"},"function composition"),", feeding an output of one layer to an input of another:"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???  // A ==> B  // A ==> B\nval barLayer: ZLayer[B, Nothing  , C] = ???  // B ==> C  // B ==> C\n\nval horizontal: ZLayer[A, Throwable, C] =    // A ==> C\n  fooLayer >>> barLayer\n")),(0,o.kt)("h3",{id:"hidden-versus-passed-through-dependencies"},"Hidden Versus Passed-through Dependencies"),(0,o.kt)("p",null,"ZLayer has a ",(0,o.kt)("inlineCode",{parentName:"p"},"passthrough")," operator which returns a new layer that produces the outputs of this layer but also passes-through the inputs:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval fooLayer: ZLayer[A, Nothing, B] = ???  // A ==> B  // A ==> B\n\nval result1 : ZLayer[A, Nothing, A & B] =  // A ==> A & B\n  fooLayer.passthrough\n  \nval result2 : ZLayer[A, Nothing, A & B] =  // A ==> A & B\n  ZLayer.service[A] ++ fooLayer\n")),(0,o.kt)("p",null,"By default, the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," hides intermediate dependencies when composing vertically. For example, when we compose ",(0,o.kt)("inlineCode",{parentName:"p"},"fooLayer")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"barLayer")," vertically, the output would be a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer[A, Throwable, C]"),". This hides the dependency on the ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," layer. By using the above technique, we can pass through hidden dependencies."),(0,o.kt)("p",null,"Let's include the ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," service into the upstream dependencies of the final layer using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO.service[B]"),". We can think of ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO.service[B]")," as an ",(0,o.kt)("em",{parentName:"p"},"identity function")," (",(0,o.kt)("inlineCode",{parentName:"p"},"B ==> B"),")."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???  // A  ==> B  // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ???  // B  ==> C  // B  ==> C\n\nval finalLayer: ZLayer[A & B, Throwable, C] = // A & B ==> C\n  (fooLayer ++ ZLayer.service[B]) >>> barLayer\n")),(0,o.kt)("p",null,"Or we may want to include the middle services in the output channel of the final layer, resulting in a new layer with the inputs of the first layer and the outputs of both layers:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ??? // A  ==> B // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ??? // B  ==> C // B  ==> C\n\nval finalLayer: ZLayer[A, Throwable, B & C] = // A ==> B & C\n  fooLayer >>> (ZLayer.service[B] ++ barLayer)\n")),(0,o.kt)("p",null,"We can do the same with the ",(0,o.kt)("inlineCode",{parentName:"p"},">+>")," operator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ??? // A  ==> B // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ??? // B  ==> C // B  ==> C\n\nval finalLayer: ZLayer[A, Throwable, B & C] = // A ==> B & C\n  fooLayer >+> barLayer\n")),(0,o.kt)("p",null,"This technique is useful when we want to defer the creation of some intermediate services and require them as part of the input of the final layer. For example, assume we have these two layers:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval fooLayer: ZLayer[A    , Throwable, B] = ???   // A     ==> B   // A     ==> B\nval barLayer: ZLayer[B & C, Throwable, D] = ???   // B & C ==> D   // B & C ==> D\n\nval finalLayer: ZLayer[A & B & C, Throwable, D] = // A & B & C ==> B & D\n  fooLayer >>> barLayer\n")),(0,o.kt)("p",null,"So we can defer the creation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," layer using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.service[C]"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval fooLayer: ZLayer[A    , Throwable, B] = ??? // A ==> B  // A ==> B \nval barLayer: ZLayer[B & C, Throwable, D] = ??? // B & C ==> D // B & C ==> D\n\nval layer: ZLayer[A & C, Throwable, D] =        // A & C ==> D\n  (fooLayer ++ ZLayer.service[C]) >>> barLayer\n")),(0,o.kt)("p",null,"Here is an example in which we passthrough all requirements to bake a ",(0,o.kt)("inlineCode",{parentName:"p"},"Cake")," so all the requirements are available to all the downstream services: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Baker \ntrait Ingredients\ntrait Oven\ntrait Dough\ntrait Cake\n\nlazy val baker      : ZLayer[Any, Nothing, Baker] = ???\nlazy val ingredients: ZLayer[Any, Nothing, Ingredients] = ???\nlazy val oven       : ZLayer[Any, Nothing, Oven] = ???\nlazy val dough      : ZLayer[Baker & Ingredients, Nothing, Dough] = ???\nlazy val cake       : ZLayer[Baker & Oven & Dough, Nothing, Cake] = ???\n\nlazy val all: ZLayer[Any, Nothing, Baker & Ingredients & Oven & Dough & Cake] =\n  baker >+>       // Baker\n  ingredients >+> // Baker & Ingredients\n  oven >+>        // Baker & Ingredients & Oven\n  dough >+>       // Baker & Ingredients & Oven & Dough\n  cake            // Baker & Ingredients & Oven & Dough & Cake\n")),(0,o.kt)("p",null,"This allows a style of composition where the ",(0,o.kt)("inlineCode",{parentName:"p"},">+>")," operator is used to build a progressively larger set of services, with each new service able to depend on all the services before it. If we passthrough dependencies and later want to hide them we can do so through a simple type ascription:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"lazy val hidden: ZLayer[Any, Nothing, Cake] = all\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," makes it easy to mix and match these styles. If we build our dependency graph more explicitly, we can be confident that dependencies used in multiple parts of the dependency graph will only be created once due to memoization and sharing."),(0,o.kt)("p",null,"Using these simple operators we can build complex dependency graphs."),(0,o.kt)("h3",{id:"updating-local-dependencies"},"Updating Local Dependencies"),(0,o.kt)("p",null,"Given a layer, it is possible to update one or more components it provides. We update a dependency in two ways:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Using the ",(0,o.kt)("inlineCode",{parentName:"strong"},"update")," Method")," \u2014 This method allows us to replace one requirement with a different implementation:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval origin: ZLayer[Any, Nothing, String & Int & Double] = \n  ZLayer.succeedEnvironment(ZEnvironment[String, Int, Double]("foo", 123, 1.3))\n\nval updated1 = origin.update[String](_ + "bar")\nval updated2 = origin.update[Int](_ + 5)\nval updated3 = origin.update[Double](_ - 0.3)\n')),(0,o.kt)("p",null,"Here is an example of updating a config layer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\ncase class AppConfig(poolSize: Int)\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[AppConfig, IOException, Unit] =\n    for {\n      config <- ZIO.service[AppConfig]\n      _ <- Console.printLine(s"Application config after the update operation: $config")\n    } yield ()\n\n\n  val appLayers: ZLayer[Any, Nothing, AppConfig] =\n    ZLayer(ZIO.succeed(AppConfig(5)).debug("Application config initialized"))\n\n  val updatedConfig: ZLayer[Any, Nothing, AppConfig] =\n    appLayers.update[AppConfig](c =>\n      c.copy(poolSize = c.poolSize + 10)\n    )\n\n  def run = myApp.provide(updatedConfig)\n}\n')),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Using Horizontal Composition")," \u2014 Another way to update a requirement is to horizontally compose in a layer that provides the updated service. The resulting composition will replace the old layer with the new one:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval origin: ZLayer[Any, Nothing, String & Int & Double] =\n  ZLayer.succeedEnvironment(ZEnvironment[String, Int, Double]("foo", 123, 1.3))\n\nval updated = origin ++ ZLayer.succeed(321)\n')),(0,o.kt)("p",null,"Let's see an example of updating a config layer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\ncase class AppConfig(poolSize: Int)\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[AppConfig, IOException, Unit] =\n    for {\n      config <- ZIO.service[AppConfig]\n      _      <- Console.printLine(s"Application config after the update operation: $config")\n    } yield ()\n\n\n  val appLayers: ZLayer[Any, Nothing, AppConfig] =\n    ZLayer(ZIO.succeed(AppConfig(5)).debug("Application config initialized"))\n\n  val updatedConfig: ZLayer[Any, Nothing, AppConfig] =\n    appLayers ++ ZLayer.succeed(AppConfig(8))\n\n  def run = myApp.provide(updatedConfig)\n}\n')),(0,o.kt)("h3",{id:"cyclic-dependencies"},"Cyclic Dependencies"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," mechanism makes it impossible to build cyclic dependencies, making the initialization process very linear, by construction."),(0,o.kt)("h2",{id:"automatic-layer-construction"},"Automatic Layer Construction"),(0,o.kt)("p",null,"ZIO also has an automatic layer construction facility, which takes care of building dependency graphs from the individual layers and building blocks. So instead of manually composing layers together to build the final layer, we can only provide individual layers to the ZIO application, and it will do the rest."),(0,o.kt)("p",null,"The automatic layer construction takes place at the ",(0,o.kt)("em",{parentName:"p"},"compile-time"),", so if there is a problem in providing a layer, we will receive an error or warning message. So it helps us to diagnose the problem. Additionally, it has a way to print the dependency graph using built-in debug layers."),(0,o.kt)("h3",{id:"providing-individual-layers-to-a-zio-application"},"Providing Individual Layers to a ZIO Application"),(0,o.kt)("p",null,"When we provide individual layers using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provide"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideCustom"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideSome")," to a ZIO application, the compiler will create the dependency graph automatically from the provided layers:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")),(0,o.kt)("p",{parentName:"blockquote"},"We have a ",(0,o.kt)("a",{parentName:"p",href:"#dependency-propagation"},"separate section")," that describes different methods for providing layers to the ZIO application.")),(0,o.kt)("p",null,"Assume we have written the following services (",(0,o.kt)("inlineCode",{parentName:"p"},"Cake"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Chocolate"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Flour"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Spoon"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Cake\n\nobject Cake {\n  val live: ZLayer[Chocolate & Flour, Nothing, Cake] =\n    for {\n      _ <- ZLayer.environment[Chocolate & Flour]\n      cake <- ZLayer.succeed(new Cake {})\n    } yield cake\n}\n\ntrait Spoon\n\nobject Spoon {\n  val live: ULayer[Spoon] =\n    ZLayer.succeed(new Spoon {})\n}\n\ntrait Chocolate\n\nobject Chocolate {\n  val live: ZLayer[Spoon, Nothing, Chocolate] =\n    ZLayer.service[Spoon].project(_ => new Chocolate {})\n}\n\ntrait Flour\n\nobject Flour {\n  val live: ZLayer[Spoon, Nothing, Flour] =\n    ZLayer.service[Spoon].project(_ => new Flour {})\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Cake")," service has the following dependency graph:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"          Cake\n          /   \\\n   Chocolate   Flour\n       |         |\n     Spoon     Spoon\n")),(0,o.kt)("p",null,"Now we can write an application that uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Cake")," service as below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\nval myApp: ZIO[Cake, IOException, Unit] = for {\n  cake <- ZIO.service[Cake]\n  _    <- Console.printLine(s"Yay! I baked a cake with flour and chocolate: $cake")\n} yield ()\n')),(0,o.kt)("p",null,"The type of ",(0,o.kt)("inlineCode",{parentName:"p"},"myApp")," indicates we should provide ",(0,o.kt)("inlineCode",{parentName:"p"},"Cake")," to this ZIO application to run it. Let's give it that and see what happens:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object MainApp extends ZIOAppDefault {\n  def run =\n    myApp.provide(Cake.live)\n}\n\n// error:\n// \n// \u2500\u2500\u2500\u2500 ZLAYER ERROR \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// \n//  Please provide layers for the following 2 types:\n// \n//    Required by Cake.live\n//    1. Chocolate\n//    2. Flour\n//    \n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n")),(0,o.kt)("p",null,"Here are the errors that will be printed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"\u2500\u2500\u2500\u2500 ZLAYER ERROR \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n Please provide layers for the following 2 types:\n\n   Required by Cake.live\n   1. Chocolate\n   2. Flour\n   \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n")),(0,o.kt)("p",null,"It says that we missed providing ",(0,o.kt)("inlineCode",{parentName:"p"},"Chocolate")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Flour")," layers. Now let's add these two missing layers:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp.provide(\n      Cake.live,\n      Chocolate.live,\n      Flour.live\n    )\n}\n\n// error:\n// \n// \u2500\u2500\u2500\u2500 ZLAYER ERROR \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// \n// Please provide a layer for the following type:\n// \n// Required by Flour.live\n// 1. Spoon\n// \n// Required by Chocolate.live\n// 1. Spoon\n// \n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n")),(0,o.kt)("p",null,"Again, the compiler asks us to provide another dependency called ",(0,o.kt)("inlineCode",{parentName:"p"},"Spoon"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"\u2500\u2500\u2500\u2500 ZLAYER ERROR \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nPlease provide a layer for the following type:\n\nRequired by Flour.live\n1. Spoon\n\nRequired by Chocolate.live\n1. Spoon\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n")),(0,o.kt)("p",null,"Finally, our application compiles without any errors: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp.provide(\n      Cake.live,\n      Chocolate.live,\n      Flour.live,\n      Spoon.live  \n    )\n}\n")),(0,o.kt)("p",null,"Note that the order of dependencies doesn't matter. We can provide them in any order."),(0,o.kt)("p",null,"Now, let's compare the automatic layer construction with the manual one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ULayer[Cake] =\n      (((Spoon.live >>> Chocolate.live) ++ (Spoon.live >>> Flour.live)) >>> Cake.live)\n\n  def run = myApp.provideLayer(layers)\n\n}\n")),(0,o.kt)("h3",{id:"automatically-assembling-layers"},"Automatically Assembling Layers"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ZLayer.make","[R]")," \u2014 Using ",(0,o.kt)("inlineCode",{parentName:"li"},"ZLayer.make[R]"),", we can provide a type ",(0,o.kt)("inlineCode",{parentName:"li"},"R")," and then provide individual layers as arguments, it will automatically assemble these layers to create a layer of type ",(0,o.kt)("inlineCode",{parentName:"li"},"R"),".")),(0,o.kt)("p",null,"For example, we can create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Cake")," layer as below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval cakeLayer: ZLayer[Any, Nothing, Cake] =\n  ZLayer.make[Cake](\n    Cake.live,\n    Chocolate.live,\n    Flour.live,\n    Spoon.live\n  )\n")),(0,o.kt)("p",null,"We can also create a layer for intersections of services:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval chocolateAndFlourLayer: ZLayer[Any, Nothing, Chocolate & Flour] =\n  ZLayer.make[Chocolate & Flour](\n    Chocolate.live,\n    Flour.live,\n    Spoon.live\n  )\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ZLayer.makeSome","[R0, R]")," \u2014 Automatically constructs a layer for the provided type ",(0,o.kt)("inlineCode",{parentName:"li"},"R"),", leaving a remainder ",(0,o.kt)("inlineCode",{parentName:"li"},"R0"),":")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval cakeLayer: ZLayer[Spoon, Nothing, Cake] =\n  ZLayer.makeSome[Spoon, Cake](\n    Cake.live,\n    Chocolate.live,\n    Flour.live\n  )\n")),(0,o.kt)("h3",{id:"zlayer-debugging"},"ZLayer Debugging"),(0,o.kt)("p",null,"To debug ZLayer construction, we have two built-in layers, i.e., ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.tree")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.mermaid"),". "),(0,o.kt)("p",null,"Let's include the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.tree")," layer into the layer construction:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp.provide(\n      Cake.live,\n      Chocolate.live,\n      Flour.live,\n      Spoon.live,\n      ZLayer.Debug.tree\n    )\n}\n")),(0,o.kt)("p",null,"The following debug messages will be generated by the compiler:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"[info]   ZLayer Wiring Graph\n[info]\n[info] \u25c9 Cake.live\n[info] \u251c\u2500\u25d1 Chocolate.live\n[info] \u2502 \u2570\u2500\u25d1 Spoon.live\n[info] \u2570\u2500\u25d1 Flour.live\n[info]   \u2570\u2500\u25d1 Spoon.live\n[info] \n")),(0,o.kt)("p",null,"If we use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.mermaid")," layer, it will generate the following debug messages:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"[info]   ZLayer Wiring Graph  \n[info] \n[info] \u25c9 Cake.live\n[info] \u251c\u2500\u25d1 Chocolate.live\n[info] \u2502 \u2570\u2500\u25d1 Spoon.live\n[info] \u2570\u2500\u25d1 Flour.live\n[info]   \u2570\u2500\u25d1 Spoon.live\n[info] \n[info] Mermaid Live Editor Link\n[info] https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZ3JhcGhcbiAgICBDb25zb2xlLmxpdmVcbiAgICBDYWtlLmxpdmUgLS0+IENob2NvbGF0ZS5saXZlXG4gICAgQ2FrZS5saXZlIC0tPiBGbG91ci5saXZlXG4gICAgRmxvdXIubGl2ZSAtLT4gU3Bvb24ubGl2ZVxuICAgIFNwb29uLmxpdmVcbiAgICBDaG9jb2xhdGUubGl2ZSAtLT4gU3Bvb24ubGl2ZVxuICAgICIsIm1lcm1haWQiOiAie1xuICBcInRoZW1lXCI6IFwiZGVmYXVsdFwiXG59IiwgInVwZGF0ZUVkaXRvciI6IHRydWUsICJhdXRvU3luYyI6IHRydWUsICJ1cGRhdGVEaWFncmFtIjogdHJ1ZX0=\n")),(0,o.kt)("h2",{id:"dependency-propagation"},"Dependency Propagation"),(0,o.kt)("p",null,"When we write an application, our application has a lot of dependencies. We need a way to provide implementations and to feed and propagate all dependencies throughout the whole application. We can solve the propagation problem by using ",(0,o.kt)("em",{parentName:"p"},"ZIO environment"),"."),(0,o.kt)("p",null,"During the development of an application, we don't care about implementations. Incrementally, when we use various effects with different requirements on their environment, all parts of our application compose together, and at the end of the day we have a ZIO effect which requires some services as an environment. Before running this effect by ",(0,o.kt)("inlineCode",{parentName:"p"},"unsafeRun")," we should provide an implementation of these services into the ZIO Environment of that effect."),(0,o.kt)("p",null,"ZIO has some facilities for doing this. ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provide")," is the core function that allows us to ",(0,o.kt)("em",{parentName:"p"},"feed")," an ",(0,o.kt)("inlineCode",{parentName:"p"},"R")," to an effect that requires an ",(0,o.kt)("inlineCode",{parentName:"p"},"R"),"."),(0,o.kt)("p",null,"Notice that the act of ",(0,o.kt)("inlineCode",{parentName:"p"},"provide"),"ing an effect with its environment, eliminates the environment dependency in the resulting effect type, represented by type ",(0,o.kt)("inlineCode",{parentName:"p"},"Any")," of the resulting environment."),(0,o.kt)("h4",{id:"using-zioprovideenvironment-method"},"Using ",(0,o.kt)("inlineCode",{parentName:"h4"},"ZIO#provideEnvironment")," Method"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideEnvironment")," takes an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"ZEnvironment[R]")," and provides it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," effect which eliminates its dependency on ",(0,o.kt)("inlineCode",{parentName:"p"},"R"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def provideEnvironment(r: => ZEnvironment[R]): IO[E, A]\n}\n")),(0,o.kt)("p",null,"This is similar to dependency injection, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"provide*")," function can be thought of as ",(0,o.kt)("em",{parentName:"p"},"inject"),"."),(0,o.kt)("p",null,"Assume we have the following services:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait EmailService {\n  def send(email: String, content: String): UIO[Unit]\n}\n\nobject EmailService {\n  def send(email: String, content: String) = ZIO.serviceWithZIO[EmailService](_.send(email, content))\n}\n")),(0,o.kt)("p",null,"Let's write a simple program using ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService")," service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val app: ZIO[EmailService, Nothing, Unit] = EmailService.send("john@doe.com", "Hello John!")\n')),(0,o.kt)("p",null,"We can ",(0,o.kt)("inlineCode",{parentName:"p"},"provide")," implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"EmailService")," service into the ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," effect:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val loggingImpl = new EmailService {\n  override def send(email: String, content: String): UIO[Unit] = ???\n}\n\nval effect = app.provideEnvironment(ZEnvironment(loggingImpl))\n")),(0,o.kt)("p",null,"Most of the time, we don't use ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideEnvironment")," directly to provide our services; instead, we use ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," to construct the dependency graph of our application, then we use methods like ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provide"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideSome")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideCustom")," to propagate dependencies into the environment of our ZIO effect."),(0,o.kt)("h4",{id:"using-zioprovide-method"},"Using ",(0,o.kt)("inlineCode",{parentName:"h4"},"ZIO#provide")," Method"),(0,o.kt)("p",null,"Unlike the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideEnvironment")," which takes a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZEnvironment[R]"),", the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provide")," takes a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," to the ZIO effect and translates it to another level."),(0,o.kt)("p",null,"Assume we have written this piece of program that requires ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Bar")," services:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'trait Foo {\n  def foo(): UIO[String]\n}\n\nobject Foo {\n  def foo(): ZIO[Foo, Nothing, String] = ZIO.serviceWithZIO[Foo](_.foo())\n}\n\ncase class FooLive() extends Foo {\n  override def foo(): UIO[String] = ZIO.succeed("foo")\n}\n\nobject FooLive {\n  val layer: ULayer[Foo] = ZLayer.succeed(FooLive())\n}\n\ntrait Bar {\n  def bar(): UIO[Int]\n}\n\nobject Bar {\n  def bar(): ZIO[Bar, Nothing, Int] = ZIO.serviceWithZIO[Bar](_.bar())\n}\n\ncase class BarLive() extends Bar {\n  override def bar(): UIO[Int] = ZIO.succeed(1)\n}\n\nobject BarLive {\n  val layer: ULayer[Bar] = ZLayer.succeed(BarLive())\n}\n\nval myApp: ZIO[Foo & Bar, Nothing, Unit] = for {\n  foo  <- Foo.foo()\n  bar  <- Bar.bar()\n  _    <- ZIO.debug(s"foo: $foo, bar: $bar")\n} yield ()\n')),(0,o.kt)("p",null,"We provide implementations of ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Bar")," services to the ",(0,o.kt)("inlineCode",{parentName:"p"},"myApp")," effect by using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provide")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val mainEffect: ZIO[Any, Nothing, Unit] = \n  myApp.provide(FooLive.layer, BarLive.layer)\n")),(0,o.kt)("p",null,"As we see, the type of our effect converted from ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO[Foo & Bar, Nothing, Unit]")," which requires two services to ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO[Any, Nothing, Unit]")," effect which doesn't require any services."),(0,o.kt)("h4",{id:"using-zioprovidesome-method"},"Using ",(0,o.kt)("inlineCode",{parentName:"h4"},"ZIO#provideSome")," Method"),(0,o.kt)("p",null,"Sometimes we have written a program, and we don't want to provide all its requirements. In these cases, we can use ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideSome")," to partially apply some layers to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," effect."),(0,o.kt)("p",null,"In the previous example, if we just want to provide the ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),", we should use ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideSome"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val mainEffectSome: ZIO[Bar, Nothing, Unit] = \n  myApp.provideSome(FooLive.layer)\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")),(0,o.kt)("p",{parentName:"blockquote"},"When using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provideSome[R0]"),", we should provide the remaining type as ",(0,o.kt)("inlineCode",{parentName:"p"},"R0")," type parameter. This workaround helps the compiler to infer the proper types.")),(0,o.kt)("h2",{id:"environment-scope"},"Environment Scope"),(0,o.kt)("p",null,"We can create a ZIO application by providing a local or a global environment, or a combination:"),(0,o.kt)("h3",{id:"global-environment"},"Global Environment"),(0,o.kt)("p",null,"It is usual when writing ZIO applications to provide layers at the end of the world. Then we provide layers to the whole ZIO application all at once. This pattern uses a single global environment for all ZIO applications:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[ServiceA & ServiceB & ServiceC & ServiceD, Throwable, Unit] = ???\n    \n  def run = myApp.provide(a, b, c, d)\n}\n")),(0,o.kt)("h3",{id:"local-environment"},"Local Environment"),(0,o.kt)("p",null,"Occasionally, we may need to provide different environments for different parts of our application, or it may be necessary to provide a single global environment for the entire application except for some inner layers. "),(0,o.kt)("p",null,"Providing a layer locally is analogous to overriding a method in an object-oriented paradigm. So we can think of that as overriding the global environment:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def myApp: ZIO[A & B & C, Throwable, Unit] = {\n    def innerApp1: ZIO[A & B & C, Throwable, Unit] = ???\n    def innerApp2: ZIO[A & C,     Throwable, Unit] = ???\n\n    innerApp1.provideSomeLayer[A & B](localC) *> innerApp2\n  }\n\n  def run = myApp.provide(globalA, globalB, globalC)\n}\n")),(0,o.kt)("p",null,"ZIO Test's ",(0,o.kt)("a",{parentName:"p",href:"/reference/test/environment/live"},"Live service")," uses this pattern to provide real environment to a single part of an effect."),(0,o.kt)("h2",{id:"layer-memoization"},"Layer Memoization"),(0,o.kt)("p",null,"Layer memoization allows a layer to be created once and used multiple times in the dependency graph. So if we use the same layer twice, e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"(a >>> b) ++ (a >>> c)"),", then the ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," layer will be allocated only once."),(0,o.kt)("h3",{id:"layers-are-memoized-by-default-when-providing-globally"},"Layers are Memoized by Default when Providing Globally"),(0,o.kt)("p",null,"One important feature of a ZIO application is that layers are shared by default, meaning that if the same layer is used twice, and if we provide the layer ",(0,o.kt)("a",{parentName:"p",href:"#global-environment"},"globally")," the layer will only be allocated a single time. For every layer in our dependency graph, there is only one instance of it that is shared between all the layers that depend on it."),(0,o.kt)("p",null,"For example, assume we have the three ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," services. The implementation of both ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," are dependent on the ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ntrait A\ntrait B\ntrait C\n\ncase class BLive(a: A) extends B\ncase class CLive(a: A) extends C\n\nval a: ZLayer[Any, Nothing, A] =\n  ZLayer(ZIO.succeed(new A {}).debug("initialized"))\n\nval b: ZLayer[A, Nothing, B] =\n  ZLayer {\n    for {\n      a <- ZIO.service[A]\n    } yield BLive(a)\n  }\n\nval c: ZLayer[A, Nothing, C] =\n  ZLayer {\n    for {\n      a <- ZIO.service[A]\n    } yield CLive(a)\n  }\n')),(0,o.kt)("p",null,"Although both ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," layers require the ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," layer, the ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," layer is instantiated only once. It is shared with both ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"c"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[B & C, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[B]\n      _ <- ZIO.service[C]\n    } yield ()\n    \n  // alternative: myApp.provideLayer((a >>> b) ++ (a >>> c))\n  def run = myApp.provide(a, b, c) \n}\n")),(0,o.kt)("h4",{id:"acquiring-a-fresh-version"},"Acquiring a Fresh Version"),(0,o.kt)("p",null,"If we don't want to share a module, we should create a fresh, non-shared version of it through ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#fresh"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[B & C, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[B]\n      _ <- ZIO.service[C]\n    } yield ()\n\n  def run = myApp.provideLayer((a.fresh >>> b) ++ (a.fresh >>> c))\n}\n")),(0,o.kt)("h3",{id:"layers-are-not-memoized-when-providing-locally"},"Layers are not Memoized When Providing Locally"),(0,o.kt)("p",null,"If we don't provide a layer globally but instead provide them ",(0,o.kt)("a",{parentName:"p",href:"#local-environment"},"locally"),", that layer doesn't support memoization by default."),(0,o.kt)("p",null,"In the following example, we provided the ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," layer two times locally and the ZIO doesn't memoize the construction of the ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," layer. So, it will be initialized two times:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[A].provide(a) // providing locally\n      _ <- ZIO.service[A].provide(a) // providing locally\n    } yield ()\n\n  def run = myApp\n}\n")),(0,o.kt)("h4",{id:"manual-memoization"},"Manual Memoization"),(0,o.kt)("p",null,"We can memoize the ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," layer manually using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#memoize")," operator. It will return a scoped effect that, if evaluated, will return the lazily computed result of this layer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    ZIO.scoped {\n      a.memoize.flatMap { aLayer =>\n        for {\n          _ <- ZIO.service[A].provide(aLayer)\n          _ <- ZIO.service[A].provide(aLayer)\n        } yield ()\n      }\n    }\n    \n  def run = myApp\n}\n")),(0,o.kt)("h2",{id:"other-operators"},"Other Operators"),(0,o.kt)("h3",{id:"converting-a-layer-to-a-scoped-value"},"Converting a Layer to a Scoped Value"),(0,o.kt)("p",null,"Every ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," can be converted to a scoped ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," by using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer.build"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ntrait Database {\n  def close: UIO[Unit]\n}\n\nobject Database {\n  def connect: ZIO[Any, Throwable, Database] = ???\n}\n\nval database: ZLayer[Any, Throwable, Database] =\n  ZLayer.scoped {\n    ZIO.acquireRelease {\n      Database.connect.debug("connecting to the database")\n    } { database =>\n      database.close\n    }\n  }\n\nval scopedDatabase: ZIO[Scope, Throwable, ZEnvironment[Database]] =\n  database.build\n')),(0,o.kt)("h3",{id:"falling-back-to-an-alternate-layer"},"Falling Back to an Alternate Layer"),(0,o.kt)("p",null,"If a layer fails, we can provide an alternative layer by using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#orElse")," so it will fall back to the second layer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Database\n\nval postgresDatabaseLayer: ZLayer[Any, Throwable, Database] = ???\nval inmemoryDatabaseLayer: ZLayer[Any, Throwable, Database] = ???\n\nval databaseLayer: ZLayer[Any, Throwable, Database] =\n  postgresDatabaseLayer.orElse(inmemoryDatabaseLayer)\n")),(0,o.kt)("h3",{id:"converting-a-layer-to-a-zio-application"},"Converting a Layer to a ZIO Application"),(0,o.kt)("p",null,"Sometimes our entire application is a ZIO Layer, e.g. an HTTP Server, so by calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#launch")," we can convert that to a ZIO application. This will build the layer and use it until it is interrupted."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object MainApp extends ZIOAppDefault {\n\n  val httpServer: ZLayer[Any, Nothing, HttpServer] =\n    ZLayer.make[HttpServer](\n      JsonParserLive.layer,\n      TemplateEngineLive.layer \n    )\n\n  def run = httpServer.launch\n\n}\n")),(0,o.kt)("h3",{id:"retrying"},"Retrying"),(0,o.kt)("p",null,"We can retry constructing a layer in case of failure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval databaseLayer: ZLayer[Any, Throwable, DatabaseConnection]   = ???\n\nval retriedLayer : ZLayer[Clock, Throwable, DatabaseConnection] = databaseLayer.retry(Schedule.fibonacci(1.second))\n")),(0,o.kt)("h3",{id:"layer-projection"},"Layer Projection"),(0,o.kt)("p",null,"We can project out a part of ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," by providing a projection function to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#project")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ncase class Connection(host: String, port: Int)  \ncase class Login(user: String, password: String)\n\ncase class DBConfig(\n  connection: Connection, \n  login: Login\n)\n\nval connection: ZLayer[DBConfig, Nothing, Connection] = \n  ZLayer.service[DBConfig].project(_.connection)\n")),(0,o.kt)("h3",{id:"tapping"},"Tapping"),(0,o.kt)("p",null,"We can perform a specified effect based on the success or failure result of the layer using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#tap"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#tapError"),". This would not change the layer's signature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval config: ZLayer[Any, Throwable, AppConfig] =\n  ZLayer.fromZIO(\n    ZIO.attempt(???) // reading config from a file\n  )\n\nval res: ZLayer[Any, Throwable, AppConfig] =\n  config\n    .tap(cnf => ZIO.debug(s"layer acquisition succeeded with $cnf"))\n    .tapError(err => ZIO.debug(s"error occurred during reading the config $err"))\n')),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("h3",{id:"an-example-of-a-zio-application-with-a-simple-dependency"},"An Example of a ZIO Application with a Simple Dependency"),(0,o.kt)("p",null,"This application demonstrates a ZIO program with a single dependency on a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"AppConfig"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class AppConfig(poolSize: Int)\n\nobject MainApp extends ZIOAppDefault {\n\n  // Define our simple ZIO program\n  val zio: ZIO[AppConfig, Nothing, Unit] = \n    for {\n      config <- ZIO.service[AppConfig]\n      _      <- ZIO.succeed(println(s"Application started with config: $config"))\n    } yield ()\n\n  // Create a ZLayer that produces an AppConfig and can be used to satisfy the AppConfig \n  // dependency that the program has\n  val defaultConfig: ULayer[AppConfig] = ZLayer.succeed(AppConfig(10))\n\n  // Run the program, providing the `defaultConfig`\n  def run = zio.provide(defaultConfig)\n}\n')),(0,o.kt)("h3",{id:"an-example-of-manually-generating-a-dependency-graph"},"An Example of Manually Generating a Dependency Graph"),(0,o.kt)("p",null,"Suppose we have defined the ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"DocumentRepo"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Database"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"BlobStorage"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Cache")," services and their respective implementations as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class User(email: String, name: String)\n\ntrait UserRepo {\n  def save(user: User): Task[Unit]\n\n  def get(email: String): Task[User]\n}\n\nobject UserRepo {\n  def save(user: User): ZIO[UserRepo, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.save(user))\n\n  def get(email: String): ZIO[UserRepo, Throwable, User] =\n    ZIO.serviceWithZIO(_.get(email))\n}\n\ncase class UserRepoLive(cache: Cache, database: Database) extends UserRepo {\n  override def save(user: User): Task[Unit] = ???\n\n  override def get(email: String): Task[User] = ???\n}\n\nobject UserRepoLive {\n  val layer: URLayer[Cache & Database, UserRepo] =\n    ZLayer {\n      for {\n        cache    <- ZIO.service[Cache]\n        database <- ZIO.service[Database]\n      } yield UserRepoLive(cache, database)\n    }\n}\n\ntrait Database\n\ncase class DatabaseLive() extends Database\n\nobject DatabaseLive {\n  val layer: ZLayer[Any, Nothing, Database] =\n    ZLayer.succeed(DatabaseLive())\n}\n\ntrait Cache {\n  def save(key: String, value: Array[Byte]): Task[Unit]\n\n  def get(key: String): Task[Array[Byte]]\n\n  def remove(key: String): Task[Unit]\n}\n\nclass InmemeoryCache() extends Cache {\n  override def save(key: String, value: Array[Byte]): Task[Unit] = ???\n\n  override def get(key: String): Task[Array[Byte]] = ???\n\n  override def remove(key: String): Task[Unit] = ???\n}\n\nobject InmemoryCache {\n  val layer: ZLayer[Any, Throwable, Cache] =\n    ZLayer(ZIO.attempt(new InmemeoryCache).debug("initialized"))\n}\n\nclass PersistentCache() extends Cache {\n  override def save(key: String, value: Array[Byte]): Task[Unit] = ???\n\n  override def get(key: String): Task[Array[Byte]] = ???\n\n  override def remove(key: String): Task[Unit] = ???\n}\n\nobject PersistentCache {\n  val layer: ZLayer[Any, Throwable, Cache] =\n    ZLayer(ZIO.attempt(new PersistentCache).debug("initialized"))\n}\n\ncase class Document(title: String, author: String, body: String)\n\ntrait DocumentRepo {\n  def save(document: Document): Task[Unit]\n\n  def get(id: String): Task[Document]\n}\n\nobject DocumentRepo {\n  def save(document: Document): ZIO[DocumentRepo, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.save(document))\n\n  def get(id: String): ZIO[DocumentRepo, Throwable, Document] =\n    ZIO.serviceWithZIO(_.get(id))\n}\n\ncase class DocumentRepoLive(cache: Cache, blobStorage: BlobStorage) extends DocumentRepo {\n  override def save(document: Document): Task[Unit] = ???\n\n  override def get(id: String): Task[Document] = ???\n}\n\nobject DocumentRepoLive {\n  val layer: ZLayer[Cache & BlobStorage, Nothing, DocumentRepo] =\n    ZLayer {\n      for {\n        cache       <- ZIO.service[Cache]\n        blobStorage <- ZIO.service[BlobStorage]\n      } yield DocumentRepoLive(cache, blobStorage)\n    }\n}\n\ntrait BlobStorage {\n  def store(key: String, value: Array[Byte]): Task[Unit]\n}\n\ncase class BlobStorageLive() extends BlobStorage {\n  override def store(key: String, value: Array[Byte]): Task[Unit] = ???\n}\n\nobject BlobStorageLive {\n  val layer: URLayer[Any, BlobStorage] =\n    ZLayer.succeed(BlobStorageLive())\n}\n')),(0,o.kt)("p",null,"And then assume we have the following ZIO application:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef myApp: ZIO[DocumentRepo & UserRepo, Throwable, Unit] =\n  for {\n    _ <- UserRepo.save(User("john@doe", "john"))\n    _ <- DocumentRepo.save(Document("introduction to zio", "john", ""))\n    _ <- UserRepo.get("john@doe").debug("retrieved john@doe user")\n    _ <- DocumentRepo.get("introduction to zio").debug("retrieved article about zio")\n  } yield ()\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"myApp")," requires ",(0,o.kt)("inlineCode",{parentName:"p"},"DocumentRepo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo")," services to run. So we need to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," which requires no services and produces ",(0,o.kt)("inlineCode",{parentName:"p"},"DocumentRepo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo"),". We can manually create this layer using ",(0,o.kt)("a",{parentName:"p",href:"#vertical-and-horizontal-composition"},"vertical and horizontal layer composition"),": "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Any, DocumentRepo with UserRepo] =\n    (BlobStorageLive.layer ++ InmemoryCache.layer ++ DatabaseLive.layer) >>>\n      (DocumentRepoLive.layer >+> UserRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n")),(0,o.kt)("h3",{id:"an-example-of-automatically-generating-a-dependency-graph"},"An Example of Automatically Generating a Dependency Graph"),(0,o.kt)("p",null,"Instead of creating the required layer manually, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO#provide"),". ZIO internally creates the dependency graph automatically based on all dependencies provided:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def run =\n    myApp.provide(\n      InmemoryCache.layer,\n      DatabaseLive.layer,\n      UserRepoLive.layer,\n      BlobStorageLive.layer,\n      DocumentRepoLive.layer\n    )\n    \n}\n")),(0,o.kt)("h3",{id:"an-example-of-providing-different-implementations-of-the-same-service"},"An Example of Providing Different Implementations of the Same Service"),(0,o.kt)("p",null,"Let's say we want to provide different versions of the same service to different services. In this example, both ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DocumentRepo")," services require the ",(0,o.kt)("inlineCode",{parentName:"p"},"Cache")," service. However, we want to provide different cache implementations for these two services. Our goal is to provide an ",(0,o.kt)("inlineCode",{parentName:"p"},"InmemoryCache")," layer for ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"PersistentCache")," layer for the ",(0,o.kt)("inlineCode",{parentName:"p"},"DocumentRepo")," service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Throwable, UserRepo with DocumentRepo] =\n    ((InmemoryCache.layer ++ DatabaseLive.layer) >>> UserRepoLive.layer) ++\n      ((PersistentCache.layer ++ BlobStorageLive.layer) >>> DocumentRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n")),(0,o.kt)("h3",{id:"an-example-of-how-to-get-fresh-layers"},"An Example of How to Get Fresh Layers"),(0,o.kt)("p",null,"Having covered the topic of ",(0,o.kt)("a",{parentName:"p",href:"#acquiring-a-fresh-version"},"acquiring fresh layers"),", let's see an example of using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#fresh")," operator."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DocumentRepo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo")," services are dependent on an in-memory cache service. On the other hand, let's assume the cache service is quite simple, and we might be prone to cache conflicts between services. While sharing the cache service may cause some problems for our business logic, we should separate the cache service for both ",(0,o.kt)("inlineCode",{parentName:"p"},"DocumentRepo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Throwable, UserRepo & DocumentRepo] =\n    ((InmemoryCache.layer.fresh ++ DatabaseLive.layer) >>> UserRepoLive.layer) ++\n      ((InmemoryCache.layer.fresh ++ BlobStorageLive.layer) >>> DocumentRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n")),(0,o.kt)("h3",{id:"an-example-of-pass-through-dependencies"},"An Example of Pass-through Dependencies"),(0,o.kt)("p",null,"Notice that in the previous examples, both ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DocuemntRepo")," have some ",(0,o.kt)("a",{parentName:"p",href:"#hidden-versus-passed-through-dependencies"},"hidden dependencies"),", such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Cache"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Database"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"BlobStorage"),".  So these hidden dependencies are no longer expressed in the type signature of the ",(0,o.kt)("inlineCode",{parentName:"p"},"layers"),". From the perspective of a caller, ",(0,o.kt)("inlineCode",{parentName:"p"},"layers")," just outputs a ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DocuemntRepo")," and requires no inputs. The caller does not need to be concerned with the internal implementation details of how the ",(0,o.kt)("inlineCode",{parentName:"p"},"UserRepo")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DocumentRepo")," are constructed."),(0,o.kt)("p",null,'An upstream dependency that is used by many other services can be "passed-through" and included in a layer\'s output. This can be done with the ',(0,o.kt)("inlineCode",{parentName:"p"},">+>")," operator, which provides the output of one layer to another layer, returning a new layer that outputs the services of ",(0,o.kt)("em",{parentName:"p"},"both"),"."),(0,o.kt)("p",null,"The following example shows how to passthrough all dependencies to the final layer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  // passthrough all dependencies\n  val layers: ZLayer[Any, Throwable, Database & BlobStorage & Cache & DocumentRepo & UserRepo] =\n    DatabaseLive.layer >+>\n      BlobStorageLive.layer >+>\n      InmemoryCache.layer >+>\n      DocumentRepoLive.layer >+>\n      UserRepoLive.layer\n\n  // providing all passthrough dependencies to the ZIO application\n  def run = myApp.provideLayer(layers)\n}\n")),(0,o.kt)("h3",{id:"an-example-of-updating-hidden-dependencies"},"An Example of Updating Hidden Dependencies"),(0,o.kt)("p",null,"One of the use cases of having explicit all dependencies in the final layer is that we can ",(0,o.kt)("a",{parentName:"p",href:"#updating-local-dependencies"},"update")," those hidden layers using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer#update"),". In the following example, we are replacing the ",(0,o.kt)("inlineCode",{parentName:"p"},"InmemoryCache")," with another implementation called ",(0,o.kt)("inlineCode",{parentName:"p"},"PersistentCache"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def myApp: ZIO[DocumentRepo & UserRepo, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[UserRepo]\n      _ <- ZIO.service[DocumentRepo]\n    } yield ()\n\n  val layers: ZLayer[Any, Throwable, Database & BlobStorage & Cache & DocumentRepo & UserRepo] =\n    DatabaseLive.layer >+>\n      BlobStorageLive.layer >+>\n      InmemoryCache.layer >+>\n      DocumentRepoLive.layer >+>\n      UserRepoLive.layer\n\n  def run =\n    myApp.provideLayer(\n      layers.update[Cache](_ => new PersistentCache)\n    )\n}\n")))}d.isMDXComponent=!0}}]);