"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[4035],{3905:function(e,n,i){i.d(n,{Zo:function(){return d},kt:function(){return m}});var t=i(7294);function r(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function a(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,t)}return i}function o(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?a(Object(i),!0).forEach((function(n){r(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function l(e,n){if(null==e)return{};var i,t,r=function(e,n){if(null==e)return{};var i,t,r={},a=Object.keys(e);for(t=0;t<a.length;t++)i=a[t],n.indexOf(i)>=0||(r[i]=e[i]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)i=a[t],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var s=t.createContext({}),c=function(e){var n=t.useContext(s),i=n;return e&&(i="function"==typeof e?e(n):o(o({},n),e)),i},d=function(e){var n=c(e.components);return t.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var i=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(i),m=r,v=u["".concat(s,".").concat(m)]||u[m]||p[m]||a;return i?t.createElement(v,o(o({ref:n},d),{},{components:i})):t.createElement(v,o({ref:n},d))}));function m(e,n){var i=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=i.length,o=new Array(a);o[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<a;c++)o[c]=i[c];return t.createElement.apply(null,o)}return t.createElement.apply(null,i)}u.displayName="MDXCreateElement"},2108:function(e,n,i){i.r(n),i.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return d},default:function(){return u}});var t=i(7462),r=i(3366),a=(i(7294),i(3905)),o=["components"],l={id:"zservicebuilder",title:"ZServiceBuilder"},s=void 0,c={unversionedId:"datatypes/contextual/zservicebuilder",id:"datatypes/contextual/zservicebuilder",isDocsHomePage:!1,title:"ZServiceBuilder",description:"A ZServiceBuilder[-RIn, +E, +ROut] describes a service builder of an application: every service builder in an application requires some services as input RIn and produces some services as the output ROut.",source:"@site/docs/datatypes/contextual/zservicebuilder.md",sourceDirName:"datatypes/contextual",slug:"/datatypes/contextual/zservicebuilder",permalink:"/next/datatypes/contextual/zservicebuilder",editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/datatypes/contextual/zservicebuilder.md",tags:[],version:"current",frontMatter:{id:"zservicebuilder",title:"ZServiceBuilder"},sidebar:"datatypes-sidebar",previous:{title:"HasMany",permalink:"/next/datatypes/contextual/hasmany"},next:{title:"RServiceBuilder",permalink:"/next/datatypes/contextual/rservicebuilder"}},d=[{value:"Creation",id:"creation",children:[{value:"From Simple Values",id:"from-simple-values",children:[],level:3},{value:"From Managed Resources",id:"from-managed-resources",children:[],level:3},{value:"From ZIO Effects",id:"from-zio-effects",children:[],level:3},{value:"From another Service",id:"from-another-service",children:[],level:3}],level:2},{value:"Vertical and Horizontal Composition",id:"vertical-and-horizontal-composition",children:[],level:2},{value:"Service Builder Memoization",id:"service-builder-memoization",children:[],level:2},{value:"Updating Local Dependencies",id:"updating-local-dependencies",children:[],level:2},{value:"Hidden Versus Passed Through Dependencies",id:"hidden-versus-passed-through-dependencies",children:[],level:2},{value:"Cyclic Dependencies",id:"cyclic-dependencies",children:[],level:2},{value:"Asynchronous Service Construction",id:"asynchronous-service-construction",children:[],level:2},{value:"Examples",id:"examples",children:[{value:"The simplest ZServiceBuilder application",id:"the-simplest-zservicebuilder-application",children:[],level:3},{value:"ZServiceBuilder application with dependencies",id:"zservicebuilder-application-with-dependencies",children:[],level:3},{value:"ZServiceBuilder example with complex dependencies",id:"zservicebuilder-example-with-complex-dependencies",children:[],level:3}],level:2}],p={toc:d};function u(e){var n=e.components,i=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,t.Z)({},p,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder[-RIn, +E, +ROut]")," describes a service builder of an application: every service builder in an application requires some services as input ",(0,a.kt)("inlineCode",{parentName:"p"},"RIn")," and produces some services as the output ",(0,a.kt)("inlineCode",{parentName:"p"},"ROut"),". "),(0,a.kt)("p",null,"Service builders are:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Recipes for Creating Services")," \u2014 They describe how a given dependencies produces another services. For example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder[Logging with Database, Throwable, UserRepo]")," is a recipe for building a service that requires ",(0,a.kt)("inlineCode",{parentName:"p"},"Logging")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Database")," service, and it produces a ",(0,a.kt)("inlineCode",{parentName:"p"},"UserRepo")," service.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"An Alternative to Constructors")," \u2014 We can think of ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," as a more powerful version of a constructor, it is an alternative way to represent a constructor. Like a constructor, it allows us to build the ",(0,a.kt)("inlineCode",{parentName:"p"},"ROut")," service in terms of its dependencies (",(0,a.kt)("inlineCode",{parentName:"p"},"RIn"),").")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Composable")," \u2014 Because of their excellent ",(0,a.kt)("strong",{parentName:"p"},"composition properties"),", service builders are the idiomatic way in ZIO to create services that depend on other services. We can define service builders that are relying on each other. ")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Effectful and Resourceful")," \u2014 The construction of ZIO service builders can be effectful and resourceful, they can be acquired and safely released when the services are done being utilized.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Asynchronous")," \u2014 Unlike class constructors which are blocking, ZServiceBuilder is fully asynchronous and non-blocking."))),(0,a.kt)("p",null,"For example, a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder[Blocking with Logging, Throwable, Database]")," can be thought of as a function that map ",(0,a.kt)("inlineCode",{parentName:"p"},"Blocking")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Logging")," services into ",(0,a.kt)("inlineCode",{parentName:"p"},"Database")," service: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"(Blocking, Logging) => Database\n")),(0,a.kt)("p",null,"So we can say that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Database")," service has two dependencies: ",(0,a.kt)("inlineCode",{parentName:"p"},"Blocking")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Logging")," services."),(0,a.kt)("p",null,"Let's see how we can create a service builder:"),(0,a.kt)("h2",{id:"creation"},"Creation"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," is an ",(0,a.kt)("strong",{parentName:"p"},"alternative to a class constructor"),", a recipe to create a service. This recipe may contain the following information:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Dependencies")," \u2014 To create a service, we need to indicate what other service we are depending on. For example, a ",(0,a.kt)("inlineCode",{parentName:"p"},"Database")," service might need ",(0,a.kt)("inlineCode",{parentName:"p"},"Socket")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Blocking")," services to perform its operations.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Acquisition/Release Action")," \u2014 It may contain how to initialize a service. For example, if we are creating a recipe for a ",(0,a.kt)("inlineCode",{parentName:"p"},"Database")," service, we should provide how the ",(0,a.kt)("inlineCode",{parentName:"p"},"Database")," will be initialized, via acquisition action. Also, it may contain how to release a service. For example, how the ",(0,a.kt)("inlineCode",{parentName:"p"},"Database")," releases its connection pools."))),(0,a.kt)("p",null,"In some cases, a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," may not have any dependencies or requirements from the environment. In this case, we can specify ",(0,a.kt)("inlineCode",{parentName:"p"},"Any")," for the ",(0,a.kt)("inlineCode",{parentName:"p"},"RIn")," type parameter. The ",(0,a.kt)("inlineCode",{parentName:"p"},"ServiceBuilder")," type alias provided by ZIO is a convenient way to define a service builder without requirements."),(0,a.kt)("p",null,"There are many ways to create a ZServiceBuilder. Here's an incomplete list:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZServiceBuilder.succeed")," to create a service builder from an existing service"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZServiceBuilder.succeedMany")," to create a service builder from a value that's one or more services"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZServiceBuilder.fromFunction")," to create a service builder from a function from the requirement to the service"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZServiceBuilder.fromEffect")," to lift a ",(0,a.kt)("inlineCode",{parentName:"li"},"ZIO")," effect to a service builder requiring the effect environment"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZServiceBuilder.fromAcquireRelease")," for a service builder based on resource acquisition/release. The idea is the same as ",(0,a.kt)("inlineCode",{parentName:"li"},"ZManaged"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZServiceBuilder.fromService")," to build a service builer from a service"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZServiceBuilder.fromServices")," to build a service builder from a number of required services"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZServiceBuilder.identity")," to express the requirement for a dependency"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ZIO#toServiceBuilder")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"ZManaged#toServiceBuilder")," to construct a service builder from an effect")),(0,a.kt)("p",null,"Where it makes sense, these methods have also variants to build a service effectfully (suffixed by ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO"),"), resourcefully (suffixed by ",(0,a.kt)("inlineCode",{parentName:"p"},"Managed"),"), or to create a combination of services (suffixed by ",(0,a.kt)("inlineCode",{parentName:"p"},"Many"),")."),(0,a.kt)("p",null,"Let's review some of the ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder"),"'s most useful constructors:"),(0,a.kt)("h3",{id:"from-simple-values"},"From Simple Values"),(0,a.kt)("p",null,"With ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder.succeed")," we can construct a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," from a value. It returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"UServiceBuilder[Has[A]]")," value, which represents a service builder of an application that ",(0,a.kt)("em",{parentName:"p"},"has")," a service of type ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def succeed[A: Tag](a: A): UServiceBuilder[Has[A]]\n")),(0,a.kt)("p",null,"In the following example, we are going to create a ",(0,a.kt)("inlineCode",{parentName:"p"},"nameServiceBuilder")," that provides us the name of ",(0,a.kt)("inlineCode",{parentName:"p"},"Adam"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val nameServiceBuilder: UServiceBuilder[Has[String]] = ZServiceBuilder.succeed("Adam")\n')),(0,a.kt)("p",null,"In most cases, we use ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder.succeed")," to create a service builder of type ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,a.kt)("p",null,"For example, assume we have written the following service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"object terminal {\n  type Terminal = Has[Terminal.Service]\n\n  object Terminal {\n    trait Service {\n      def printLine(line: String): UIO[Unit]\n    }\n\n    object Service {\n      val live: Service = new Service {\n        override def printLine(line: String): UIO[Unit] =\n          ZIO.succeed(println(line))\n      }\n    }\n  }\n}\n")),(0,a.kt)("p",null,"Now we can create a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," from the ",(0,a.kt)("inlineCode",{parentName:"p"},"live")," version of this service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import terminal._\nval live: ZServiceBuilder[Any, Nothing, Terminal] = ZServiceBuilder.succeed(Terminal.Service.live)\n")),(0,a.kt)("h3",{id:"from-managed-resources"},"From Managed Resources"),(0,a.kt)("p",null,"Some components of our applications need to be managed, meaning they undergo a resource acquisition phase before usage, and a resource release phase after usage (e.g. when the application shuts down). "),(0,a.kt)("p",null,"Fortunately, the construction of ZIO service builders can be effectful and resourceful, this means they can be acquired and safely released when the services are done being utilized."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," relies on the powerful ",(0,a.kt)("inlineCode",{parentName:"p"},"ZManaged")," data type and this makes this process extremely simple."),(0,a.kt)("p",null,"We can lift any ",(0,a.kt)("inlineCode",{parentName:"p"},"ZManaged")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," by providing a managed resource to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO.fromManaged")," constructor:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val managedFile = ZManaged.fromAutoCloseable(\n  ZIO.attempt(scala.io.Source.fromFile("file.txt"))\n)\nval fileServiceBuilder: ZServiceBuilder[Any, Throwable, Has[BufferedSource]] = \n  ZServiceBuilder.fromManaged(managedFile)\n')),(0,a.kt)("p",null,"Also, every ",(0,a.kt)("inlineCode",{parentName:"p"},"ZManaged")," can be converted to ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder#toServiceBuilder"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val fileServiceBuilder: ZServiceBuilder[Any, Throwable, Has[BufferedSource]] = managedFile.toServiceBuilder\n")),(0,a.kt)("p",null,"Let's see another real-world example of creating a service builder from managed resources. Assume we have written a managed ",(0,a.kt)("inlineCode",{parentName:"p"},"UserRepository"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def userRepository: ZManaged[Has[Console], Throwable, UserRepository] = for {\n  cfg <- dbConfig.toManaged\n  _ <- initializeDb(cfg).toManaged\n  xa <- makeTransactor(cfg)\n} yield new UserRepository(xa)\n")),(0,a.kt)("p",null,"We can convert that to ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," with ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder.fromManaged")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"ZManaged#toServiceBuilder"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val usersServiceBuilder  = userRepository.toServiceBuilder\n// usersServiceBuilder: ZServiceBuilder[Has[Console], Throwable, Has[UserRepository]] = Managed(\n//   self = zio.ZManaged$$anon$2@654eca2b\n// )\nval usersServiceBuilder_ = ZServiceBuilder.fromManaged(userRepository)\n// usersServiceBuilder_: ZServiceBuilder[Has[Console], Throwable, Has[UserRepository]] = Managed(\n//   self = zio.ZManaged$$anon$2@7232f040\n// )\n")),(0,a.kt)("p",null,"Also, we can create a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," directly from ",(0,a.kt)("inlineCode",{parentName:"p"},"acquire")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"release")," actions of a managed resource:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'def acquire = ZIO.attempt(new FileInputStream("file.txt"))\ndef release(resource: Closeable) = ZIO.succeed(resource.close())\n\nval inputStreamServiceBuilder = ZServiceBuilder.fromAcquireRelease(acquire)(release)\n// inputStreamServiceBuilder: ZServiceBuilder[Any, Throwable, Has[FileInputStream]] = Managed(\n//   self = zio.ZManaged$$anon$2@104fe54b\n// )\n')),(0,a.kt)("h3",{id:"from-zio-effects"},"From ZIO Effects"),(0,a.kt)("p",null,"We can create ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," from any ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO")," effect by using ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder.fromEffect")," constructor, or calling ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO#toServiceBuilder")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val serviceBuilder = ZServiceBuilder.fromZIO(ZIO.succeed("Hello, World!"))\n// serviceBuilder: ZServiceBuilder[Any, Nothing, Has[String]] = Managed(\n//   self = zio.ZManaged$$anon$2@3437afb\n// )\nval serviceBuilder_ = ZIO.succeed("Hello, World!").toServiceBuilder\n// serviceBuilder_: ZServiceBuilder[Any, Nothing, Has[String]] = Managed(\n//   self = zio.ZManaged$$anon$2@55a331ae\n// )\n')),(0,a.kt)("p",null,"Assume we have a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO")," effect that read the application config from a file, we can create a service builder from that:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def loadConfig: Task[AppConfig] = Task.attempt(???)\nval configServiceBuilder = ZServiceBuilder.fromZIO(loadConfig)\n// configServiceBuilder: ZServiceBuilder[Any, Throwable, Has[AppConfig]] = Managed(\n//   self = zio.ZManaged$$anon$2@7a83826c\n// )\n")),(0,a.kt)("h3",{id:"from-another-service"},"From another Service"),(0,a.kt)("p",null,"Every ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," describes an application that requires some services as input and produces some services as output. Sometimes when we are creating a service builder, we may need to access and depend on one or several services."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder.fromService")," construct a service builder that purely depends on the specified service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def fromService[A: Tag, B: Tag](f: A => B): ZServiceBuilder[Has[A], Nothing, Has[B]]\n")),(0,a.kt)("p",null,"Assume we want to write a ",(0,a.kt)("inlineCode",{parentName:"p"},"live")," version of the following logging service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"object logging {\n  type Logging = Has[Logging.Service]\n\n  object Logging {\n    trait Service {\n      def log(msg: String): UIO[Unit]\n    }\n  }\n}\n")),(0,a.kt)("p",null,"We can create that by using ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder.fromService")," constructor, which depends on ",(0,a.kt)("inlineCode",{parentName:"p"},"Console")," service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val live: ZServiceBuilder[Has[Console], Nothing, Logging] = ZServiceBuilder.fromService(console =>\n  new Service {\n    override def log(msg: String): UIO[Unit] = console.printLine(msg).orDie\n  }\n)\n")),(0,a.kt)("h2",{id:"vertical-and-horizontal-composition"},"Vertical and Horizontal Composition"),(0,a.kt)("p",null,"We said that we can think of the ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," as a more powerful ",(0,a.kt)("em",{parentName:"p"},"constructor"),". Constructors are not composable, because they are not values. While a constructor is not composable, ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," has a nice facility to compose with other ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder"),"s. So we can say that a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," turns a constructor into values."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder"),"s can be composed together horizontally or vertically:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Horizontal Composition")," \u2014 They can be composed together horizontally with the ",(0,a.kt)("inlineCode",{parentName:"p"},"++")," operator. When we compose service builders horizontally, the new service builder requires all the services that both of them require and produces all services that both of them produce. Horizontal composition is a way of composing two service builders side-by-side. It is useful when we combine two service builders that they don't have any relationship with each other. ")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Vertical Composition")," \u2014 If we have a service builder that requires ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," and produces ",(0,a.kt)("inlineCode",{parentName:"p"},"B"),", we can compose this with another service builder that requires ",(0,a.kt)("inlineCode",{parentName:"p"},"B")," and produces ",(0,a.kt)("inlineCode",{parentName:"p"},"C"),"; this composition produces a service builder that requires ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," and produces ",(0,a.kt)("inlineCode",{parentName:"p"},"C"),". The feed operator, ",(0,a.kt)("inlineCode",{parentName:"p"},">>>"),", stack them on top of each other by using vertical composition. This sort of composition is like ",(0,a.kt)("em",{parentName:"p"},"function composition"),", feeding an output of one service builder to an input of another."))),(0,a.kt)("p",null,"Let's get into an example, assume we have these services with their implementations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"trait Logging { }\ntrait Database { }\ntrait BlobStorage { }\ntrait UserRepo { }\ntrait DocRepo { }\n\ncase class LoggerImpl(console: Console) extends Logging { }\ncase object DatabaseImp extends Database { }\ncase class UserRepoImpl(logging: Logging, database: Database) extends UserRepo { } \ncase class BlobStorageImpl(logging: Logging) extends BlobStorage { }\ncase class DocRepoImpl(logging: Logging, database: Database, blobStorage: BlobStorage) extends DocRepo { }\n")),(0,a.kt)("p",null,"We can't compose these services together, because their constructors are not value. ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," can convert these services into values, then we can compose them together."),(0,a.kt)("p",null,"Let's assume we have lifted these services into ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder"),"s:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val logging: URServiceBuilder[Has[Console], Has[Logging]] = \n  (LoggerImpl.apply _).toServiceBuilder\nval database: URServiceBuilder[Any, Has[Database]] = \n  ZServiceBuilder.succeed(DatabaseImp)\nval userRepo: URServiceBuilder[Has[Logging] with Has[Database], Has[UserRepo]] = \n  (UserRepoImpl(_, _)).toServiceBuilder\nval blobStorage: URServiceBuilder[Has[Logging], Has[BlobStorage]] = \n  (BlobStorageImpl(_)).toServiceBuilder\nval docRepo: URServiceBuilder[Has[Logging] with Has[Database] with Has[BlobStorage], Has[DocRepo]] = \n  (DocRepoImpl(_, _, _)).toServiceBuilder\n")),(0,a.kt)("p",null,"Now, we can compose logging and database horizontally:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val newServiceBuilder: ZServiceBuilder[Has[Console], Throwable, Has[Logging] with Has[Database]] = logging ++ database\n")),(0,a.kt)("p",null,"And then we can compose the ",(0,a.kt)("inlineCode",{parentName:"p"},"newServiceBuilder")," with ",(0,a.kt)("inlineCode",{parentName:"p"},"userRepo")," vertically:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val myServiceBuilder: ZServiceBuilder[Has[Console], Throwable, Has[UserRepo]] = newServiceBuilder >>> userRepo\n")),(0,a.kt)("h2",{id:"service-builder-memoization"},"Service Builder Memoization"),(0,a.kt)("p",null,"One important feature of ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO")," service builders is that ",(0,a.kt)("strong",{parentName:"p"},"they are shared by default"),", meaning that if the same service builder is used twice, the service builder will only be allocated a single time. "),(0,a.kt)("p",null,"For every service builder in our dependency graph, there is only one instance of it that is shared between all the service builders that depend on it. "),(0,a.kt)("p",null,"If we don't want to share a module, we should create a fresh, non-shared version of it through ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder#fresh"),"."),(0,a.kt)("h2",{id:"updating-local-dependencies"},"Updating Local Dependencies"),(0,a.kt)("p",null,"Given a service builder, it is possible to update one or more components it provides. We update a dependency in two ways:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Using the ",(0,a.kt)("inlineCode",{parentName:"strong"},"update")," Method")," \u2014 This method allows us to replace one requirement with a different implementation:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val withPostgresService = horizontal.update[UserRepo.Service]{ oldRepo  => new UserRepo.Service {\n      override def getUser(userId: UserId): IO[DBError, Option[User]] = UIO(???)\n      override def createUser(user: User): IO[DBError, Unit] = UIO(???)\n    }\n  }\n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Using Horizontal Composition")," \u2014 Another way to update a requirement is to horizontally compose in a service builder that provides the updated service. The resulting composition will replace the old service builder with the new one:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val dbServiceBuilder: ServiceBuilder[Nothing, UserRepo] = ZServiceBuilder.succeed(new UserRepo.Service {\n    override def getUser(userId: UserId): IO[DBError, Option[User]] = ???\n    override def createUser(user: User): IO[DBError, Unit] = ???\n  })\n\nval updatedHorizontal2 = horizontal ++ dbServiceBuilder\n")),(0,a.kt)("h2",{id:"hidden-versus-passed-through-dependencies"},"Hidden Versus Passed Through Dependencies"),(0,a.kt)("p",null,"One design decision regarding building dependency graphs is whether to hide or pass through the upstream dependencies of a service. ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," defaults to hidden dependencies but makes it easy to pass through dependencies as well."),(0,a.kt)("p",null,"To illustrate this, consider the Postgres-based repository discussed above:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val connection: ZServiceBuilder[Any, Nothing, Has[Connection]] = connectionServiceBuilder\nval userRepo: ZServiceBuilder[Has[Connection], Nothing, UserRepo] = postgresServiceBuilder\nval serviceBuilder: ZServiceBuilder[Any, Nothing, UserRepo] = connection >>> userRepo\n")),(0,a.kt)("p",null,"Notice that in ",(0,a.kt)("inlineCode",{parentName:"p"},"serviceBuilder"),", the dependency ",(0,a.kt)("inlineCode",{parentName:"p"},"UserRepo")," has on ",(0,a.kt)("inlineCode",{parentName:"p"},"Connection"),' has been "hidden", and is no longer expressed in the type signature. From the perspective of a caller, ',(0,a.kt)("inlineCode",{parentName:"p"},"serviceBuilder")," just outputs a ",(0,a.kt)("inlineCode",{parentName:"p"},"UserRepo")," and requires no inputs. The caller does not need to be concerned with the internal implementation details of how the ",(0,a.kt)("inlineCode",{parentName:"p"},"UserRepo")," is constructed."),(0,a.kt)("p",null,"To provide only some inputs, we need to explicitly define what inputs still need to be provided:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"trait Configuration\n\nval userRepoWithConfig: ZServiceBuilder[Has[Configuration] with Has[Connection], Nothing, UserRepo] = \n  ZServiceBuilder.succeed(new Configuration{}) ++ postgresServiceBuilder\nval partialServiceBuilder: ZServiceBuilder[Has[Configuration], Nothing, UserRepo] = \n  (ZServiceBuilder.environment[Has[Configuration]] ++ connection) >>> userRepoWithConfig\n")),(0,a.kt)("p",null,"In this example the requirement for a ",(0,a.kt)("inlineCode",{parentName:"p"},"Connection")," has been satisfied, but ",(0,a.kt)("inlineCode",{parentName:"p"},"Configuration")," is still required by ",(0,a.kt)("inlineCode",{parentName:"p"},"partialServiceBuilder"),"."),(0,a.kt)("p",null,"This achieves an encapsulation of services and can make it easier to refactor code. For example, say we want to refactor our application to use an in-memory database:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val updatedServiceBuilder: ZServiceBuilder[Any, Nothing, UserRepo] = dbServiceBuilder\n")),(0,a.kt)("p",null,"No other code will need to be changed, because the previous implementation's dependency upon a ",(0,a.kt)("inlineCode",{parentName:"p"},"Connection")," was hidden from users, and so they were not able to rely on it."),(0,a.kt)("p",null,'However, if an upstream dependency is used by many other services, it can be convenient to "pass through" that dependency, and include it in the output of a service builder. This can be done with the ',(0,a.kt)("inlineCode",{parentName:"p"},">+>")," operator, which provides the output of one service builder to another service builder, returning a new service builder that outputs the services of ",(0,a.kt)("em",{parentName:"p"},"both"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val serviceBuilder: ZServiceBuilder[Any, Nothing, Has[Connection] with UserRepo] = connection >+> userRepo\n")),(0,a.kt)("p",null,"Here, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Connection")," dependency has been passed through, and is available to all downstream services. This allows a style of composition where the ",(0,a.kt)("inlineCode",{parentName:"p"},">+>")," operator is used to build a progressively larger set of services, with each new service able to depend on all the services before it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"lazy val baker: ZServiceBuilder[Any, Nothing, Baker] = ???\nlazy val ingredients: ZServiceBuilder[Any, Nothing, Ingredients] = ???\nlazy val oven: ZServiceBuilder[Any, Nothing, Oven] = ???\nlazy val dough: ZServiceBuilder[Baker with Ingredients, Nothing, Dough] = ???\nlazy val cake: ZServiceBuilder[Baker with Oven with Dough, Nothing, Cake] = ???\n\nlazy val all: ZServiceBuilder[Any, Nothing, Baker with Ingredients with Oven with Dough with Cake] =\n  baker >+>       // Baker\n  ingredients >+> // Baker with Ingredients\n  oven >+>        // Baker with Ingredients with Oven\n  dough >+>       // Baker with Ingredients with Oven with Dough\n  cake            // Baker with Ingredients with Oven with Dough with Cake\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," makes it easy to mix and match these styles. If you pass through dependencies and later want to hide them you can do so through a simple type ascription:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"lazy val hidden: ZServiceBuilder[Any, Nothing, Cake] = all\n")),(0,a.kt)("p",null,"And if you do build your dependency graph more explicitly, you can be confident that dependencies used in multiple parts of the dependency graph will only be created once due to memoization and sharing."),(0,a.kt)("h2",{id:"cyclic-dependencies"},"Cyclic Dependencies"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," mechanism makes it impossible to build cyclic dependencies, making the initialization process very linear, by construction."),(0,a.kt)("h2",{id:"asynchronous-service-construction"},"Asynchronous Service Construction"),(0,a.kt)("p",null,"Another important note about ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," is that, unlike constructors which are synchronous, ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," is ",(0,a.kt)("em",{parentName:"p"},"asynchronous"),". Constructors in classes are always synchronous. This is a drawback for non-blocking applications. Because sometimes we might want to use something that is blocking the inside constructor."),(0,a.kt)("p",null,"For example, when we are constructing some sort of Kafka streaming service, we might want to connect to the Kafka cluster in the constructor of our service, which takes some time. So that wouldn't be a good idea to blocking inside a constructor. There are some workarounds for fixing this issue, but they are not perfect as the ZIO solution."),(0,a.kt)("p",null,"Well, with ZIO ZServiceBuilder, our constructor could be asynchronous, and they also can block definitely. And that is because ",(0,a.kt)("inlineCode",{parentName:"p"},"ZServiceBuilder")," has the full power of ZIO. And as a result, we have strictly more power on our constructors with ZServiceBuilder. "),(0,a.kt)("p",null,"We can acquire resources asynchronously or in a blocking fashion, and spend some time doing that, and we don't need to worry about it. That is not an anti-pattern. This is the best practice with ZIO."),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("h3",{id:"the-simplest-zservicebuilder-application"},"The simplest ZServiceBuilder application"),(0,a.kt)("p",null,"This application demonstrates a ZIO program with a single dependency on a simple string value:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject Example extends ZIOAppDefault {\n\n  // Define our simple ZIO program\n  val zio: ZIO[Has[String], Nothing, Unit] = for {\n    name <- ZIO.access[Has[String]](_.get)\n    _    <- UIO(println(s"Hello, $name!"))\n  } yield ()\n\n  // Create a ZServiceBuilder that produces a string and can be used to satisfy a string\n  // dependency that the program has\n  val nameServiceBuilder: UServiceBuilder[Has[String]] = ZServiceBuilder.succeed("Adam")\n\n  // Run the program, providing the `nameServiceBuilder`\n  def run = zio.provideSomeServices(nameServiceBuilder)\n}\n')),(0,a.kt)("h3",{id:"zservicebuilder-application-with-dependencies"},"ZServiceBuilder application with dependencies"),(0,a.kt)("p",null,"In the following example, our ZIO application has several dependencies:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"zio.Clock")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"zio.Console")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ModuleB"))),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ModuleB")," in turn depends upon ",(0,a.kt)("inlineCode",{parentName:"p"},"ModuleA"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.Clock._\nimport zio.Console._\nimport java.io.IOException\n\nobject moduleA {\n  type ModuleA = Has[ModuleA.Service]\n\n  object ModuleA {\n    trait Service {\n      def letsGoA(v: Int): UIO[String]\n    }\n\n    val any: ZServiceBuilder[ModuleA, Nothing, ModuleA] =\n      ZServiceBuilder.requires[ModuleA]\n\n    val live: ServiceBuilder[Nothing, Has[Service]] = ZServiceBuilder.succeed {\n      new Service {\n        def letsGoA(v: Int): UIO[String] = UIO(s"done: v = $v ")\n      }\n    }\n  }\n\n  def letsGoA(v: Int): URIO[ModuleA, String] =\n    ZIO.accessZIO(_.get.letsGoA(v))\n}\n\nimport moduleA._\n\nobject moduleB {\n  type ModuleB = Has[ModuleB.Service]\n\n  object ModuleB {\n    trait Service {\n      def letsGoB(v: Int): UIO[String]\n    }\n\n    val any: ZServiceBuilder[ModuleB, Nothing, ModuleB] =\n      ZServiceBuilder.requires[ModuleB]\n\n    val live: ZServiceBuilder[ModuleA, Nothing, ModuleB] = ZServiceBuilder.fromService { (moduleA: ModuleA.Service) =>\n      new Service {\n        def letsGoB(v: Int): UIO[String] =\n          moduleA.letsGoA(v)\n      }\n    }\n  }\n\n  def letsGoB(v: Int): URIO[ModuleB, String] =\n    ZIO.accessZIO(_.get.letsGoB(v))\n}\n\nobject ZServiceBuilderApp0 extends zio.App {\n\n  import moduleB._\n\n  val env = Console.live ++ Clock.live ++ (ModuleA.live >>> ModuleB.live)\n  val program: ZIO[Has[Console] with Has[Clock] with moduleB.ModuleB, IOException, Unit] =\n    for {\n      _ <- printLine(s"Welcome to ZIO!")\n      _ <- sleep(1.second)\n      r <- letsGoB(10)\n      _ <- printLine(r)\n    } yield ()\n\n  def run(args: List[String]) =\n    program.provideSomeServices(env).exitCode\n\n}\n\n// output: \n// [info] running ZServiceBuilderApp \n// Welcome to ZIO!\n// done: v = 10 \n')),(0,a.kt)("h3",{id:"zservicebuilder-example-with-complex-dependencies"},"ZServiceBuilder example with complex dependencies"),(0,a.kt)("p",null,"In this example, we can see that ",(0,a.kt)("inlineCode",{parentName:"p"},"ModuleC")," depends upon ",(0,a.kt)("inlineCode",{parentName:"p"},"ModuleA"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ModuleB"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"Clock"),". The service builder provided to the runnable application shows how dependency service builders can be combined using ",(0,a.kt)("inlineCode",{parentName:"p"},"++")," into a single combined service builder. The combined service builder will then be able to produce both of the outputs of the original sets as a single service builder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.Clock._\n\nobject ZServiceBuilderApp1 extends scala.App {\n  val rt = Runtime.default\n\n  type ModuleA = Has[ModuleA.Service]\n\n  object ModuleA {\n\n    trait Service {}\n\n    val any: ZServiceBuilder[ModuleA, Nothing, ModuleA] =\n      ZServiceBuilder.environment[ModuleA]\n\n    val live: ZServiceBuilder[Any, Nothing, ModuleA] =\n      ZServiceBuilder.succeed(new Service {})\n  }\n\n  type ModuleB = Has[ModuleB.Service]\n\n  object ModuleB {\n\n    trait Service {}\n\n    val any: ZServiceBuilder[ModuleB, Nothing, ModuleB] =\n      ZServiceBuilder.environment[ModuleB]\n\n    val live: ZServiceBuilder[Any, Nothing, ModuleB] =\n      ZServiceBuilder.succeed(new Service {})\n  }\n\n  type ModuleC = Has[ModuleC.Service]\n\n  object ModuleC {\n\n    trait Service {\n      def foo: UIO[Int]\n    }\n\n    val any: ZServiceBuilder[ModuleC, Nothing, ModuleC] =\n      ZServiceBuilder.environment[ModuleC]\n\n    val live: ZServiceBuilder[ModuleA with ModuleB with Has[Clock], Nothing, ModuleC] =\n      ZServiceBuilder.succeed {\n        new Service {\n          val foo: UIO[Int] = UIO.succeed(42)\n        }\n      }\n\n    val foo: URIO[ModuleC, Int] =\n      ZIO.accessZIO(_.get.foo)\n  }\n\n  val env = (ModuleA.live ++ ModuleB.live ++ ZServiceBuilder.environment[Has[Clock]]) >>> ModuleC.live\n\n  val res = ModuleC.foo.provideCustomServices(env)\n\n  val out = rt.unsafeRun(res)\n  println(out)\n  // 42\n}\n")))}u.isMDXComponent=!0}}]);