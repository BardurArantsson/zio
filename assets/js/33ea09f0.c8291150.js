"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[6430],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),k=r,N=u["".concat(o,".").concat(k)]||u[k]||m[k]||i;return n?a.createElement(N,l(l({ref:t},d),{},{components:n})):a.createElement(N,l({ref:t},d))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},952:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={id:"assertion",title:"Assertion"},l=void 0,s={unversionedId:"references/test/assertion",id:"references/test/assertion",title:"Assertion",description:"Assertions are used to make sure that the assumptions on computations are exactly what we expect them to be. They are executable checks for a property that must be true in our code. Also, they can be seen as a specification of a program and facilitate understanding of programs.",source:"@site/docs/references/test/assertion.md",sourceDirName:"references/test",slug:"/references/test/assertion",permalink:"/references/test/assertion",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/references/test/assertion.md",tags:[],version:"current",frontMatter:{id:"assertion",title:"Assertion"},sidebar:"references-sidebar",previous:{title:"Spec",permalink:"/references/test/spec"},next:{title:"Introduction",permalink:"/references/test/environment/"}},o={},p=[{value:"Using Assertions with ZIO Tests",id:"using-assertions-with-zio-tests",level:2},{value:"Classic Old-fashioned Assertions",id:"classic-old-fashioned-assertions",level:3},{value:"Smart Assertions",id:"smart-assertions",level:3},{value:"Logical Operations",id:"logical-operations",level:2},{value:"Composable Nested Assertions",id:"composable-nested-assertions",level:2},{value:"Fields",id:"fields",level:2},{value:"Assertion Lists",id:"assertion-lists",level:2},{value:"Any",id:"any",level:3},{value:"A",id:"a",level:3},{value:"Numeric",id:"numeric",level:3},{value:"Ordering",id:"ordering",level:3},{value:"Iterable",id:"iterable",level:3},{value:"Ordering",id:"ordering-1",level:3},{value:"Seq",id:"seq",level:3},{value:"Either",id:"either",level:3},{value:"Exit/Cause/Throwable",id:"exitcausethrowable",level:3},{value:"Try",id:"try",level:3},{value:"Sum type",id:"sum-type",level:3},{value:"Map",id:"map",level:3},{value:"String",id:"string",level:3},{value:"Boolean",id:"boolean",level:3},{value:"Option",id:"option",level:3},{value:"Unit",id:"unit",level:3},{value:"How it works?",id:"how-it-works",level:2},{value:"The <code>test</code> Function",id:"the-test-function",level:3},{value:"The <code>assert</code> Function",id:"the-assert-function",level:3},{value:"The <code>Assertion</code> data type",id:"the-assertion-data-type",level:3}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Assertions are used to make sure that the assumptions on computations are exactly what we expect them to be. They are ",(0,r.kt)("em",{parentName:"p"},"executable checks")," for a property that must be true in our code. Also, they can be seen as a ",(0,r.kt)("em",{parentName:"p"},"specification of a program")," and facilitate understanding of programs."),(0,r.kt)("p",null,'Assume we have a function that concatenates two strings. One simple property of this function would be "the sum of the length of all inputs should be equal to the length of the output". Let\'s see an example of how we can make an assertion about this property:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("The sum of the lengths of both inputs must equal the length of the output") {\n  check(Gen.string, Gen.string) { (a, b) =>\n    assert((a + b).length)(Assertion.equalTo(a.length + b.length))\n  }\n}\n')),(0,r.kt)("p",null,"The syntax of assertion in the above code, is ",(0,r.kt)("inlineCode",{parentName:"p"},"assert(expression)(assertion)"),". The first section is an expression of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," which is ",(0,r.kt)("em",{parentName:"p"},"result")," of our computation and the second one is the expected assertion of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]"),"."),(0,r.kt)("h2",{id:"using-assertions-with-zio-tests"},"Using Assertions with ZIO Tests"),(0,r.kt)("p",null,"We have two methods for writing test assertions:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"assert"))," and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"assertZIO"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"assertTrue")))),(0,r.kt)("p",null,"The first one is the old way of asserting ordinary values and also ZIO effects. The second method, which is called ",(0,r.kt)("em",{parentName:"p"},"smart assertion"),", has a unified logic for testing both ordinary values and ZIO effects. ",(0,r.kt)("strong",{parentName:"p"},"We encourage developers to use the smart assertion method, which is much simpler.")),(0,r.kt)("h3",{id:"classic-old-fashioned-assertions"},"Classic Old-fashioned Assertions"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," and its effectful counterpart ",(0,r.kt)("inlineCode",{parentName:"p"},"assertZIO")," are the old way of asserting ordinary values and ZIO effects."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"In order to test ordinary values, we should use ",(0,r.kt)("inlineCode",{parentName:"li"},"assert"),", like the example below:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\n\ntest("sum") {\n  assert(1 + 1)(Assertion.equalTo(2))\n}\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"If we are testing an effect, we should use the ",(0,r.kt)("inlineCode",{parentName:"li"},"assertZIO")," function:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\n\ntest("updating ref") {\n  val value = for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield v\n  assertZIO(value)(Assertion.equalTo(1))\n}\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Having this all in mind, probably the most common and also most readable way of structuring tests is to pass a for-comprehension to ",(0,r.kt)("inlineCode",{parentName:"li"},"test")," function and yield a call to ",(0,r.kt)("inlineCode",{parentName:"li"},"assert")," function.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\n\ntest("updating ref") {\n  for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield assert(v)(Assertion.equalTo(v))\n}\n')),(0,r.kt)("h3",{id:"smart-assertions"},"Smart Assertions"),(0,r.kt)("p",null,"The smart assertion is a simpler way to assert both ordinary values and effectful values. It uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"assertTrue")," function, which uses macro under the hood."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Testing ordinary values:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\n\ntest("sum"){\n  assertTrue(1 + 1 == 2)\n}\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Testing effectful values:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\n\ntest("updating ref") {\n  for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield assertTrue(v == 1)\n}\n')),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"assertTrue")," with for-comprehension style, we can think of testing as these three steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Setup the test")," \u2014 In this section we should setup the system under test (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"Ref.make(0)"),")."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Running the test")," \u2014 Then we run the test scenario according to the test specification. (e.g ",(0,r.kt)("inlineCode",{parentName:"li"},"ref.update(_ + 1)"),")"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Making assertions about the test")," - Finally, we should assert the result with the right expectations (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"assertTrue(v == 1)"),")")),(0,r.kt)("h2",{id:"logical-operations"},"Logical Operations"),(0,r.kt)("p",null,"What is really useful in assertions is that they behave like boolean values and can be composed with operators known from operating on boolean values like and (",(0,r.kt)("inlineCode",{parentName:"p"},"&&"),"), or (",(0,r.kt)("inlineCode",{parentName:"p"},"||"),"), negation (",(0,r.kt)("inlineCode",{parentName:"p"},"negate"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion\n\nval assertionForString: Assertion[String] = \n  Assertion.containsString("Foo") && Assertion.endsWithString("Bar")\n')),(0,r.kt)("h2",{id:"composable-nested-assertions"},"Composable Nested Assertions"),(0,r.kt)("p",null,"Assertions also compose with each other allowing for doing rich diffs not only simple value to value comparison:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.Assertion.{isRight, isSome, equalTo, hasField}\n\ntest("Check assertions") {\n  assert(Right(Some(2)))(isRight(isSome(equalTo(2))))\n}\n')),(0,r.kt)("p",null,"Here we're checking deeply nested values inside an ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Option"),". Because ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion"),"s compose this is not a problem. All layers are being peeled off tested for the condition until the final value is reached."),(0,r.kt)("p",null,"Here the expression ",(0,r.kt)("inlineCode",{parentName:"p"},"Right(Some(2))")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Either[Any, Option[Int]]")," and our assertion ",(0,r.kt)("inlineCode",{parentName:"p"},"isRight(isSome(equalTo(2)))")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[Either[Any, Option[Int]]]")),(0,r.kt)("h2",{id:"fields"},"Fields"),(0,r.kt)("p",null,"There is also an easy way to test an object's data for certain assertions with ",(0,r.kt)("inlineCode",{parentName:"p"},"hasField")," which accepts besides a name, a mapping function from object to its tested property, and ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion")," object which will validate this property. Here our test checks if a person has at least 18 years and is not from the USA."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.Assertion.{isRight, isSome,equalTo, isGreaterThanEqualTo, not, hasField}\n\nfinal case class Address(country:String, city:String)\nfinal case class User(name:String, age:Int, address: Address)\n\ntest("Rich checking") {\n  assert(\n    User("Jonny", 26, Address("Denmark", "Copenhagen"))\n  )(\n    hasField("age", (u:User) => u.age, isGreaterThanEqualTo(18)) &&\n    hasField("country", (u:User) => u.address.country, not(equalTo("USA")))\n  )\n}\n')),(0,r.kt)("p",null,"What is nice about those tests is that test reporters will tell you exactly which assertion was broken. Let's say we would change ",(0,r.kt)("inlineCode",{parentName:"p"},"isGreaterThanEqualTo(18)")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"isGreaterThanEqualTo(40)")," which will fail. Print out on the console will be a nice detailed text explaining what exactly went wrong:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'[info]       User(Jonny,26,Address(Denmark,Copenhagen)) did not satisfy (hasField("age", _.age, isGreaterThanEqualTo(45)) && hasField("country", _.country, not(equalTo(USA))))\n[info]       26 did not satisfy isGreaterThanEqualTo(45)\n')),(0,r.kt)("h2",{id:"assertion-lists"},"Assertion Lists"),(0,r.kt)("p",null,"To create ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]")," object one can use functions defined under ",(0,r.kt)("inlineCode",{parentName:"p"},"zio.test.Assertion"),". There are already a number of useful assertions predefined like ",(0,r.kt)("inlineCode",{parentName:"p"},"equalTo"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"isFalse"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"isTrue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"contains"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"throws")," and more."),(0,r.kt)("p",null,"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion")," type effectively often involves finding the best fitting function for the type of assumptions you would like to verify."),(0,r.kt)("p",null,"This list is intended to break up the available functions into groups based on the ",(0,r.kt)("em",{parentName:"p"},"Result type"),". The types of the functions are included as well, to guide intuition."),(0,r.kt)("p",null,"For instance, if we wanted to assert that the fourth element of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector[Int]")," was a value equal to the number ",(0,r.kt)("inlineCode",{parentName:"p"},"5"),", we would first look at assertions that operate on ",(0,r.kt)("inlineCode",{parentName:"p"},"Seq[A]"),", with the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[Seq[A]]"),". For this example, I would select ",(0,r.kt)("inlineCode",{parentName:"p"},"hasAt"),", as it accepts both the position into a sequence, as well as an ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]")," to apply at that position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"Assertion.hasAt[A](pos: Int)(assertion: Assertion[A]): Assertion[Seq[A]]\n")),(0,r.kt)("p",null,"I could start by writing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.Assertion._\n\nval xs = Vector(0, 1, 2, 3)\n\ntest("Fourth value is equal to 5") {\n  assert(xs)(hasAt(3)(???))\n}\n')),(0,r.kt)("p",null,"The second parameter to ",(0,r.kt)("inlineCode",{parentName:"p"},"hasAt")," is an ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]")," that applies to the third element of that sequence, so I would look for functions that operate on ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", of the return type ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]"),"."),(0,r.kt)("p",null,"I could select ",(0,r.kt)("inlineCode",{parentName:"p"},"equalTo"),", as it accepts an ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," as a parameter, allowing me to supply ",(0,r.kt)("inlineCode",{parentName:"p"},"5"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.Assertion._\n\nval xs = Vector(0, 1, 2, 3)\n\ntest("Fourth value is equal to 5") {\n  assert(xs)(hasAt(3)(equalTo(5)))\n}\n')),(0,r.kt)("p",null,"Let's say this is too restrictive, and I would prefer to assert that a value is ",(0,r.kt)("em",{parentName:"p"},"near")," the number five, with a tolerance of two. This requires a little more knowledge of the type ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", so I'll look for an assertion in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Numeric")," section. ",(0,r.kt)("inlineCode",{parentName:"p"},"approximatelyEquals")," looks like what we want, as it permits the starting value ",(0,r.kt)("inlineCode",{parentName:"p"},"reference"),", as well as a ",(0,r.kt)("inlineCode",{parentName:"p"},"tolerance"),", for any ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," that is ",(0,r.kt)("inlineCode",{parentName:"p"},"Numeric"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"Assertion.approximatelyEquals[A: Numeric](reference: A, tolerance: A): Assertion[A]\n")),(0,r.kt)("p",null,"Changing out ",(0,r.kt)("inlineCode",{parentName:"p"},"equalTo")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"approximatelyEquals")," leaves us with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.Assertion._\n\nval xs = Vector(0, 1, 2, 3)\n\ntest("Fourth value is approximately equal to 5") {\n  assert(xs)(hasAt(3)(approximatelyEquals(5, 2)))\n}\n')),(0,r.kt)("h3",{id:"any"},"Any"),(0,r.kt)("p",null,"Assertions that apply to ",(0,r.kt)("inlineCode",{parentName:"p"},"Any")," value."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"anything")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Any]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that always succeeds.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isNull")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Any]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a null value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isSubtype[A](assertion: Assertion[A])(implicit C: ClassTag[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Any]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a value have the specified type.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"nothing")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Any]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that always fails.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"throwsA[E: ClassTag]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Any]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the expression to throw.")))),(0,r.kt)("h3",{id:"a"},"A"),(0,r.kt)("p",null,"Assertions that apply to specific values."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"equalTo[A](expected: A)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a value equal the specified value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasField[A, B](name: String, proj: A => B, assertion: Assertion[B])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that focuses in on a field in a case class.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isOneOf[A](values: Iterable[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a value to be equal to one of the specified values.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"not[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that negates the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"throws[A](assertion: Assertion[Throwable])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the expression to throw.")))),(0,r.kt)("h3",{id:"numeric"},"Numeric"),(0,r.kt)("p",null,"Assertions on ",(0,r.kt)("inlineCode",{parentName:"p"},"Numeric")," types"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"approximatelyEquals[A: Numeric](reference: A, tolerance: A)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given numeric value to match a value with some tolerance.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isNegative[A](implicit num: Numeric[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a numeric value is negative.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isPositive[A](implicit num: Numeric[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a numeric value is positive.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isZero[A](implicit num: Numeric[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a numeric value is zero.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"nonNegative[A](implicit num: Numeric[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a numeric value is non negative.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"nonPositive[A](implicit num: Numeric[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a numeric value is non positive.")))),(0,r.kt)("h3",{id:"ordering"},"Ordering"),(0,r.kt)("p",null,"Assertions on types that support ",(0,r.kt)("inlineCode",{parentName:"p"},"Ordering")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isGreaterThan[A](reference: A)(implicit ord: Ordering[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the value be greater than the specified reference value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isGreaterThanEqualTo[A](reference: A)(implicit ord: Ordering[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the value be greater than or equal to the specified reference value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isLessThan[A](reference: A)(implicit ord: Ordering[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the value be less than the specified reference value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isLessThanEqualTo[A](reference: A)(implicit ord: Ordering[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the value be less than or equal to the specified reference value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isWithin[A](min: A, max: A)(implicit ord: Ordering[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[A]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a value to fall within a specified min and max (inclusive).")))),(0,r.kt)("h3",{id:"iterable"},"Iterable"),(0,r.kt)("p",null,"Assertions on types that extend ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable"),", like ",(0,r.kt)("inlineCode",{parentName:"p"},"List"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Seq"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Set"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),", and many others."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contains[A](element: A)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable contain the specified element. See Assertion.exists if you want to require an Iterable to contain an element satisfying an assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"exists[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable contain an element satisfying the given assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"forall[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable contain only elements satisfying the given assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasFirst[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable to contain the first element satisfying the given assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasIntersection[A](other: Iterable[A])(assertion: Assertion[Iterable[A]])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the intersection of two Iterables satisfy the given assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasLast[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable to contain the last element satisfying the given assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasSize[A](assertion: Assertion[Int])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the size of an Iterable be satisfied by the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasAtLeastOneOf[A](other: Iterable[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable contain at least one of the specified elements.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasAtMostOneOf[A](other: Iterable[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable contain at most one of the specified elements.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasNoneOf[A](other: Iterable[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable contain none of the specified elements.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasOneOf[A](other: Iterable[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable contain exactly one of the specified elements.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasSameElements[A](other: Iterable[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable to have the same elements as the specified Iterable, though not necessarily in the same order.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasSameElementsDistinct[A](other: Iterable[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable to have the same distinct elements as the other Iterable, though not necessarily in the same order.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasSubset[A](other: Iterable[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the specified Iterable to be a subset of the other Iterable.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isDistinct")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable is distinct.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isEmpty")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable to be empty.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isNonEmpty")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable to be non empty.")))),(0,r.kt)("h3",{id:"ordering-1"},"Ordering"),(0,r.kt)("p",null,"Assertions that apply to ordered ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable"),"s"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isSorted[A](implicit ord: Ordering[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable is sorted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isSortedReverse[A](implicit ord: Ordering[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Iterable[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Iterable is sorted in reverse order.")))),(0,r.kt)("h3",{id:"seq"},"Seq"),(0,r.kt)("p",null,"Assertions that operate on sequences (",(0,r.kt)("inlineCode",{parentName:"p"},"List"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),", and many others)"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"endsWith[A](suffix: Seq[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Seq[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given string to end with the specified suffix.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasAt[A](pos: Int)(assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Seq[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a sequence to contain an element satisfying the given assertion on the given position.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"startsWith[A](prefix: Seq[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Seq[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given sequence to start with the specified prefix.")))),(0,r.kt)("h3",{id:"either"},"Either"),(0,r.kt)("p",null,"Assertions for ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," values."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isLeft[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Either[A, Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Left value satisfying a specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isLeft")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Either[Any, Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Either is Left.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isRight[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Either[Any, A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Right value satisfying a specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isRight")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Either[Any, Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Either is Right.")))),(0,r.kt)("h3",{id:"exitcausethrowable"},"Exit/Cause/Throwable"),(0,r.kt)("p",null,"Assertions for ",(0,r.kt)("inlineCode",{parentName:"p"},"Exit")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Cause")," results."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"containsCause[E](cause: Cause[E])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Cause[E]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Cause contain the specified cause.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"dies(assertion: Assertion[Throwable])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Exit[Any, Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an exit value to die.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"failsCause[E](assertion: Assertion[Cause[E]])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Exit[E, Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an exit value to fail with a cause that meets the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fails[E](assertion: Assertion[E])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Exit[E, Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an exit value to fail.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isInterrupted")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Exit[Any, Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an exit value to be interrupted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"succeeds[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Exit[Any, A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an exit value to succeed.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasMessage(message: Assertion[String])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Throwable]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an exception to have a certain message.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasThrowableCause(cause: Assertion[Throwable])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Throwable]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an exception to have a certain cause.")))),(0,r.kt)("h3",{id:"try"},"Try"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isFailure(assertion: Assertion[Throwable])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Try[Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Failure value satisfying the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isFailure")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Try[Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Try value is Failure.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isSuccess[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Try[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Success value satisfying the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isSuccess")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Try[Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Try value is Success.")))),(0,r.kt)("h3",{id:"sum-type"},"Sum type"),(0,r.kt)("p",null,"An assertion that applies to some type, giving a method to transform the source\ntype into another type, then assert a property on that projected type."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isCase[Sum, Proj]( termName: String, term: Sum => Option[Proj], assertion: Assertion[Proj])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Sum]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the sum type be a specified term.")))),(0,r.kt)("h3",{id:"map"},"Map"),(0,r.kt)("p",null,"Assertions for ",(0,r.kt)("inlineCode",{parentName:"p"},"Map[K, V]")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasKey[K, V](key: K)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Map[K, V]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Map to have the specified key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasKey[K, V](key: K, assertion: Assertion[V])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Map[K, V]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Map to have the specified key with value satisfying the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasKeys[K, V](assertion: Assertion[Iterable[K]])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Map[K, V]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Map have keys satisfying the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasValues[K, V](assertion: Assertion[Iterable[V]])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Map[K, V]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Map have values satisfying the specified assertion.")))),(0,r.kt)("h3",{id:"string"},"String"),(0,r.kt)("p",null,"Assertions for Strings"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"containsString(element: String)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[String]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a substring to be present.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"endsWithString(suffix: String)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[String]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given string to end with the specified suffix.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"equalsIgnoreCase(other: String)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[String]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given string to equal another ignoring case.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hasSizeString(assertion: Assertion[Int])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[String]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the size of a string be satisfied by the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isEmptyString")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[String]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given string to be empty.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isNonEmptyString")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[String]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given string to be non empty.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"matchesRegex(regex: String)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[String]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given string to match the specified regular expression.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"startsWithString(prefix: String)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[String]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a given string to start with a specified prefix.")))),(0,r.kt)("h3",{id:"boolean"},"Boolean"),(0,r.kt)("p",null,"Assertions for Booleans"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isFalse")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Boolean]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a value be false.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isTrue")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Boolean]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a value be true.")))),(0,r.kt)("h3",{id:"option"},"Option"),(0,r.kt)("p",null,"Assertions for Optional values"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isNone")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Option[Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a None value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isSome[A](assertion: Assertion[A])")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Option[A]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires a Some value satisfying the specified assertion.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isSome")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Option[Any]]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires an Option is Some.")))),(0,r.kt)("h3",{id:"unit"},"Unit"),(0,r.kt)("p",null,"Assertion for Unit"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function"),(0,r.kt)("th",{parentName:"tr",align:null},"Result type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"isUnit")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assertion[Unit]")),(0,r.kt)("td",{parentName:"tr",align:null},"Makes a new assertion that requires the value be unit.")))),(0,r.kt)("h2",{id:"how-it-works"},"How it works?"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Note:"))),(0,r.kt)("p",{parentName:"blockquote"},"In this section we are going to learn about the internals of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion")," data type. So feel free to skip this section if you are not interested.")),(0,r.kt)("h3",{id:"the-test-function"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"test")," Function"),(0,r.kt)("p",null,"In order to understand the ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion")," data type, let's first look at the ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def test[In](label: String)(assertion: => In)(implicit testConstructor: TestConstructor[Nothing, In]): testConstructor.Out\n")),(0,r.kt)("p",null,"Its signature is a bit complicated and uses ",(0,r.kt)("em",{parentName:"p"},"path dependent types"),", but it doesn't matter. We can think of a ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," as a function from ",(0,r.kt)("inlineCode",{parentName:"p"},"TestResult")," (or its effectful versions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO[R, E, TestResult]")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ZSTM[R, E, TestResult]"),") to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Spec[R, E]")," data type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def test(label: String)(assertion: => TestResult): Spec[Any, Nothing]\ndef test(label: String)(assertion: => ZIO[R, E, TestResult]): Spec[R, E]\n")),(0,r.kt)("p",null,"Therefore, the function ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," needs a ",(0,r.kt)("inlineCode",{parentName:"p"},"TestResult"),". The most common way to produce a ",(0,r.kt)("inlineCode",{parentName:"p"},"TestResult")," is to resort to ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," or its effectful counterpart ",(0,r.kt)("inlineCode",{parentName:"p"},"assertZIO"),". The former one is for creating ordinary ",(0,r.kt)("inlineCode",{parentName:"p"},"TestResult")," values and the latter one is for producing effectful ",(0,r.kt)("inlineCode",{parentName:"p"},"TestResult")," values. Both of them accept a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," (effectful version wrapped in a ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO"),") and an ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]"),"."),(0,r.kt)("h3",{id:"the-assert-function"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"assert")," Function"),(0,r.kt)("p",null,"Let's look at the ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def assert[A](expr: => A)(assertion: Assertion[A]): TestResult\n")),(0,r.kt)("p",null,"It takes an expression of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," and an ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]")," and returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"TestResult")," which is the boolean algebra of the ",(0,r.kt)("inlineCode",{parentName:"p"},"AssertionResult"),". Furthermore, we have an ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]")," which is capable of producing ",(0,r.kt)("em",{parentName:"p"},"assertion results")," on any value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),". So the ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," function can apply the expression to the assertion and produce the ",(0,r.kt)("inlineCode",{parentName:"p"},"TestResult"),"."),(0,r.kt)("h3",{id:"the-assertion-data-type"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"Assertion")," data type"),(0,r.kt)("p",null,"We can think of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Assertion[A]")," as a function of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A => Boolean"),"."),(0,r.kt)("p",null,"As a proposition, assertions compose using logical conjunction and disjunction and can be negated:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.test._\n\nval greaterThanZero: Assertion[Int] = Assertion.isPositive\nval lessThanFive   : Assertion[Int] = Assertion.isLessThan(5)\nval equalTo10      : Assertion[Int] = Assertion.equalTo(10)\n\nval assertion: Assertion[Int] = greaterThanZero && lessThanFive || equalTo10.negate\n")),(0,r.kt)("p",null,"After composing them, we can run it on any expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: TestResult = assertion.run(10)\n// result: TestResult = TestResult(\n//   arrow = Meta(\n//     arrow = AndThen(\n//       f = Meta(\n//         arrow = TestArrowF(\n//           f = zio.test.TestArrow$$$Lambda$12058/64590789@66417a0e\n//         ),\n//         span = None,\n//         parentSpan = None,\n//         code = Some(value = "input"),\n//         location = None,\n//         completeCode = None,\n//         customLabel = None,\n//         genFailureDetails = None\n//       ),\n//       g = Or(\n//         left = And(\n//           left = Meta(\n//             arrow = TestArrowF(\n//               f = zio.test.TestArrow$$$Lambda$12036/1168566735@1f874d4\n//             ),\n//             span = None,\n//             parentSpan = None,\n//             code = Some(value = "isPositive"),\n//             location = None,\n//             completeCode = None,\n//             customLabel = None,\n//             genFailureDetails = None\n//           ),\n//           right = Meta(\n//             arrow = TestArrowF(\n//               f = zio.test.TestArrow$$$Lambda$12036/1168566735@349eecc\n//             ),\n//             span = None,\n//             parentSpan = None,\n//             code = Some(value = "isLessThan"),\n//             location = None,\n//             completeCode = None,\n//             customLabel = None,\n//             genFailureDetails = None\n//           )\n//         ),\n//         right = Not(\n//           arrow = Meta(\n//             arrow = TestArrowF(\n//               f = zio.test.TestArrow$$$Lambda$12036/1168566735@7419fbd6\n//             ),\n//             span = None,\n//             parentSpan = None,\n// ...\n')))}m.isMDXComponent=!0}}]);