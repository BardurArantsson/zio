"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[8816],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8097:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={id:"error-management",title:"Error Management"},o=void 0,l={unversionedId:"references/core/zio/error-management",id:"references/core/zio/error-management",title:"Error Management",description:"As well as providing first-class support for typed errors, ZIO has a variety of facilities for catching, propagating, and transforming errors in a typesafe manner. In this section, we will learn about different types of errors in ZIO and how we can manage them.",source:"@site/docs/references/core/zio/error-management.md",sourceDirName:"references/core/zio",slug:"/references/core/zio/error-management",permalink:"/references/core/zio/error-management",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/references/core/zio/error-management.md",tags:[],version:"current",frontMatter:{id:"error-management",title:"Error Management"},sidebar:"references-sidebar",previous:{title:"ZIO",permalink:"/references/core/zio/"},next:{title:"UIO",permalink:"/references/core/zio/uio"}},s={},p=[{value:"Three Types of Errors in ZIO",id:"three-types-of-errors-in-zio",level:2},{value:"1. Failures",id:"1-failures",level:3},{value:"2. Defects",id:"2-defects",level:3},{value:"3. Fatal Errors",id:"3-fatal-errors",level:3},{value:"Imperative vs. Functional Error Handling",id:"imperative-vs-functional-error-handling",level:2},{value:"Expected and Unexpected Errors",id:"expected-and-unexpected-errors",level:2},{value:"Exceptional and Unexceptional Effects",id:"exceptional-and-unexceptional-effects",level:2},{value:"Typed Errors Don&#39;t Guarantee the Absence of Defects and Interruptions",id:"typed-errors-dont-guarantee-the-absence-of-defects-and-interruptions",level:2},{value:"Sequential and Parallel Errors",id:"sequential-and-parallel-errors",level:2},{value:"Recovering From Errors",id:"recovering-from-errors",level:2},{value:"1. Catching",id:"1-catching",level:3},{value:"Catching Failures",id:"catching-failures",level:4},{value:"Catching Defects",id:"catching-defects",level:4},{value:"Catching Causes",id:"catching-causes",level:4},{value:"Catching Traces",id:"catching-traces",level:4},{value:"Catching Non-Fatal",id:"catching-non-fatal",level:4},{value:"2. Fallback",id:"2-fallback",level:3},{value:"3. Folding",id:"3-folding",level:3},{value:"4. Retrying",id:"4-retrying",level:3},{value:"5. Timing out",id:"5-timing-out",level:3},{value:"6. Sandboxing",id:"6-sandboxing",level:3},{value:"Error Accumulation",id:"error-accumulation",level:2},{value:"<code>ZIO#validate</code>",id:"ziovalidate",level:3},{value:"<code>ZIO.validate</code>",id:"ziovalidate-1",level:3},{value:"<code>ZIO.validateFirst</code>",id:"ziovalidatefirst",level:3},{value:"<code>ZIO.partition</code>",id:"ziopartition",level:3},{value:"Error Channel Operations",id:"error-channel-operations",level:2},{value:"Map and FlatMap on the Error Channel",id:"map-and-flatmap-on-the-error-channel",level:3},{value:"Filtering the Success Channel Values",id:"filtering-the-success-channel-values",level:3},{value:"Tapping Errors",id:"tapping-errors",level:3},{value:"Putting Errors Into Success Channel and Submerging Them Back Again",id:"putting-errors-into-success-channel-and-submerging-them-back-again",level:3},{value:"Converting Defects to Failures",id:"converting-defects-to-failures",level:3},{value:"Error Refinement",id:"error-refinement",level:3},{value:"Refining",id:"refining",level:4},{value:"Unrefining",id:"unrefining",level:4},{value:"Converting Option on Values to Option on Errors and Vice Versa",id:"converting-option-on-values-to-option-on-errors-and-vice-versa",level:3},{value:"Flattening Optional Error Types",id:"flattening-optional-error-types",level:3},{value:"Merging the Error Channel into the Success Channel",id:"merging-the-error-channel-into-the-success-channel",level:3},{value:"Flipping the Error and Success Channels",id:"flipping-the-error-and-success-channels",level:3},{value:"Rejecting Some Success Values",id:"rejecting-some-success-values",level:3},{value:"Zoom in/out on Left or Right Side of An Either Value",id:"zoom-inout-on-left-or-right-side-of-an-either-value",level:3},{value:"Converting Optional Values to Optional Errors and Vice Versa",id:"converting-optional-values-to-optional-errors-and-vice-versa",level:3},{value:"Uncovering the Underlying Cause of an Effect",id:"uncovering-the-underlying-cause-of-an-effect",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Model Domain Errors Using Algebraic Data Types",id:"model-domain-errors-using-algebraic-data-types",level:3},{value:"Use Union Types to Be More Specific About Error Types",id:"use-union-types-to-be-more-specific-about-error-types",level:3},{value:"Don&#39;t Type Unexpected Errors",id:"dont-type-unexpected-errors",level:3},{value:"Don&#39;t Reflexively Log Errors",id:"dont-reflexively-log-errors",level:3},{value:"Debugging",id:"debugging",level:2},{value:"Logging",id:"logging",level:2},{value:"Examples",id:"examples",level:2}],c={toc:p};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"As well as providing first-class support for typed errors, ZIO has a variety of facilities for catching, propagating, and transforming errors in a typesafe manner. In this section, we will learn about different types of errors in ZIO and how we can manage them."),(0,r.kt)("h2",{id:"three-types-of-errors-in-zio"},"Three Types of Errors in ZIO"),(0,r.kt)("p",null,"We should consider three types of errors when writing ZIO applications:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Failures")," are expected errors. We use ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fail")," to model failures. As they are expected, we know how to handle them. We should handle these errors and prevent them from propagating throughout the call stack.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Defects")," are unexpected errors. We use ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.die")," to model a defect. As they are not expected, we need to propagate them through the application stack, until in the upper layers one of the following situations happens:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"In one of the upper layers, it makes sense to expect these errors. So we will convert them to failure, and then they can be handled."),(0,r.kt)("li",{parentName:"ul"},"None of the upper layers won't catch these errors, so it will finally crash the whole application."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Fatals")," are catastrophic unexpected errors. When they occur we should kill the application immediately without propagating the error furthermore. At most, we might need to log the error and print its call stack."))),(0,r.kt)("h3",{id:"1-failures"},"1. Failures"),(0,r.kt)("p",null,"When writing ZIO application, we can model a failure, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fail")," constructor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO {\n  def fail[E](error: => E): ZIO[Any, E, Nothing]\n}\n")),(0,r.kt)("p",null,"Let's try to model some failures using this constructor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval f1: ZIO[Any, String, Nothing] = ZIO.fail("Oh uh!")\nval f2: ZIO[Any, String, Int]     = ZIO.succeed(5) *> ZIO.fail("Oh uh!")\n')),(0,r.kt)("p",null,"Now, let's try to run a failing effect and see what happens:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.succeed(5) *> ZIO.fail("Oh uh!")\n}\n')),(0,r.kt)("p",null,"This will crash the application and print the following stack trace:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-03-08T17:55:50.002161369Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.String: Oh uh!\n    at <empty>.MainApp.run(MainApp.scala:4)"\n')),(0,r.kt)("p",null,"We can also model a failure using ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'val f2: ZIO[Any, Exception, Nothing] =\n  ZIO.fail(new Exception("Oh uh!"))\n')),(0,r.kt)("p",null,"Or using user-defined failure types (domain errors):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'case class NegativeNumberException(msg: String) extends Exception(msg)\n\nval validateNonNegaive(input: Int): ZIO[Any, NegativeNumberException, Int] =\n  if (input < 0)\n    ZIO.fail(NegativeNumberException(s"entered negative number: $input"))\n  else\n    ZIO.succeed(input)\n')),(0,r.kt)("p",null,"In the above examples, we can see that the type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"validateNonNegaive")," function is ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO[Any, NegativeNumberException, Int]"),". It means this is an exceptional effect, which may fail with the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"NegativeNumberException"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fail")," constructor is somehow the moral equivalent of ",(0,r.kt)("inlineCode",{parentName:"p"},"throw")," for pure codes. We will discuss this ",(0,r.kt)("a",{parentName:"p",href:"#imperative-vs-functional-error-handling"},"further"),"."),(0,r.kt)("h3",{id:"2-defects"},"2. Defects"),(0,r.kt)("p",null,"By providing a ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," value to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.die")," constructor, we can describe a dying effect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object ZIO {\n  def die(t: => Throwable): ZIO[Any, Nothing, Nothing]\n}\n")),(0,r.kt)("p",null,"Here is an example of such effect, which will die because of encountering ",(0,r.kt)("em",{parentName:"p"},"divide by zero")," defect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval dyingEffect: ZIO[Any, Nothing, Nothing] =\n  ZIO.die(new ArithmeticException("divide by zero"))\n')),(0,r.kt)("p",null,"The result is the creation of a ZIO effect whose error channel and success channel are both ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),". In other words, this effect cannot fail and does not produce anything. Instead, it is an effect describing a ",(0,r.kt)("em",{parentName:"p"},"defect")," or an ",(0,r.kt)("em",{parentName:"p"},"unexpected error"),"."),(0,r.kt)("p",null,"Let's see what happens if we run this effect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.die(new ArithmeticException("divide by zero"))\n}\n')),(0,r.kt)("p",null,"If we run this effect, ZIO runtime will print the stack trace that belongs to this defect. So, here is the output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-02-16T13:02:44.057191215Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.ArithmeticException: divide by zero\n    at MainApp$.$anonfun$run$1(MainApp.scala:4)\n    at zio.ZIO$.$anonfun$die$1(ZIO.scala:3384)\n    at zio.internal.FiberContext.runUntil(FiberContext.scala:255)\n    at zio.internal.FiberContext.run(FiberContext.scala:115)\n    at zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\n    at <empty>.MainApp.run(MainApp.scala:4)"\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.die")," constructor is used to manually describe a dying effect because of a defect inside the code."),(0,r.kt)("p",null,"For example, assume we want to write a ",(0,r.kt)("inlineCode",{parentName:"p"},"divide")," function that takes two numbers and divides the first number by the second. We know that the ",(0,r.kt)("inlineCode",{parentName:"p"},"divide")," function is not defined for zero dominators. Therefore, we should signal an error if division by zero occurs."),(0,r.kt)("p",null,"We have two choices to implement this function using the ZIO effect:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"We can divide the first number by the second, and if the second number was zero, we can fail the effect using ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.fail")," with the ",(0,r.kt)("inlineCode",{parentName:"li"},"ArithmeticException")," failure value:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, ArithmeticException, Int] =\n  if (b == 0)\n    ZIO.fail(new ArithmeticException("divide by zero"))\n  else\n    ZIO.succeed(a / b)\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"We can divide the first number by the second. In the case of zero for the second number, we use ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.die")," to kill the effect by sending a signal of ",(0,r.kt)("inlineCode",{parentName:"li"},"ArithmeticException")," as a defect:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\n  if (b == 0)\n    ZIO.die(new ArithmeticException("divide by zero")) // Unexpected error\n  else\n    ZIO.succeed(a / b)\n')),(0,r.kt)("p",null,"So what is the difference between these two approaches? Let's compare the function signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def divide(a: Int, b: Int): ZIO[Any, ArithmeticException, Int]   // using ZIO.fail\ndef divide(a: Int, b: Int): ZIO[Any, Nothing,             Int]   // using ZIO.die\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The first approach, models the ",(0,r.kt)("em",{parentName:"li"},"divide by zero")," error by ",(0,r.kt)("em",{parentName:"li"},"failing")," the effect. We call these failures ",(0,r.kt)("em",{parentName:"li"},"expected errors")," or ",(0,r.kt)("em",{parentName:"li"},"typed error"),"."),(0,r.kt)("li",{parentName:"ol"},"While the second approach models the ",(0,r.kt)("em",{parentName:"li"},"divide by zero")," error by ",(0,r.kt)("em",{parentName:"li"},"dying")," the effect. We call these kinds of errors ",(0,r.kt)("em",{parentName:"li"},"unexpected errors"),", ",(0,r.kt)("em",{parentName:"li"},"defects")," or ",(0,r.kt)("em",{parentName:"li"},"untyped errors"),".")),(0,r.kt)("p",null,"We use the first method when we are handling errors as we expect them, and thus we know how to handle them. In contrast, the second method is used when we aren't expecting those errors in our domain, and we don't know how to handle them. Therefore, we use the ",(0,r.kt)("em",{parentName:"p"},"let it crash")," philosophy."),(0,r.kt)("p",null,"In the second approach, we can see that the ",(0,r.kt)("inlineCode",{parentName:"p"},"divide")," function indicates that it cannot fail because it's error channel is ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),". However, it doesn't mean that this function hasn't any defects. ZIO defects are not typed, so they cannot be seen in type parameters."),(0,r.kt)("p",null,"Note that to create an effect that will die, we shouldn't throw an exception inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.die")," constructor, although it works. Instead, the idiomatic way of creating a dying effect is to provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," value into the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.die")," constructor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval defect1 = ZIO.die(new ArithmeticException("divide by zero"))       // recommended       // recommended\nval defect2 = ZIO.die(throw new ArithmeticException("divide by zero")) // not recommended\n')),(0,r.kt)("p",null,"Also, if we import a code that may throw an exception, all the exceptions will be translated to the ZIO defect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval defect3 = ZIO.succeed(throw new Exception("boom!"))\n')),(0,r.kt)("p",null,"Therefore, in the second approach of the ",(0,r.kt)("inlineCode",{parentName:"p"},"divide")," function, we do not require to manually die the effect in case of the ",(0,r.kt)("em",{parentName:"p"},"dividing by zero"),", because the JVM itself throws an ",(0,r.kt)("inlineCode",{parentName:"p"},"ArithmeticException")," when the denominator is zero."),(0,r.kt)("p",null,"When we import any code into the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," effect, any exception is thrown inside that code will be translated to ",(0,r.kt)("em",{parentName:"p"},"ZIO defects")," by default. So the following program is the same as the previous example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\n  ZIO.succeed(a / b)\n")),(0,r.kt)("p",null,"Another important note is that if we ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"flatMap")," a ZIO effect and then accidentally throw an exception inside the map operation, that exception will be translated to a ZIO defect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval defect4 = ZIO.succeed(???).map(_ => throw new Exception("Boom!"))\nval defect5 = ZIO.attempt(???).map(_ => throw new Exception("Boom!"))\n')),(0,r.kt)("h3",{id:"3-fatal-errors"},"3. Fatal Errors"),(0,r.kt)("p",null,"In ZIO on the JVM platform, the ",(0,r.kt)("inlineCode",{parentName:"p"},"VirtualMachineError")," and all its subtypes are the only errors considered fatal by the ZIO runtime. So if during the running application, the JVM throws any of these errors like ",(0,r.kt)("inlineCode",{parentName:"p"},"StackOverflowError"),", the ZIO runtime considers it as a catastrophic fatal error. So it will interrupt the whole application immediately without safe resource interruption. None of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAll")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAllDefects")," can catch these fatal errors. At most, if we set the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runtime.setReportFatal"),", the application will log the stack trace before interrupting the whole application."),(0,r.kt)("p",null,"Here is an example of manually creating a fatal error. Although we are ignoring all expected and unexpected errors, the fatal error interrupts the whole application:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    ZIO\n      .attempt(\n        throw new StackOverflowError(\n          "The call stack pointer exceeds the stack bound."\n        )\n      )\n      .catchAll(_ => ZIO.unit)       // ignoring all expected errors\n      .catchAllDefect(_ => ZIO.unit) // ignoring all unexpected errors\n}\n')),(0,r.kt)("p",null,"The output will be something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"java.lang.StackOverflowError: The call stack pointer exceeds the stack bound.\nat zio.examples.MainApp$.$anonfun$run$1(MainApp.scala:10)\nat zio.ZIO$.liftedTree1$1(ZIO.scala:2603)\nat zio.ZIO$.$anonfun$attempt$1(ZIO.scala:2603)\nat zio.ZIO$.$anonfun$isFatalWith$1(ZIO.scala:3571)\nat zio.internal.FiberContext.runUntil(FiberContext.scala:410)\nat zio.internal.FiberContext.run(FiberContext.scala:111)\nat zio.Runtime.unsafeRunWithRefs(Runtime.scala:400)\n  ...\n**** WARNING ****\nCatastrophic error encountered. Application not safely interrupted. Resources may be leaked. Check the logs for more details and consider overriding `Runtime.reportFatal` to capture context.\n")),(0,r.kt)("p",null,"Note that we can change the default way to report fatal errors using ",(0,r.kt)("inlineCode",{parentName:"p"},"Runtime#reportFatal")," or the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runtime.setReportFatal")," layer."),(0,r.kt)("h2",{id:"imperative-vs-functional-error-handling"},"Imperative vs. Functional Error Handling"),(0,r.kt)("p",null,"When practicing imperative programming in Scala, we have the ",(0,r.kt)("inlineCode",{parentName:"p"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," language construct for handling errors. Using them, we can wrap regions that may throw exceptions, and handle them in the catch block."),(0,r.kt)("p",null,"Let's try an example. In the following code we have an age validation function that may throw two exceptions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): Int = {\n  if (age < 0)\n    throw NegativeAgeException(age)\n  else if (age < 18)\n    throw IllegalAgeException(age)\n  else age\n}\n")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," we can handle exceptions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"try {\n  validate(17)\n} catch {\n  case NegativeAgeException(age) => ???\n  case IllegalAgeException(age) =>  ???\n}\n")),(0,r.kt)("p",null,"There are some issues with error handling using exceptions and ",(0,r.kt)("inlineCode",{parentName:"p"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"catch"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"finally")," statement:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"It lacks type safety on errors")," \u2014 There is no way to know what errors can be thrown by looking the function signature. The only way to find out in which circumstance a method may throw an exception is to read and investigate its implementation. So the compiler cannot prevent us from writing unsafe codes. It is also hard for a developer to read the documentation event through reading the documentation is not suffice as it may be obsolete, or it may don't reflect the exact exceptions.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] =\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n")),(0,r.kt)("p",null,"We can handle errors using ",(0,r.kt)("inlineCode",{parentName:"p"},"catchAll"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"catchSome")," methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"validate(17).catchAll {\n  case NegativeAgeException(age) => ???\n  case IllegalAgeException(age)  => ???\n}\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"It doesn't help us to write total functions")," \u2014 When we use ",(0,r.kt)("inlineCode",{parentName:"li"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"catch")," the compiler doesn't know about errors at compile-time, so if we forgot to handle one of the exceptions the compiler doesn't help us to write total functions. This code will crash at runtime because we forgot to handle the ",(0,r.kt)("inlineCode",{parentName:"li"},"IllegalAgeException")," case:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"try {\n  validate(17)\n} catch {\n  case NegativeAgeException(age) => ???\n  //  case IllegalAgeException(age) => ???\n}\n")),(0,r.kt)("p",null,"When we are using typed errors we can have exhaustive checking support of the compiler. For example, when we are catching all errors if we forgot to handle one of the cases, the compiler warns us about that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'validate(17).catchAll {\n  case NegativeAgeException(age) => ???\n}\n// res12: ZIO[Any, Nothing, Int] = OnSuccessAndFailure(\n//   trace = "repl.MdocSession.App10.res12(error-management.md:265)",\n//   first = OnSuccess(\n//     trace = "repl.MdocSession.App10.validate(error-management.md:245)",\n//     first = GenerateStackTrace(\n//       trace = "repl.MdocSession.App10.validate(error-management.md:245)"\n//     ),\n//     successK = zio.ZIO$$$Lambda$10834/339974451@4c761443\n//   ),\n//   successK = zio.ZIO$$Lambda$10890/432718699@3b38dcf5,\n//   failureK = zio.ZIO$$Lambda$10884/379004507@3686252b\n// )\n')),(0,r.kt)("p",null,"This helps us cover all cases and write ",(0,r.kt)("em",{parentName:"p"},"total functions")," easily."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")),(0,r.kt)("p",{parentName:"blockquote"},"When a function is defined for all possible input values, it is called a ",(0,r.kt)("em",{parentName:"p"},"total function")," in functional programming.")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Its error model is broken and lossy")," \u2014 The error model based on the ",(0,r.kt)("inlineCode",{parentName:"li"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"catch"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"finally")," statement is broken. Because if we have the combinations of these statements we can throw many exceptions, and then we are only able to catch one of them. All the other ones are lost. They are swallowed into a black hole, and also the one that we catch is the wrong one. It is not the primary cause of the failure.")),(0,r.kt)("p",null,"To be more specific, if the ",(0,r.kt)("inlineCode",{parentName:"p"},"try")," block throws an exception, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"finally")," block throws an exception as well, then, if these are caught at a higher level, only the finalizer's exception will be caught normally, not the exception from the try block."),(0,r.kt)("p",null,"In the following example, we are going to show this behavior:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},' try {\n    try throw new Error("e1")\n    finally throw new Error("e2")\n } catch {\n   case e: Error => println(e)\n }\n\n// Output:\n// e2\n')),(0,r.kt)("p",null,"The above program just prints the ",(0,r.kt)("inlineCode",{parentName:"p"},"e2")," while it is not the primary cause of failure. That is why we say the ",(0,r.kt)("inlineCode",{parentName:"p"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," model is lossy."),(0,r.kt)("p",null,"In ZIO, all the errors will still be reported. So even though we are only able to catch one error, the other ones will be reported which we have full control over them. They don't get lost."),(0,r.kt)("p",null,"Let's write a ZIO version:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.fail("e1")\n  .ensuring(ZIO.succeed(throw new Exception("e2")))\n  .catchAll {\n    case "e1" => Console.printLine("e1")\n    case "e2" => Console.printLine("e2")\n  }\n\n// Output:\n// e1\n')),(0,r.kt)("p",null,"ZIO guarantees that no errors are lost. It has a ",(0,r.kt)("em",{parentName:"p"},"lossless error model"),". This guarantee is provided via a hierarchy of supervisors and information made available via data types such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Exit")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Cause"),". All errors will be reported. If there's a bug in the code, ZIO enables us to find about it."),(0,r.kt)("h2",{id:"expected-and-unexpected-errors"},"Expected and Unexpected Errors"),(0,r.kt)("p",null,"Inside an application, there are two distinct categories of errors:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Expected Errors"),"\u2014 They are also known as ",(0,r.kt)("em",{parentName:"li"},"recoverable errors"),", ",(0,r.kt)("em",{parentName:"li"},"declared errors")," or ",(0,r.kt)("em",{parentName:"li"},"errors"),".")),(0,r.kt)("p",null,"Expected errors are those errors in which we expected them to happen in normal circumstances, and we can't prevent them. They can be predicted upfront, and we can plan for them. We know when, where, and why they occur. So we know when, where, and how to handle these errors. By handling them we can recover from the failure, this is why we say they are ",(0,r.kt)("em",{parentName:"p"},"recoverable errors"),". All domain errors, business errors are expected once because we talk about them in workflows and user stories, so we know about them in the context of business flows."),(0,r.kt)("p",null,"For example, when accessing an external database, that database might be down for some short period of time, so we retry to connect again, or after some number of attempts, we might decide to use an alternative solution, e.g. using an in-memory database."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Unexpected Errors"),"\u2014 ",(0,r.kt)("em",{parentName:"li"},"non-recoverable errors"),", ",(0,r.kt)("em",{parentName:"li"},"defects"),".")),(0,r.kt)("p",null,"We know there is a category of things that we are not going to expect and plan for. These are the things we don't expect but of course, we know they are going to happen. We don't know what is the exact root of these errors at runtime, so we have no idea how to handle them. They are actually going to bring down our production application, and then we have to figure out what went wrong to fix them."),(0,r.kt)("p",null,"For example, the corrupted database file will cause an unexpected error. We can't handle that in runtime. It may be necessary to shut down the whole application in order to prevent further damage."),(0,r.kt)("p",null,"Most of the unexpected errors are rooted in programming errors. This means, we have just tested the ",(0,r.kt)("em",{parentName:"p"},"happy path"),", so in case of ",(0,r.kt)("em",{parentName:"p"},"unhappy path")," we encounter a defect. When we have defects in our code we have no way of knowing about them otherwise we investigate, test, and fix them."),(0,r.kt)("p",null,"One of the common programming errors is forgetting to validate unexpected errors that may occur when we expect an input but the input is not valid, while we haven't validated the input. When the user inputs the invalid data, we might encounter the divide by zero exception or might corrupt our service state or a cause similar defect. These kinds of defects are common when we upgrade our service with the new data model for its input, while one of the other services is not upgraded with the new data contract and is calling our service with the deprecated data model. If we haven't a validation phase, they will cause defects!"),(0,r.kt)("p",null,"Another example of defects is memory errors like buffer overflows, stack overflows, out-of-memory, invalid access to null pointers, and so forth. Most of the time these unexpected errors are occurs when we haven't written a memory-safe and resource-safe program, or they might occur due to hardware issues or uncontrollable external problems. We as a developer don't know how to cope with these types of errors at runtime. We should investigate to find the exact root cause of these defects."),(0,r.kt)("p",null,"As we cannot handle unexpected errors, we should instead log them with their respective stack traces and contextual information. So later we could investigate the problem and try to fix them. The best we can do with unexpected errors is to ",(0,r.kt)("em",{parentName:"p"},"sandbox")," them to limit the damage that they do to the overall application. For example, an unexpected error in browser extension shouldn't crash the whole browser."),(0,r.kt)("p",null,"So the best practice for each of these errors is as follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Expected Errors")," \u2014 we handle expected errors with the aid of the Scala compiler, by pushing them into the type system. In ZIO there is the error type parameter called ",(0,r.kt)("inlineCode",{parentName:"li"},"E"),", and this error type parameter is for modeling all the expected errors in the application.")),(0,r.kt)("p",null,"A ZIO value has a type parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," which is the type of ",(0,r.kt)("em",{parentName:"p"},"declared errors")," it can fail with. ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," only covers the errors which were specified at the outset. The same ZIO value could still throw exceptions in unforeseen ways. These unforeseen situations are called ",(0,r.kt)("em",{parentName:"p"},"defects")," in a ZIO program, and they lie outside ",(0,r.kt)("inlineCode",{parentName:"p"},"E"),"."),(0,r.kt)("p",null,"Bringing abnormal situations from the domain of defects into that of ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," enables the compiler to help us keep a tab on error conditions throughout the application, at compile time. This helps ensure the handling of domain errors in domain-specific ways."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Unexpected Errors")," \u2014 We encode unexpected errors by not reflecting them to the type system because there is no way we could do it, and it wouldn't provide any value if we could. At best as we can, we simply sandbox that to some well-defined area of the application.")),(0,r.kt)("p",null,"Note that ",(0,r.kt)("em",{parentName:"p"},"defects"),", can creep silently to higher levels in our application, and, if they get triggered at all, their handling might eventually be in more general ways."),(0,r.kt)("p",null,"So for ZIO, expected errors are reflected in the type of the ZIO effect, whereas unexpected errors are not so reflective, and that is the distinction."),(0,r.kt)("p",null,"That is the best practice. It helps us write better code. The code that we can reason about its error properties and potential expected errors. We can look at the ZIO effect and know how it is supposed to fail."),(0,r.kt)("p",null,"So to summarize"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Unexpected errors are impossible to recover and they will eventually shut down the application but expected errors can be recovered by handling them."),(0,r.kt)("li",{parentName:"ol"},"We do not type unexpected errors, but we type expected errors either explicitly or using general ",(0,r.kt)("inlineCode",{parentName:"li"},"Throwable")," error type."),(0,r.kt)("li",{parentName:"ol"},"Unexpected errors mostly is a sign of programming errors, but expected errors part of domain errors."),(0,r.kt)("li",{parentName:"ol"},"Even though we haven't any clue on how to handle defects, we might still need to do some operation, before letting them crash the application. So in such a situation, we can ",(0,r.kt)("a",{parentName:"li",href:"#catching-defects"},"catch defects")," do following operations, and then rethrow them again:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"logging the defect to a log aggregator"),(0,r.kt)("li",{parentName:"ul"},"sending an email to alert developers"),(0,r.kt)("li",{parentName:"ul"},'displaying a nice "unexpected error" message to the user'),(0,r.kt)("li",{parentName:"ul"},"etc.")),(0,r.kt)("h2",{id:"exceptional-and-unexceptional-effects"},"Exceptional and Unexceptional Effects"),(0,r.kt)("p",null,"Besides the ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," type alias, ZIO has four different type aliases which can be categorized into two different categories:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Exceptional Effect")," \u2014 ",(0,r.kt)("inlineCode",{parentName:"li"},"Task")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"RIO")," are two effects whose error parameter is fixed to ",(0,r.kt)("inlineCode",{parentName:"li"},"Throwable"),", so we call them exceptional effects."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Unexceptional Effect")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"UIO")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"URIO")," have error parameters that are fixed to ",(0,r.kt)("inlineCode",{parentName:"li"},"Nothing"),", indicating that they are unexceptional effects. So they can't fail, and the compiler knows about it.")),(0,r.kt)("p",null,"So when we compose different effects together, at any point of the codebase we can determine this piece of code can fail or cannot. As a result, typed errors offer a compile-time transition point between this can fail and this can't fail."),(0,r.kt)("p",null,"For example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.acquireReleaseWith")," API asks us to provide three different inputs: ",(0,r.kt)("em",{parentName:"p"},"require"),", ",(0,r.kt)("em",{parentName:"p"},"release"),", and ",(0,r.kt)("em",{parentName:"p"},"use"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"release")," parameter requires a function from ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"URIO[R, Any]"),". So, if we put an exceptional effect, it will not compile:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object ZIO {\n  def acquireReleaseWith[R, E, A, B](\n    acquire: => ZIO[R, E, A],\n    release: A => URIO[R, Any],\n    use: A => ZIO[R, E, B]\n  ): ZIO[R, E, B]\n}\n")),(0,r.kt)("h2",{id:"typed-errors-dont-guarantee-the-absence-of-defects-and-interruptions"},"Typed Errors Don't Guarantee the Absence of Defects and Interruptions"),(0,r.kt)("p",null,"Having an effect of type ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO[R, E, A]"),", means it can fail because of some failure of type ",(0,r.kt)("inlineCode",{parentName:"p"},"E"),", but it doesn't mean it can't die or be interrupted. So the error channel is only for ",(0,r.kt)("inlineCode",{parentName:"p"},"failure")," errors."),(0,r.kt)("p",null,"In the following example, the type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"validateNonNegativeNumber")," function is ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO[Any, String, Int]")," which denotes it is a typed exceptional effect. It can fail of type ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," but it still can die with the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException")," defect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef validateNonNegativeNumber(input: String): ZIO[Any, String, Int] =\n  input.toIntOption match {\n    case Some(value) if value >= 0 =>\n      ZIO.succeed(value)\n    case Some(other) =>\n      ZIO.fail(s"the entered number is negative: $other")\n    case None =>\n      ZIO.die(\n        new NumberFormatException(\n          s"the entered input is not in the correct number format: $input"\n        )\n      )\n  }\n')),(0,r.kt)("p",null,"Also, its underlying fiber can be interrupted without affecting the type of the error channel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval myApp: ZIO[Any, String, Int] =\n  for {\n    f <- validateNonNegativeNumber("5").fork\n    _ <- f.interrupt\n    r <- f.join\n  } yield r\n')),(0,r.kt)("p",null,"Therefore, if we run the ",(0,r.kt)("inlineCode",{parentName:"p"},"myApp")," effect, it will be interrupted before it gets the chance to finish."),(0,r.kt)("h2",{id:"sequential-and-parallel-errors"},"Sequential and Parallel Errors"),(0,r.kt)("p",null,"A simple and regular ZIO application usually fails with one error, which is the first error encountered by the ZIO runtime:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val fail = ZIO.fail("Oh uh!")\n  val die = ZIO.dieMessage("Boom!")\n  val interruption = ZIO.interrupt\n\n  def run = (fail <*> die) *> interruption\n}\n')),(0,r.kt)("p",null,'This application will fail with the first error which is "Oh uh!":'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-03-09T09:50:22.067072131Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.String: Oh uh!\n    at <empty>.MainApp.fail(MainApp.scala:4)"\n')),(0,r.kt)("p",null,"In some cases, we may run into multiple errors. When we perform parallel computations, the application may fail due to multiple errors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.fail("Oh!") <&> ZIO.fail("Uh!")\n}\n')),(0,r.kt)("p",null,"If we run this application, we can see two exceptions in two different fibers that caused the failure (",(0,r.kt)("inlineCode",{parentName:"p"},"zio-fiber-0")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"zio-fiber-14"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-03-09T08:05:48.703035927Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-13" java.lang.String: Oh!\n    at <empty>.MainApp.run(MainApp.scala:4)\nException in thread "zio-fiber-14" java.lang.String: Uh!\n    at <empty>.MainApp.run(MainApp.scala:4)"\n')),(0,r.kt)("p",null,"ZIO has a combinator called ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#parallelErrors")," that exposes all parallel failure errors in the error channel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: ZIO[Any, ::[String], Nothing] =\n  (ZIO.fail("Oh uh!") <&> ZIO.fail("Oh Error!")).parallelErrors\n')),(0,r.kt)("p",null,"Note that this operator is only for failures, not defects or interruptions."),(0,r.kt)("p",null,"Also, when we work with resource-safety operators like ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#ensuring")," we can have multiple sequential errors. Why? because regardless of the original effect has any errors or not, the finalizer is uninterruptible. So the finalizer will be run. Unless the finalizer should be an unexceptional effect (",(0,r.kt)("inlineCode",{parentName:"p"},"URIO"),"), it may die because of a defect. Therefore, it creates multiple sequential errors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.fail("Oh uh!").ensuring(ZIO.dieMessage("Boom!"))\n}\n')),(0,r.kt)("p",null,"When we run this application, we can see that the original failure (",(0,r.kt)("inlineCode",{parentName:"p"},"Oh uh!"),") was suppressed by another defect (",(0,r.kt)("inlineCode",{parentName:"p"},"Boom!"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-03-09T08:30:56.563179230Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.String: Oh uh!\n    at <empty>.MainApp.run(MainApp.scala:4)\n    Suppressed: java.lang.RuntimeException: Boom!\n        at <empty>.MainApp.run(MainApp.scala:4)"\n')),(0,r.kt)("h2",{id:"recovering-from-errors"},"Recovering From Errors"),(0,r.kt)("h3",{id:"1-catching"},"1. Catching"),(0,r.kt)("h4",{id:"catching-failures"},"Catching Failures"),(0,r.kt)("p",null,"If we want to catch and recover from all ",(0,r.kt)("em",{parentName:"p"},"typed error")," and effectfully attempt recovery, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAll")," operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def catchAll[R1 <: R, E2, A1 >: A](h: E => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n}\n")),(0,r.kt)("p",null,"We can recover from all errors while reading a file and then fallback to another operation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval z: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.json").catchAll(_ =>\n    readFile("backup.json"))\n')),(0,r.kt)("p",null,"In the callback passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAll"),", we may return an effect with a different error type (or perhaps ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),"), which will be reflected in the type of effect returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAll"),"."),(0,r.kt)("p",null,"When using this operator, the match cases should be exhaustive:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val result: ZIO[Any, Nothing, Int] =\n  validate(20)\n  .catchAll {\n    case NegativeAgeException(age) =>\n      ZIO.debug(s"negative age: $age").as(-1)\n    case IllegalAgeException(age) =>\n      ZIO.debug(s"illegal age: $age").as(-1)\n  }\n')),(0,r.kt)("p",null,"If we forget to catch all cases and the match fails, the original ",(0,r.kt)("strong",{parentName:"p"},"failure")," will be lost and replaced by a ",(0,r.kt)("inlineCode",{parentName:"p"},"MatchError")," ",(0,r.kt)("strong",{parentName:"p"},"defect"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object MainApp extends ZIOAppDefault {\n  val result: ZIO[Any, Nothing, Int] =\n    validate(15)\n      .catchAll {\n        case NegativeAgeException(age) =>\n          ZIO.debug(s"negative age: $age").as(-1)\n//        case IllegalAgeException(age) =>\n//          ZIO.debug(s"illegal age: $age").as(-1)\n      }\n\n  def run = result\n}\n')),(0,r.kt)("p",null,"Another important note about ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAll")," is that this operator only can recover from ",(0,r.kt)("em",{parentName:"p"},"failures"),". So it can't recover from defects or fiber interruptions."),(0,r.kt)("p",null,"Let's try what happens if we ",(0,r.kt)("inlineCode",{parentName:"p"},"catchAll")," on a dying effect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val die: ZIO[Any, String, Nothing] =\n    ZIO.dieMessage("Boom!") *> ZIO.fail("Oh uh!")\n\n  def run = die.catchAll(_ => ZIO.unit)\n}\n')),(0,r.kt)("p",null,"Also, if we have a fiber interruption, we can't catch that using this operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val interruptedEffect: ZIO[Any, String, Nothing] =\n    ZIO.interrupt *> ZIO.fail("Oh uh!")\n\n  def run = interruptedEffect.catchAll(_ => ZIO.unit)\n}\n')),(0,r.kt)("p",null,"If we want to catch and recover from only some types of exceptions and effectfully attempt recovery, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchSome")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def catchSome[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[E, ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n")),(0,r.kt)("p",null,"In the following example, we are only catching failure of type ",(0,r.kt)("inlineCode",{parentName:"p"},"FileNotFoundException"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval data: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.data").catchSome {\n    case _ : FileNotFoundException =>\n      readFile("backup.data")\n  }\n')),(0,r.kt)("h4",{id:"catching-defects"},"Catching Defects"),(0,r.kt)("p",null,"Like catching failures, ZIO has two operators to catch ",(0,r.kt)("em",{parentName:"p"},"defects"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def catchAllDefect[R1 <: R, E1 >: E, A1 >: A](h: Throwable => ZIO[R1, E1, A1]): ZIO[R1, E1, A1]\n\n  def catchSomeDefect[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[Throwable, ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n")),(0,r.kt)("p",null,"Let's try the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAllDefect")," operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.dieMessage("Boom!")\n  .catchAllDefect {\n    case e: RuntimeException if e.getMessage == "Boom!" =>\n      ZIO.debug("Boom! defect caught.")\n    case _: NumberFormatException =>\n      ZIO.debug("NumberFormatException defect caught.")\n    case _ =>\n      ZIO.debug("Unknown defect caught.")\n  }\n')),(0,r.kt)("p",null,"We should note that using these operators, we can only recover from a dying effect, and it cannot recover from a failure or fiber interruption."),(0,r.kt)("p",null,"A defect is an error that cannot be anticipated in advance, and there is no way to respond to it. Our rule of thumb is to not recover defects since we don't know about them. We let them crash the application. Although, in some cases, we might need to reload a part of the application instead of killing the entire application."),(0,r.kt)("p",null,"Assume we have written an application that can load plugins at runtime. During the runtime of the plugins, if a defect occurs, we don't want to crash the entire application; rather, we log all defects and then reload the plugin."),(0,r.kt)("h4",{id:"catching-causes"},"Catching Causes"),(0,r.kt)("p",null,"So far, we have only studied how to catch ",(0,r.kt)("em",{parentName:"p"},"failures")," and ",(0,r.kt)("em",{parentName:"p"},"defects"),". But what about ",(0,r.kt)("em",{parentName:"p"},"fiber interruptions")," or how about the specific combination of these errors?"),(0,r.kt)("p",null,"There are two ZIO operators useful for catching causes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def catchAllCause[R1 <: R, E2, A1 >: A](h: Cause[E] => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n\n  def catchSomeCause[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[Cause[E], ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n")),(0,r.kt)("p",null,"With the help of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAllCause")," operator we can catch all errors of an effect and recover from them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval exceptionalEffect = ZIO.attempt(???)\n\nexceptionalEffect.catchAllCause {\n  case Cause.Empty =>\n    ZIO.debug("no error caught")\n  case Cause.Fail(value, _) =>\n    ZIO.debug(s"a failure caught: $value")\n  case Cause.Die(value, _) =>\n    ZIO.debug(s"a defect caught: $value")\n  case Cause.Interrupt(fiberId, _) =>\n    ZIO.debug(s"a fiber interruption caught with the fiber id: $fiberId")\n  case Cause.Stackless(cause: Cause.Die, _) =>\n    ZIO.debug(s"a stackless defect caught: ${cause.value}")\n  case Cause.Stackless(cause: Cause[_], _) =>\n    ZIO.debug(s"an unknown stackless defect caught: ${cause.squashWith(identity)}")\n  case Cause.Then(left, right) =>\n    ZIO.debug(s"two consequence causes caught")\n  case Cause.Both(left, right) =>\n    ZIO.debug(s"two parallel causes caught")\n}\n')),(0,r.kt)("p",null,"Additionally, there is a partial version of this operator called ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchSomeCause"),", which can be used when we don't want to catch all causes, but some of them."),(0,r.kt)("h4",{id:"catching-traces"},"Catching Traces"),(0,r.kt)("p",null,"The two ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAllTrace")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchSomeTrace")," operators are useful to catch the typed error as well as stack traces of exceptional effects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def catchAllTrace[R1 <: R, E2, A1 >: A](\n    h: ((E, Trace)) => ZIO[R1, E2, A1]\n  ): ZIO[R1, E2, A1]\n\n  def catchSomeTrace[R1 <: R, E1 >: E, A1 >: A](\n    pf: PartialFunction[(E, Trace), ZIO[R1, E1, A1]]\n  ): ZIO[R1, E1, A1]\n}\n")),(0,r.kt)("p",null,"In the below example, let's try to catch a failure on the line number 4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO\n  .fail("Oh uh!")\n  .catchAllTrace {\n    case ("Oh uh!", trace)\n      if trace.toJava\n        .map(_.getLineNumber)\n        .headOption\n        .contains(4) =>\n      ZIO.debug("caught a failure on the line number 4")\n    case _ =>\n      ZIO.debug("caught other failures")\n  }\n')),(0,r.kt)("h4",{id:"catching-non-fatal"},"Catching Non-Fatal"),(0,r.kt)("p",null,"We can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchNonFatalOrDie")," to recover from all non-fatal errors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def catchNonFatalOrDie[R1 <: R, E2, A1 >: A](\n    h: E => ZIO[R1, E2, A1]\n  )(implicit ev1: CanFail[E], ev2: E <:< Throwable): ZIO[R1, E2, A1]\n}\n")),(0,r.kt)("p",null,"In case of occurring any ",(0,r.kt)("a",{parentName:"p",href:"#3-fatal-errors"},"fatal error"),", it will die."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'openFile("data.json").catchNonFatalOrDie(_ => openFile("backup.json"))\n')),(0,r.kt)("h3",{id:"2-fallback"},"2. Fallback"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#orElse")),"\u2014 We can try one effect, or if it fails, try another effect with the ",(0,r.kt)("inlineCode",{parentName:"li"},"orElse")," combinator:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def orElse[R1 <: R, E2, A1 >: A](that: => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n}\n")),(0,r.kt)("p",null,"Let's try an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val primaryOrBackupData: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.data").orElse(readFile("backup.data"))\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#orElseEither")),"\u2014 If the original effect fails, this operator tries another effect, and as a result, returns either:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def orElseEither[R1 <: R, E2, B](that: => ZIO[R1, E2, B]): ZIO[R1, E2, Either[A, B]]\n}\n")),(0,r.kt)("p",null,"This operator is useful when the fallback effect has a different result type than the original effect. So this will unify both in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Either[A, B]")," data type. Here is an example usage of this operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait LocalConfig\ntrait RemoteConfig\n\ndef readLocalConfig: ZIO[Any, Throwable, LocalConfig] = ???\ndef readRemoteConfig: ZIO[Any, Throwable, RemoteConfig] = ???\n\nval result: ZIO[Any, Throwable, Either[LocalConfig, RemoteConfig]] =\n  readLocalConfig.orElseEither(readRemoteConfig)\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#orElseSucceed"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#orElseFail")),"\u2014 These two operators convert the original failure with constant succeed or failure values:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +R, +E] {\n  def orElseFail[E1](e1: => E1): ZIO[R, E1, A]\n\n  def orElseSucceed[A1 >: A](a1: => A1): ZIO[R, Nothing, A1]\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#orElseFail")," will always replace the original failure with the new one, so ",(0,r.kt)("inlineCode",{parentName:"p"},"E1")," does not have to be a supertype of ",(0,r.kt)("inlineCode",{parentName:"p"},"E"),". It is useful when we have ",(0,r.kt)("inlineCode",{parentName:"p"},"Unit")," as an error, and we want to unify that with something else:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] = {\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n}\n\nval result: ZIO[Any, String, Int] =\n  validate(3).orElseFail("invalid age")\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#orElseSucceed")," will always replace the original failure with a success value so the resulting effect cannot fail. It is useful when we have a constant value that will work in case the effect fails:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val result: ZIO[Any, Nothing, Int] =\n  validate(3).orElseSucceed(0)\n")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#orElseOptional")),"\u2014 When dealing with optional failure types, we might need to fall back to another effect when the failure value is ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),". This operator helps to do so:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def orElseOptional[R1 <: R, E1, A1 >: A](\n      that: => ZIO[R1, Option[E1], A1]\n    )(implicit ev: E IsSubtypeOfError Option[E1]): ZIO[R1, Option[E1], A1] =\n}\n")),(0,r.kt)("p",null,"In the following example, the ",(0,r.kt)("inlineCode",{parentName:"p"},'parseInt(" ")')," fails with ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", so then the fallback effect results in a zero:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef parseInt(input: String): ZIO[Any, Option[String], Int] =\n  input.toIntOption match {\n    case Some(value) => ZIO.succeed(value)\n    case None =>\n      if (input.trim.isEmpty)\n        ZIO.fail(None)\n      else\n        ZIO.fail(Some(s"invalid non-integer input: $input"))\n  }\n\nval result = parseInt("  ").orElseOptional(ZIO.succeed(0)).debug\n')),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO.firstSuccessOf"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#firstSuccessOf")),"\u2014 These two operators make it easy for a user to run an effect, and in case it fails, it will run a series of ZIO effects until one succeeds:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object ZIO {\n  def firstSuccessOf[R, R1 <: R, E, A](\n    zio: => ZIO[R, E, A],\n    rest: => Iterable[ZIO[R1, E, A]]\n  ): ZIO[R1, E, A] =\n}\n\ntrait ZIO[-R, +E, +A] {\n  final def firstSuccessOf[R1 <: R, E1 >: E, A1 >: A](\n    rest: => Iterable[ZIO[R1, E1, A1]]\n  ): ZIO[R1, E1, A1]\n}\n")),(0,r.kt)("p",null,"These methods use ",(0,r.kt)("inlineCode",{parentName:"p"},"orElse")," to reduce the non-empty iterable of effects into a single effect."),(0,r.kt)("p",null,"In the following example, we are trying to get the config from the master node, and if it fails, we will try successively to retrieve the config from the next available node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ntrait Config\n\ndef remoteConfig(name: String): ZIO[Any, Throwable, Config] =\n  ZIO.attempt(???)\n\nval masterConfig: ZIO[Any, Throwable, Config] =\n  remoteConfig("master")\n\nval nodeConfigs: Seq[ZIO[Any, Throwable, Config]] =\n  List("node1", "node2", "node3", "node4").map(remoteConfig)\n\nval config: ZIO[Any, Throwable, Config] =\n  ZIO.firstSuccessOf(masterConfig, nodeConfigs)\n')),(0,r.kt)("h3",{id:"3-folding"},"3. Folding"),(0,r.kt)("p",null,"Scala's ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," data types have ",(0,r.kt)("inlineCode",{parentName:"p"},"fold"),", which let us handle both failure and success at the same time. In a similar fashion, ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," effects also have several methods that allow us to handle both failure and success."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#fold"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#foldZIO")),"\u2014 The first fold method, ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#fold"),", lets us non-effectfully handle both failure and success, by supplying a non-effectful handler for each case. The second fold method, ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#foldZIO"),", lets us effectfully handle both failure and success, by supplying an effectful (but still pure) handler for each case:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def fold[B](\n    failure: E => B,\n    success: A => B\n  ): ZIO[R, Nothing, B]\n\n  def foldZIO[R1 <: R, E2, B](\n    failure: E => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  ): ZIO[R1, E2, B]\n}\n")),(0,r.kt)("p",null,"Let's try an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nlazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: UIO[Array[Byte]] =\n  readFile("primary.data").fold(_ => DefaultData, data => data)\n')),(0,r.kt)("p",null,"We can ignore any failure and success values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: ZIO[Any, Nothing, Unit] =\n  ZIO\n    .fail("Uh oh!")         // ZIO[Any, String, Int]\n    .as(5)                  // ZIO[Any, String, Int]\n    .fold(_ => (), _ => ()) // ZIO[Any, Nothing, Unit]\n')),(0,r.kt)("p",null,"It is equivalent to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#ignore")," operator instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: ZIO[Any, Nothing, Unit] = ZIO.fail("Uh oh!").as(5).ignore\n')),(0,r.kt)("p",null,"Now let's try the effectful version of the fold operation. In this example, in case of failure on reading from the primary file, we will fallback to another effectful operation which will read data from the secondary file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val primaryOrSecondaryData: IO[IOException, Array[Byte]] =\n  readFile("primary.data").foldZIO(\n    failure = _    => readFile("secondary.data"),\n    success = data => ZIO.succeed(data)\n  )\n')),(0,r.kt)("p",null,"Nearly all error handling methods are defined in terms of ",(0,r.kt)("inlineCode",{parentName:"p"},"foldZIO"),", because it is both powerful and fast."),(0,r.kt)("p",null,"In the following example, ",(0,r.kt)("inlineCode",{parentName:"p"},"foldZIO")," is used to handle both failure and success of the ",(0,r.kt)("inlineCode",{parentName:"p"},"readUrls")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val urls: UIO[Content] =\n  readUrls("urls.json").foldZIO(\n    error   => ZIO.succeed(NoContent(error)),\n    success => fetchContent(success)\n  )\n')),(0,r.kt)("p",null,"It's important to note that both ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#fold")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#foldZIO")," operators cannot catch fiber interruptions. So the following application will crash due to ",(0,r.kt)("inlineCode",{parentName:"p"},"InterruptedException"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = (ZIO.interrupt *> ZIO.fail("Uh oh!")).fold(_ => (), _ => ())\n}\n')),(0,r.kt)("p",null,"And here is the output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-02-24T13:41:01.696273024Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.InterruptedException: Interrupted by thread "zio-fiber-"\n   at <empty>.MainApp.run(MainApp.scala:4)"\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#foldCause"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#foldCauseZIO")),"\u2014 This cause version of the ",(0,r.kt)("inlineCode",{parentName:"li"},"fold")," operator is useful to access the full cause of the underlying fiber. So in case of failure, based on the exact cause, we can determine what to do:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def foldCause[B](\n    failure: Cause[E] => B,\n    success: A => B\n  ): ZIO[R, Nothing, B]\n\n  def foldCauseZIO[R1 <: R, E2, B](\n    failure: Cause[E] => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  ): ZIO[R1, E2, B]\n}\n")),(0,r.kt)("p",null,"Among the fold operators, these are the most powerful combinators. They can recover from any error, even fiber interruptions."),(0,r.kt)("p",null,"In the following example, we are printing the proper message according to what cause occurred due to failure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval exceptionalEffect: ZIO[Any, Throwable, Unit] = ???\n\nval myApp: ZIO[Any, IOException, Unit] =\n  exceptionalEffect.foldCauseZIO(\n    failure = {\n      case Cause.Fail(value, _)        => Console.printLine(s"failure: $value")\n      case Cause.Die(value, _)         => Console.printLine(s"cause: $value")\n      case Cause.Interrupt(failure, _) => Console.printLine(s"${failure.threadName} interrupted!")\n      case _                           => Console.printLine("failed due to other causes")\n    },\n    success = succeed => Console.printLine(s"succeeded with $succeed value")\n  )\n')),(0,r.kt)("p",null,"When catching errors using this operator, if our cases were not exhaustive, we may receive a defect of the type ",(0,r.kt)("inlineCode",{parentName:"p"},"scala.MatchError")," :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val exceptionalEffect: ZIO[Any, Throwable, Unit] = ZIO.interrupt\n\n  val myApp: ZIO[Any, IOException, Unit] =\n    exceptionalEffect.foldCauseZIO(\n      failure = {\n        case Cause.Fail(value, _) => ZIO.debug(s"failure: $value")\n        case Cause.Die(value, _) => ZIO.debug(s"cause: ${value.toString}")\n        // case Cause.Interrupt(failure, _) => ZIO.debug(s"${failure.threadName} interrupted!")\n      },\n      success = succeed => ZIO.debug(s"succeeded with $succeed value")\n    )\n\n  def run = myApp\n}\n')),(0,r.kt)("p",null,"The output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-02-24T11:05:40.241436257Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" scala.MatchError: Interrupt(Runtime(2,1645700739),Trace(Runtime(2,1645700739),Chunk(<empty>.MainApp.exceptionalEffect(MainApp.scala:6),<empty>.MainApp.myApp(MainApp.scala:9)))) (of class zio.Cause$Interrupt)\n    at MainApp$.$anonfun$myApp$1(MainApp.scala:10)\n    at zio.ZIO$TracedCont$$anon$33.apply(ZIO.scala:6167)\n    at zio.ZIO$TracedCont$$anon$33.apply(ZIO.scala:6165)\n    at zio.internal.FiberContext.runUntil(FiberContext.scala:885)\n    at zio.internal.FiberContext.run(FiberContext.scala:115)\n    at zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\n    at zio.internal.FiberContext.runUntil(FiberContext.scala:538)"\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#foldTraceZIO")),"\u2014 This version of fold, provide us the facility to access the trace info of the failure:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def foldTraceZIO[R1 <: R, E2, B](\n    failure: ((E, Trace)) => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  )(implicit ev: CanFail[E]): ZIO[R1, E2, B]\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: ZIO[Any, Nothing, Int] =\n  validate(5).foldTraceZIO(\n    failure = {\n      case (_: NegativeAgeException, trace) =>\n        ZIO.succeed(0).debug(\n          "The entered age is negative\\n" +\n            s"trace info: ${trace.stackTrace.mkString("\\n")}"\n        )\n      case (_: IllegalAgeException, trace) =>\n        ZIO.succeed(0).debug(\n          "The entered age in not legal\\n" +\n            s"trace info: ${trace.stackTrace.mkString("\\n")}"\n        )\n    },\n    success = s => ZIO.succeed(s)\n  )\n')),(0,r.kt)("p",null,"Note that similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#fold")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#foldZIO")," this operator cannot recover from fiber interruptions."),(0,r.kt)("h3",{id:"4-retrying"},"4. Retrying"),(0,r.kt)("p",null,"When we are building applications we want to be resilient in the face of a transient failure. This is where we need to retry to overcome these failures."),(0,r.kt)("p",null,"There are a number of useful methods on the ZIO data type for retrying failed effects:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retry")),"\u2014 The most basic of these is ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#retry"),", which takes a ",(0,r.kt)("inlineCode",{parentName:"li"},"Schedule")," and returns a new effect that will retry the first effect if it fails, according to the specified policy:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def retry[R1 <: R, S](policy: => Schedule[R1, E, S]): ZIO[R1, E, A]\n}\n")),(0,r.kt)("p",null,"In this example, we try to read from a file. If we fail to do that, it will try five more times:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval retriedOpenFile: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.data").retry(Schedule.recurs(5))\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryN")),"\u2014 In case of failure, a ZIO effect can be retried as many times as specified:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval file = readFile("primary.data").retryN(5)\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryOrElse")),"\u2014 The next most powerful function is ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#retryOrElse"),", which allows specification of a fallback to use, if the effect does not succeed with the specified policy:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def retryOrElse[R1 <: R, A1 >: A, S, E1](\n    policy: => Schedule[R1, E, S],\n    orElse: (E, S) => ZIO[R1, E1, A1]\n  ): ZIO[R1, E1, A1] =\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"orElse")," is the recovery function that has two inputs:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The last error message"),(0,r.kt)("li",{parentName:"ol"},"Schedule output")),(0,r.kt)("p",null,"So based on these two values, we can decide what to do as the fallback operation. Let's try an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    Random\n      .nextIntBounded(11)\n      .flatMap { n =>\n        if (n < 9)\n          ZIO.fail(s"$n is less than 9!").debug("failed")\n        else\n          ZIO.succeed(n).debug("succeeded")\n      }\n      .retryOrElse(\n        policy = Schedule.recurs(5),\n        orElse = (lastError, scheduleOutput: Long) =>\n          ZIO.debug(s"after $scheduleOutput retries, we couldn\'t succeed!") *>\n            ZIO.debug(s"the last error message we received was: $lastError") *>\n            ZIO.succeed(-1)\n      )\n      .debug("the final result")\n}\n')),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryOrElseEither")),"\u2014 This operator is almost the same as the ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryOrElse"))," except it will return either result of the original or the fallback operation:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait LocalConfig\ntrait RemoteConfig\n\ndef readLocalConfig: ZIO[Any, Throwable, LocalConfig] = ???\ndef readRemoteConfig: ZIO[Any, Throwable, RemoteConfig] = ???\n\nval result: ZIO[Any, Throwable, Either[RemoteConfig, LocalConfig]] =\n  readLocalConfig.retryOrElseEither(\n    schedule0 = Schedule.fibonacci(1.seconds),\n    orElse = (_, _: Duration) => readRemoteConfig\n  )\n")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryUntil"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryUntilZIO")),"\u2014 We can retry an effect until a condition on the error channel is satisfied:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def retryUntil(f: E => Boolean): ZIO[R, E, A]\n  def retryUntilZIO[R1 <: R](f: E => URIO[R1, Boolean]): ZIO[R1, E, A]\n}\n")),(0,r.kt)("p",null,"Assume we have defined the following remote service call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait  ServiceError extends Exception\ncase object TemporarilyUnavailable extends ServiceError\ncase object DataCorrupted          extends ServiceError\n\ndef remoteService: ZIO[Any, ServiceError, Unit] = ???\n")),(0,r.kt)("p",null,"In the following example, we repeat the failed remote service call until we reach the ",(0,r.kt)("inlineCode",{parentName:"p"},"DataCorrupted")," error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"remoteService.retryUntil(_ == DataCorrupted)\n")),(0,r.kt)("p",null,"To provide an effectful predicate we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#retryUntilZIO")," operator."),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryUntilEqual")),"\u2014 Like the previous operator, it tries until its error is equal to the specified error:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"remoteService.retryUntilEquals(DataCorrupted)\n")),(0,r.kt)("ol",{start:7},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryWhile"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryWhileZIO")),"\u2014 Unlike the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#retryUntil")," it will retry the effect while its error satisfies the specified predicate:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def retryWhile(f: E => Boolean): ZIO[R, E, A]\n  def retryWhileZIO[R1 <: R](f: E => URIO[R1, Boolean]): ZIO[R1, E, A]\n}\n")),(0,r.kt)("p",null,"In the following example, we repeat the failed remote service call while we have the ",(0,r.kt)("inlineCode",{parentName:"p"},"TemporarilyUnavailable")," error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"remoteService.retryWhile(_ == TemporarilyUnavailable)\n")),(0,r.kt)("p",null,"To provide an effectful predicate we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#retryWhileZIO")," operator."),(0,r.kt)("ol",{start:8},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#retryWhileEquals")),"\u2014 Like the previous operator, it tries while its error is equal to the specified error:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"remoteService.retryWhileEquals(TemporarilyUnavailable)\n")),(0,r.kt)("h3",{id:"5-timing-out"},"5. Timing out"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#timeout")),"\u2014 ZIO lets us timeout any effect using the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#timeout")," method, which returns a new effect that succeeds with an ",(0,r.kt)("inlineCode",{parentName:"li"},"Option"),". A value of ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," indicates the timeout elapsed before the effect completed. If an effect times out, then instead of continuing to execute in the background, it will be interrupted so no resources will be wasted.")),(0,r.kt)("p",null,"Assume we have the following effect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval myApp =\n  for {\n    _ <- ZIO.debug("start doing something.")\n    _ <- ZIO.sleep(2.second)\n    _ <- ZIO.debug("my job is finished!")\n  } yield "result"\n')),(0,r.kt)("p",null,"We should note that when we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#timeout")," operator on the ",(0,r.kt)("inlineCode",{parentName:"p"},"myApp"),", it doesn't return until one of the following situations happens:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The original effect returns before the timeout elapses so the output will be ",(0,r.kt)("inlineCode",{parentName:"li"},"Some")," of the produced value by the original effect:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .timeout(3.second)\n      .debug("output")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug("execution time of the whole program in second")\n}\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The original effect interrupted after the timeout elapses:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If the effect is interruptible it will be immediately interrupted, and finally, the timeout operation produces ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," value.")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .timeout(1.second)\n      .debug("output")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug("execution time of the whole program in second")\n}\n\n// Output:\n// start doing something.\n// output: None\n// execution time of the whole program in second: 1\n')),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If the effect is uninterruptible it will be blocked until the original effect safely finished its work, and then the timeout operator produces the ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," value:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .uninterruptible\n      .timeout(1.second)\n      .debug("output")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug("execution time of the whole program in second")\n}\n\n// Output:\n// start doing something.\n// my job is finished!\n// output: None\n// execution time of the whole program in second: 2\n')))),(0,r.kt)("p",null,"Instead of waiting for the original effect to be interrupted, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"effect.disconnect.timeout")," which first disconnects the effect's interruption signal before performing the timeout. By using this technique, we can return early after the timeout has passed and before an underlying effect has been interrupted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .uninterruptible\n      .disconnect\n      .timeout(1.second)\n      .debug("output")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug("execution time of the whole program in second")\n}\n')),(0,r.kt)("p",null,"By using this technique, the original effect will be interrupted in the background."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#timeoutTo")),"\u2014 This operator is similar to the previous one, but it also allows us to manually create the final result type:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval delayedNextInt: ZIO[Any, Nothing, Int] =\n  Random.nextIntBounded(10).delay(2.second)\n\nval r1: ZIO[Any, Nothing, Option[Int]] =\n  delayedNextInt.timeoutTo(None)(Some(_))(1.seconds)\n\nval r2: ZIO[Any, Nothing, Either[String, Int]] =\n  delayedNextInt.timeoutTo(Left("timeout"))(Right(_))(1.seconds)\n\nval r3: ZIO[Any, Nothing, Int] =\n  delayedNextInt.timeoutTo(-1)(identity)(1.seconds)\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#timeoutFail"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#timeoutFailCause")),"\u2014 In case of elapsing the timeout, we can produce a particular error message:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport scala.concurrent.TimeoutException\n\nval r1: ZIO[Any, TimeoutException, Int] =\n  delayedNextInt.timeoutFail(new TimeoutException)(1.second)\n\nval r2: ZIO[Any, Nothing, Int] =\n  delayedNextInt.timeoutFailCause(Cause.die(new Error("timeout")))(1.second)\n')),(0,r.kt)("h3",{id:"6-sandboxing"},"6. Sandboxing"),(0,r.kt)("p",null,"We know that a ZIO effect may fail due to a failure, a defect, a fiber interruption, or a combination of these causes. So a ZIO effect may contain more than one cause. Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#sandbox")," operator, we can sandbox all errors of a ZIO application, whether the cause is a failure, defect, or a fiber interruption or combination of these. This operator exposes the full cause of a ZIO effect into the error channel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def sandbox: ZIO[R, Cause[E], A]\n}\n")),(0,r.kt)("p",null,"We can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#sandbox")," operator to uncover the full causes of an ",(0,r.kt)("em",{parentName:"p"},"exceptional effect"),". So we can see all the errors that occurred as a type of ",(0,r.kt)("inlineCode",{parentName:"p"},"Cause[E]")," at the error channel of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," data type. So then we can use normal error-handling operators such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchSome")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAll")," operators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val effect: ZIO[Any, String, String] =\n    ZIO.succeed("primary result") *> ZIO.fail("Oh uh!")\n\n  val myApp: ZIO[Any, Cause[String], String] =\n    effect.sandbox.catchSome {\n      case Cause.Interrupt(fiberId, _) =>\n        ZIO.debug(s"Caught interruption of a fiber with id: $fiberId") *>\n          ZIO.succeed("fallback result on fiber interruption")\n      case Cause.Die(value, _) =>\n        ZIO.debug(s"Caught a defect: $value") *>\n          ZIO.succeed("fallback result on defect")\n      case Cause.Fail(value, _) =>\n        ZIO.debug(s"Caught a failure: $value") *>\n          ZIO.succeed("fallback result on failure")\n    }\n\n  val finalApp: ZIO[Any, String, String] = myApp.unsandbox.debug("final result")\n\n  def run = finalApp\n}\n\n// Output:\n// Caught a failure: Oh uh!\n// final result: fallback result on failure\n')),(0,r.kt)("p",null,"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"sandbox")," operation we are exposing the full cause of an effect. So then we have access to the underlying cause in more detail. After handling exposed causes using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catch*")," operators, we can undo the ",(0,r.kt)("inlineCode",{parentName:"p"},"sandbox")," operation using the ",(0,r.kt)("inlineCode",{parentName:"p"},"unsandbox")," operation. It will submerge the full cause (",(0,r.kt)("inlineCode",{parentName:"p"},"Cause[E]"),") again:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval effect: ZIO[Any, String, String] =\n  ZIO.succeed("primary result") *> ZIO.fail("Oh uh!")\n\neffect            // ZIO[Any, String, String]\n  .sandbox        // ZIO[Any, Cause[String], String]\n  .catchSome(???) // ZIO[Any, Cause[String], String]\n  .unsandbox      // ZIO[Any, String, String]\n')),(0,r.kt)("p",null,"There is another version of sandbox called ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#sandboxWith"),". This operator helps us to sandbox, then catch all causes, and then unsandbox back:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def sandboxWith[R1 <: R, E2, B](f: ZIO[R1, Cause[E], A] => ZIO[R1, Cause[E2], B])\n}\n")),(0,r.kt)("p",null,"Let's try the previous example using this operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val effect: ZIO[Any, String, String] =\n    ZIO.succeed("primary result") *> ZIO.fail("Oh uh!")\n\n  val myApp =\n    effect.sandboxWith[Any, String, String] { e =>\n      e.catchSome {\n        case Cause.Interrupt(fiberId, _) =>\n          ZIO.debug(s"Caught interruption of a fiber with id: $fiberId") *>\n            ZIO.succeed("fallback result on fiber interruption")\n        case Cause.Die(value, _) =>\n          ZIO.debug(s"Caught a defect: $value") *>\n            ZIO.succeed("fallback result on defect")\n        case Cause.Fail(value, _) =>\n          ZIO.debug(s"Caught a failure: $value") *>\n            ZIO.succeed("fallback result on failure")\n      }\n    }\n  def run = myApp.debug\n}\n')),(0,r.kt)("h2",{id:"error-accumulation"},"Error Accumulation"),(0,r.kt)("p",null,"Sequential combinators such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#zip")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.foreach")," stop when they reach the first error and return immediately. So their policy on error management is to fail fast."),(0,r.kt)("p",null,"In the following example, we can see that the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#zip")," operator will fail as soon as it reaches the first failure. As a result, we only see the first error in the stack trace:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val f1: ZIO[Any, Nothing, Int] = ZIO.succeed(1)\n  val f2: ZIO[Any, String, Int]  = ZIO.fail("Oh uh!").as(2)\n  val f3: ZIO[Any, Nothing, Int] = ZIO.succeed(3)\n  val f4: ZIO[Any, String, Int]  = ZIO.fail("Oh no!").as(4)\n\n  val myApp: ZIO[Any, String, (Int, Int, Int, Int)] =\n    f1 zip f2 zip f3 zip f4\n\n  def run = myApp.debug\n}\n')),(0,r.kt)("p",null,"There is also the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.foreach")," operator that takes a collection and an effectful operation, then tries to apply the transformation to all elements of the collection. This operator also has the same error management behavior. It fails when it encounters the first error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, String, List[Int]] =\n    ZIO.foreach(List(1, 2, 3, 4, 5)) { n =>\n      if (n < 4)\n        ZIO.succeed(n)\n      else\n        ZIO.fail(s"$n is not less that 4")\n    }\n\n  def run = myApp.debug\n}\n')),(0,r.kt)("p",null,"There are some situations when we need to collect all potential errors in a computation rather than failing fast. In this section, we will discuss operators that accumulate errors as well as successes."),(0,r.kt)("h3",{id:"ziovalidate"},(0,r.kt)("inlineCode",{parentName:"h3"},"ZIO#validate")),(0,r.kt)("p",null,"It is similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#zip")," operator, it sequentially zips two ZIO effects together, if both effects fail, it combines their causes with ",(0,r.kt)("inlineCode",{parentName:"p"},"Cause.Then"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def validate[R1 <: R, E1 >: E, B](that: => ZIO[R1, E1, B]): ZIO[R1, E1, (A, B)]\n}\n")),(0,r.kt)("p",null,"If any of effecful operations doesn't fail, it results like the ",(0,r.kt)("inlineCode",{parentName:"p"},"zip")," operator. Otherwise, when it reaches the first error it won't stop, instead, it will continue the zip operation until reach the final effect while combining:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val f1 = ZIO.succeed(1).debug\n  val f2 = ZIO.succeed(2) *> ZIO.fail("Oh uh!")\n  val f3 = ZIO.succeed(3).debug\n  val f4 = ZIO.succeed(4) *> ZIO.fail("Oh error!")\n  val f5 = ZIO.succeed(5).debug\n\n  val myApp: ZIO[Any, String, (Int, Int, Int)] =\n    f1 validate f2 validate f3 validate f4 validate f5\n\n  def run = myApp.cause.debug.uncause\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#validatePar")," operator is similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#validate")," operator zips two effects but in parallel. As this operator doesn't fail fast, unlike the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#zipPar")," if it reaches a failure, it won't interrupt another running effect. If both effects fail, it will combine their causes with ",(0,r.kt)("inlineCode",{parentName:"p"},"Cause.Both"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val f1 = ZIO.succeed(1).debug\n  val f2 = ZIO.succeed(2) *> ZIO.fail("Oh uh!")\n  val f3 = ZIO.succeed(3).debug\n  val f4 = ZIO.succeed(4) *> ZIO.fail("Oh error!")\n  val f5 = ZIO.succeed(5).debug\n\n  val myApp: ZIO[Any, String, ((((Int, Int), Int), Int), Int)] =\n    f1 validatePar f2 validatePar f3 validatePar f4 validatePar f5\n\n  def run = myApp.cause.map(_.untraced).debug.uncause\n}\n')),(0,r.kt)("p",null,"In addition, it has a ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#validateWith")," variant, which is useful for providing combiner function (",(0,r.kt)("inlineCode",{parentName:"p"},"f: (A, B) => C"),") to combine pair values."),(0,r.kt)("h3",{id:"ziovalidate-1"},(0,r.kt)("inlineCode",{parentName:"h3"},"ZIO.validate")),(0,r.kt)("p",null,"This operator is very similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.foreach")," operator. It transforms all elements of a collection using the provided effectful operation, but it collects all errors in the error channel, as well as the success values in the success channel."),(0,r.kt)("p",null,"It is similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.partition")," but it is an exceptional operator which means it collects errors in the error channel and success in the success channel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object ZIO {\n  def validate[R, E, A, B](in: Collection[A])(\n    f: A => ZIO[R, E, B]\n  ): ZIO[R, ::[E], Collection[B]]\n\n  def validate[R, E, A, B](in: NonEmptyChunk[A])(\n    f: A => ZIO[R, E, B]\n  ): ZIO[R, ::[E], NonEmptyChunk[B]]\n}\n")),(0,r.kt)("p",null,"Another difference is that this operator is lossy, which means if there are errors all successes will be lost."),(0,r.kt)("p",null,"In the lossy scenario, it will collect all errors in the error channel, which cause the failure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object MainApp extends ZIOAppDefault {\n  val res: ZIO[Any, ::[String], List[Int]] =\n    ZIO.validate(List.range(1, 7)){ n =>\n      if (n < 5)\n        ZIO.succeed(n)\n      else\n        ZIO.fail(s"$n is not less that 5")\n    }\n  def run = res.debug\n}\n')),(0,r.kt)("p",null,"In the success scenario when we have no errors at all, all the successes will be collected in the success channel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val res: ZIO[Any, ::[String], List[Int]] =\n    ZIO.validate(List.range(1, 4)){ n =>\n      if (n < 5)\n        ZIO.succeed(n)\n      else\n        ZIO.fail(s"$n is not less that 5")\n    }\n  def run = res.debug\n}\n')),(0,r.kt)("p",null,"Two more notes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.validate")," operator is sequential, so we can use the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.validatePar")," version to do the computation in parallel."),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.validateDiscard")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.validateParDiscard")," operators are mostly similar to their non-discard versions, except they discard the successes. So the type of the success channel will be ",(0,r.kt)("inlineCode",{parentName:"li"},"Unit"),".")),(0,r.kt)("h3",{id:"ziovalidatefirst"},(0,r.kt)("inlineCode",{parentName:"h3"},"ZIO.validateFirst")),(0,r.kt)("p",null,"Like the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.validate")," in the success scenario, it will collect all errors in the error channel except in the success scenario it will return only the first success:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object ZIO {\n  def validateFirst[R, E, A, B](in: Collection[A])(\n    f: A => ZIO[R, E, B]\n  ): ZIO[R, Collection[E], B]\n}\n")),(0,r.kt)("p",null,"In the failure scenario, it will collect all errors in the failure channel, and it causes the failure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val res: ZIO[Any, List[String], Int] =\n    ZIO.validateFirst(List.range(5, 10)) { n =>\n      if (n < 5)\n        ZIO.succeed(n)\n      else\n        ZIO.fail(s"$n is not less that 5")\n    }\n  def run = res.debug\n}\n')),(0,r.kt)("p",null,"In the success scenario it will return the first success value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val res: ZIO[Any, List[String], Int] =\n    ZIO.validateFirst(List.range(1, 4)) { n =>\n      if (n < 5)\n        ZIO.succeed(n)\n      else\n        ZIO.fail(s"$n is not less that 5")\n    }\n  def run = res.debug\n}\n')),(0,r.kt)("h3",{id:"ziopartition"},(0,r.kt)("inlineCode",{parentName:"h3"},"ZIO.partition")),(0,r.kt)("p",null,"The partition operator takes an iterable and effectful function that transforms each value of the iterable and finally creates a tuple of both failures and successes in the success channel."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object ZIO {\n  def partition[R, E, A, B](in: => Iterable[A])(\n    f: A => ZIO[R, E, B]\n  ): ZIO[R, Nothing, (Iterable[E], Iterable[B])]\n}\n")),(0,r.kt)("p",null,"Note that this operator is an unexceptional effect, which means the type of the error channel is ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),". So using this operator, if we reach a failure case, the whole effect doesn't fail. This is similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"List#partition")," in the standard library:"),(0,r.kt)("p",null,"Let's try an example of collecting even numbers from the range of 0 to 7:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval res: ZIO[Any, Nothing, (Iterable[String], Iterable[Int])] =\n  ZIO.partition(List.range(0, 7)){ n =>\n    if (n % 2 == 0)\n      ZIO.succeed(n)\n    else\n      ZIO.fail(s"$n is not even")\n  }\nres.debug\n')),(0,r.kt)("h2",{id:"error-channel-operations"},"Error Channel Operations"),(0,r.kt)("h3",{id:"map-and-flatmap-on-the-error-channel"},"Map and FlatMap on the Error Channel"),(0,r.kt)("p",null,"Other than ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#flatMap"),", ZIO has several other operators to manage errors while mapping:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#mapError"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#mapErrorCause")),"\u2014 Let's begin with ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#mapError")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#mapErrorCause"),". These operators help us to access the error channel as a raw error value or as a type of ",(0,r.kt)("inlineCode",{parentName:"li"},"Cause")," and map their values:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def mapError[E2](f: E => E2): ZIO[R, E2, A]\n  def mapErrorCause[E2](h: Cause[E] => Cause[E2]): ZIO[R, E2, A]\n}\n")),(0,r.kt)("p",null,"Here are two simple examples for these operators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] = ???\n\n// mapping the error of the original effect to its message\nval r1: ZIO[Any, String, Int] =\n  parseInt("five")                // ZIO[Any, NumberFormatException, Int]\n    .mapError(e => e.getMessage)  // ZIO[Any, String, Int]  // ZIO[Any, String, Int]\n\n// mapping the cause of the original effect to be untraced\nval r2 = parseInt("five")         // ZIO[Any, NumberFormatException, Int]\n  .mapErrorCause(_.untraced)      // ZIO[Any, NumberFormatException, Int]\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("em",{parentName:"p"},(0,r.kt)("strong",{parentName:"em"},"Note:"))),(0,r.kt)("p",{parentName:"blockquote"},"Note that mapping over an effect's success or error channel does not change the success or failure of the effect, in the same way that mapping over an ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," does not change whether the ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Left")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Right"),".")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#mapAttempt")),"\u2014 The ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#mapAttempt")," returns an effect whose success is mapped by the specified side-effecting ",(0,r.kt)("inlineCode",{parentName:"li"},"f")," function, translating any thrown exceptions into typed failed effects. So it converts an unchecked exception to a checked one by returning the ",(0,r.kt)("inlineCode",{parentName:"li"},"RIO")," effect.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  trait ZIO[-R, +E, +A] {\n    def map[B](f: A => B): ZIO[R, E, B]\n    def mapAttempt[B](f: A => B): ZIO[R, Throwable, B]\n  }\n")),(0,r.kt)("p",null,"Using operations that can throw exceptions inside of ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#map")," such as ",(0,r.kt)("inlineCode",{parentName:"p"},"effect.map(_.unsafeOpThatThrows)")," will result in a defect (an unexceptional effect that will die). In the following example, when we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#map")," operation. So, if the ",(0,r.kt)("inlineCode",{parentName:"p"},"String#toInt")," operation throws ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException")," it will be converted to a defect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval result: ZIO[Any, Nothing, Int] =\n  Console.readLine.orDie.map(_.toInt)\n")),(0,r.kt)("p",null,"As a result, when the map operation is unsafe, it may lead to buggy programs that may crash, as shown below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, Nothing, Unit] =\n    Console.print("Please enter a number: ").orDie *>\n      Console.readLine.orDie\n        .map(_.toInt)\n        .map(_ % 2 == 0)\n        .flatMap {\n          case true =>\n            Console.printLine("You have entered an even number.").orDie\n          case false =>\n            Console.printLine("You have entered an odd number.").orDie\n        }\n\n  def run = myApp\n}\n')),(0,r.kt)("p",null,'Converting literal "five" String to Int by calling ',(0,r.kt)("inlineCode",{parentName:"p"},"toInt")," is a side effecting operation because it will throw ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException"),' exception. So in the previous example, if we enter a non-integer number, e.g. "five", it will die because of a ',(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException")," defect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'Please enter a number: five\ntimestamp=2022-03-17T14:01:33.323639073Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.NumberFormatException: For input string: "five"\n    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n    at java.base/java.lang.Integer.parseInt(Integer.java:660)\n    at java.base/java.lang.Integer.parseInt(Integer.java:778)\n    at scala.collection.StringOps$.toInt$extension(StringOps.scala:910)\n    at MainApp$.$anonfun$myApp$3(MainApp.scala:7)\n    at MainApp$.$anonfun$myApp$3$adapted(MainApp.scala:7)\n    at zio.ZIO.$anonfun$map$1(ZIO.scala:1168)\n    at zio.ZIO$FlatMap.apply(ZIO.scala:6182)\n    at zio.ZIO$FlatMap.apply(ZIO.scala:6171)\n    at zio.internal.FiberContext.runUntil(FiberContext.scala:885)\n    at zio.internal.FiberContext.run(FiberContext.scala:115)\n    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)\n    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)\n    at java.base/java.lang.Thread.run(Thread.java:831)\n    at zio.internal.FiberContext.runUntil(FiberContext.scala:538)\n    at <empty>.MainApp.myApp(MainApp.scala:8)\n    at <empty>.MainApp.myApp(MainApp.scala:9)"\n')),(0,r.kt)("p",null,"We can see that the error channel of ",(0,r.kt)("inlineCode",{parentName:"p"},"myApp")," is typed as ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),", so it's not an exceptional error. If we want typed effects, this behavior is not intended. So instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#map")," we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"mapAttempt")," combinator which is a safe map operator that translates all thrown exceptions into typed exceptional effect."),(0,r.kt)("p",null,"To prevent converting exceptions to defects, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#mapAttempt")," which converts any exceptions to exceptional effects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval result: ZIO[Any, Throwable, Int] =\n  Console.readLine.orDie.mapAttempt(_.toInt)\n")),(0,r.kt)("p",null,"Having typed errors helps us to catch errors explicitly and handle them in the right way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, Nothing, Unit] =\n    Console.print("Please enter a number: ").orDie *>\n      Console.readLine.orDie\n        .mapAttempt(_.toInt)\n        .map(_ % 2 == 0)\n        .flatMap {\n          case true =>\n            Console.printLine("You have entered an even number.").orDie\n          case false =>\n            Console.printLine("You have entered an odd number.").orDie\n        }.catchAll(_ => myApp)\n\n  def run = myApp\n}\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#mapBoth")),"\u2014 It takes two map functions, one for the error channel and the other for the success channel, and maps both sides of a ZIO effect:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def mapBoth[E2, B](f: E => E2, g: A => B): ZIO[R, E2, B]\n}\n")),(0,r.kt)("p",null,"Here is a simple example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval result: ZIO[Any, String, Int] =\n  Console.readLine.orDie.mapAttempt(_.toInt).mapBoth(\n    _ => "non-integer input",\n    n => Math.abs(n)\n  )\n')),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#flatMapError")),"\u2014 Unlike ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#flatMap")," the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#flatMapError")," combinator chains two effects, where the second effect is dependent on the error channel of the first effect:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def flatMapError[R1 <: R, E2](\n    f: E => ZIO[R1, Nothing, E2]\n  ): ZIO[R1, E2, A]\n}\n")),(0,r.kt)("p",null,"In the following example, we are trying to find a random prime number between 1000 and 10000. We will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#flatMapError")," to collect all errors inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"Ref")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"List[String]"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def isPrime(n: Int): Boolean =\n    if (n <= 1) false else (2 until n).forall(i => n % i != 0)\n\n  def findPrimeBetween(\n      minInclusive: Int,\n      maxExclusive: Int\n  ): ZIO[Any, List[String], Int] =\n    for {\n      errors <- Ref.make(List.empty[String])\n      number <- Random\n        .nextIntBetween(minInclusive, maxExclusive)\n        .reject {\n          case n if !isPrime(n) =>\n            s"non-prime number rejected: $n"\n        }\n        .flatMapError(error => errors.updateAndGet(_ :+ error))\n        .retryUntil(_.length >= 5)\n    } yield number\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    findPrimeBetween(1000, 10000)\n      .flatMap(prime => Console.printLine(s"found a prime number: $prime").orDie)\n      .catchAll { (errors: List[String]) =>\n        Console.printLine(\n          s"failed to find a prime number after 5 attempts:\\n  ${errors.mkString("\\n  ")}"\n        )\n      }\n      .orDie\n\n  def run = myApp\n}\n')),(0,r.kt)("h3",{id:"filtering-the-success-channel-values"},"Filtering the Success Channel Values"),(0,r.kt)("p",null,"ZIO has a variety of operators that can filter values on the success channel based on a given predicate, and if the predicate fails, we can use different strategies:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Failing the original effect (",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#filterOrFail"),")"),(0,r.kt)("li",{parentName:"ul"},"Dying the original effect (",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#filterOrDie")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#filterOrDieMessage"),")"),(0,r.kt)("li",{parentName:"ul"},"Running an alternative ZIO effect (",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#filterOrElse")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#filterOrElseWith"),")")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef getNumber: ZIO[Any, Nothing, Int] =\n  (Console.print("Please enter a non-negative number: ") *>\n    Console.readLine.mapAttempt(_.toInt))\n    .retryUntil(!_.isInstanceOf[NumberFormatException]).orDie\n\nval r1: ZIO[Any, String, Int] =\n  Random.nextInt.filterOrFail(_ >= 0)("random number is negative")\n\nval r2: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrDie(_ >= 0)(\n    new IllegalArgumentException("random number is negative")\n  )\n\nval r3: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrDieMessage(_ >= 0)("random number is negative")\n\nval r4: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrElse(_ >= 0)(getNumber)\n\nval r5: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrElseWith(_ >= 0)(x => ZIO.succeed(-x))\n')),(0,r.kt)("h3",{id:"tapping-errors"},"Tapping Errors"),(0,r.kt)("p",null,"Like ",(0,r.kt)("a",{parentName:"p",href:"/references/core/zio/#tapping"},"tapping for success values")," ZIO has several operators for tapping error values. So we can peek into failures or underlying defects or causes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def tapError[R1 <: R, E1 >: E](f: E => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapErrorCause[R1 <: R, E1 >: E](f: Cause[E] => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapErrorTrace[R1 <: R, E1 >: E](f: ((E, Trace)) => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapDefect[R1 <: R, E1 >: E](f: Cause[Nothing] => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapBoth[R1 <: R, E1 >: E](f: E => ZIO[R1, E1, Any], g: A => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapEither[R1 <: R, E1 >: E](f: Either[E, A] => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n}\n")),(0,r.kt)("p",null,"Let's try an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, NumberFormatException, Int] =\n    Console.readLine\n      .mapAttempt(_.toInt)\n      .refineToOrDie[NumberFormatException]\n      .tapError { e =>\n        ZIO.debug(s"user entered an invalid input: ${e}").when(e.isInstanceOf[NumberFormatException])\n      }\n\n  def run = myApp\n}\n')),(0,r.kt)("h3",{id:"putting-errors-into-success-channel-and-submerging-them-back-again"},"Putting Errors Into Success Channel and Submerging Them Back Again"),(0,r.kt)("p",null,"Before taking into ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#either")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#absolve"),", let's see their signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def either(implicit ev: CanFail[E]): URIO[R, Either[E, A]]\n  def absolve[E1 >: E, B](implicit ev: A IsSubtypeOfOutput Either[E1, B]): ZIO[R, E1, B]\n}\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#either")),"\u2014 The ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#either")," convert a ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO[R, E, A]")," effect to another effect in which its failure (",(0,r.kt)("inlineCode",{parentName:"li"},"E"),") and success (",(0,r.kt)("inlineCode",{parentName:"li"},"A"),") channel have been lifted into an ",(0,r.kt)("inlineCode",{parentName:"li"},"Either[E, A]")," data type as success channel of the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO")," data type:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval age: Int = ???\n\nval res: URIO[Any, Either[AgeValidationException, Int]] = validate(age).either\n")),(0,r.kt)("p",null,"The resulting effect is an unexceptional effect and cannot fail, because the failure case has been exposed as part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," success case. The error parameter of the returned ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),", since it is guaranteed the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," effect does not model failure."),(0,r.kt)("p",null,"This method is useful for recovering from ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," effects that may fail:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.io.IOException\n\nval myApp: ZIO[Any, IOException, Unit] =\n  for {\n    _ <- Console.print("Please enter your age: ")\n    age <- Console.readLine.map(_.toInt)\n    res <- validate(age).either\n    _ <- res match {\n      case Left(error) => ZIO.debug(s"validation failed: $error")\n      case Right(age) => ZIO.debug(s"The $age validated!")\n    }\n  } yield ()\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#absolve"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO.absolve")),"\u2014 The ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#abolve")," operator and the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.absolve")," constructor perform the inverse. They submerge the error case of an ",(0,r.kt)("inlineCode",{parentName:"li"},"Either")," into the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval age: Int = ???\nvalidate(age) // ZIO[Any, AgeValidationException, Int]\n  .either     // ZIO[Any, Either[AgeValidationException, Int]]\n  .absolve    // ZIO[Any, AgeValidationException, Int]\n")),(0,r.kt)("p",null,"Here is another example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef sqrt(input: ZIO[Any, Nothing, Double]): ZIO[Any, String, Double] =\n  ZIO.absolve(\n    input.map { value =>\n      if (value < 0.0)\n        Left("Value must be >= 0.0")\n      else\n        Right(Math.sqrt(value))\n    }\n  )\n')),(0,r.kt)("h3",{id:"converting-defects-to-failures"},"Converting Defects to Failures"),(0,r.kt)("p",null,"Both ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#resurrect")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#absorb")," are symmetrical opposite of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#orDie")," operator. The ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#orDie")," takes failures from the error channel and converts them into defects, whereas the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#absorb")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#resurrect")," take defects and convert them into failures:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def absorb(implicit ev: E IsSubtypeOfError Throwable): ZIO[R, Throwable, A]\n  def absorbWith(f: E => Throwable): ZIO[R, Throwable, A]\n  def resurrect(implicit ev1: E IsSubtypeOfError Throwable): ZIO[R, Throwable, A]\n}\n")),(0,r.kt)("p",null,"Below are examples of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#absorb")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#resurrect")," operators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval effect1 =\n  ZIO.fail(new IllegalArgumentException("wrong argument"))  // ZIO[Any, IllegalArgumentException, Nothing]\n    .orDie                                                  // ZIO[Any, Nothing, Nothing]\n    .absorb                                                 // ZIO[Any, Throwable, Nothing]\n    .refineToOrDie[IllegalArgumentException]                // ZIO[Any, IllegalArgumentException, Nothing]                // ZIO[Any, IllegalArgumentException, Nothing]\n\nval effect2 =\n  ZIO.fail(new IllegalArgumentException("wrong argument"))  // ZIO[Any, IllegalArgumentException , Nothing]\n    .orDie                                                  // ZIO[Any, Nothing, Nothing]\n    .resurrect                                              // ZIO[Any, Throwable, Nothing]\n    .refineToOrDie[IllegalArgumentException]                // ZIO[Any, IllegalArgumentException, Nothing]\n')),(0,r.kt)("p",null,"So what is the difference between ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#absorb")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#resurrect")," operators?"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#absorb")," can recover from both ",(0,r.kt)("inlineCode",{parentName:"p"},"Die")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Interruption")," causes. Using this operator we can absorb failures, defects and interruptions using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#absorb")," operation. It attempts to convert all causes into a failure, throwing away all information about the cause of the error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val effect1 =\n    ZIO.dieMessage("Boom!") // ZIO[Any, Nothing, Nothing]\n      .absorb               // ZIO[Any, Throwable, Nothing]\n      .ignore\n  val effect2 =\n    ZIO.interrupt           // ZIO[Any, Nothing, Nothing]\n      .absorb               // ZIO[Any, Throwable, Nothing]\n      .ignore\n\n  def run =\n    (effect1 <*> effect2)\n      .debug("application exited successfully")\n}\n')),(0,r.kt)("p",null,"The output would be as below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"application exited successfully: ()\n")),(0,r.kt)("p",null,"Whereas, the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#resurrect")," will only recover from ",(0,r.kt)("inlineCode",{parentName:"p"},"Die")," causes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val effect1 =\n    ZIO\n      .dieMessage("Boom!") // ZIO[Any, Nothing, Nothing]\n      .resurrect           // ZIO[Any, Throwable, Nothing]\n      .ignore\n  val effect2 =\n    ZIO.interrupt          // ZIO[Any, Nothing, Nothing]\n      .resurrect           // ZIO[Any, Throwable, Nothing]\n      .ignore\n\n  def run =\n    (effect1 <*> effect2)\n      .debug("couldn\'t recover from fiber interruption")\n}\n')),(0,r.kt)("p",null,"And, here is the output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-02-18T14:21:52.559872464Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.InterruptedException: Interrupted by thread "zio-fiber-"\n    at <empty>.MainApp.effect2(MainApp.scala:10)\n    at <empty>.MainApp.effect2(MainApp.scala:11)\n    at <empty>.MainApp.effect2(MainApp.scala:12)\n    at <empty>.MainApp.run(MainApp.scala:15)\n    at <empty>.MainApp.run(MainApp.scala:16)"\n')),(0,r.kt)("h3",{id:"error-refinement"},"Error Refinement"),(0,r.kt)("p",null,"ZIO has some operators useful for converting defects into failures. So we can take part in non-recoverable errors and convert them into the typed error channel and vice versa."),(0,r.kt)("p",null,"Note that both ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#refine*")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#unrefine*")," do not alter the error behavior, but only change the error model. That is to say, if an effect fails or die, then after ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#refine*")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#unrefine*"),", it will still fail or die; and if an effect succeeds, then after ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#refine*")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#unrefine*"),", it will still succeed; only the manner in which it signals the error will be altered by these two methods:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#refine*")," pinches off a piece of ",(0,r.kt)("em",{parentName:"li"},"failure")," of type ",(0,r.kt)("inlineCode",{parentName:"li"},"E"),", and converts it into a ",(0,r.kt)("em",{parentName:"li"},"defect"),"."),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#unrefine*")," pinches off a piece of a ",(0,r.kt)("em",{parentName:"li"},"defect"),", and converts it into a ",(0,r.kt)("em",{parentName:"li"},"failure")," of type ",(0,r.kt)("inlineCode",{parentName:"li"},"E"),".")),(0,r.kt)("h4",{id:"refining"},"Refining"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#refineToOrDie")),"\u2014 This operator ",(0,r.kt)("strong",{parentName:"li"},"narrows")," down the type of the error channel from ",(0,r.kt)("inlineCode",{parentName:"li"},"E")," to the ",(0,r.kt)("inlineCode",{parentName:"li"},"E1"),". It leaves the rest errors untyped, so everything that doesn't fit is turned into a defect. So it makes the error space ",(0,r.kt)("strong",{parentName:"li"},"smaller"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO[-R, +E, +A] {\n  def refineToOrDie[E1 <: E]: ZIO[R, E1, A]\n}\n")),(0,r.kt)("p",null,"In the following example, we are going to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"parseInt")," by importing ",(0,r.kt)("inlineCode",{parentName:"p"},"String#toInt")," code from the standard scala library using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#attempt")," and then refining the error channel from ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException")," error type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.attempt(input.toInt)                 // ZIO[Any, Throwable, Int]\n    .refineToOrDie[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n")),(0,r.kt)("p",null,"In this example, if the ",(0,r.kt)("inlineCode",{parentName:"p"},"input.toInt")," throws any other exceptions other than ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException"),", e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexOutOfBoundsException"),", will be translated to the ZIO defect."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#refineOrDie")),"\u2014 It is the more powerful version of the previous operator. Instead of refining to one specific error type, we can refine to multiple error types using a partial function:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def refineOrDie[E1](pf: PartialFunction[E, E1]): ZIO[R, E1, A]\n}\n")),(0,r.kt)("p",null,"In the following example, we excluded the ",(0,r.kt)("inlineCode",{parentName:"p"},"Baz")," exception from recoverable errors, so it will be converted to a defect. In another word, we narrowed ",(0,r.kt)("inlineCode",{parentName:"p"},"DomainError")," down to just ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Bar")," errors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nsealed abstract class DomainError(msg: String)\n  extends Exception(msg)\n    with Serializable\n    with Product\ncase class Foo(msg: String) extends DomainError(msg)\ncase class Bar(msg: String) extends DomainError(msg)\ncase class Baz(msg: String) extends DomainError(msg)\n\nobject MainApp extends ZIOAppDefault {\n  val effect: ZIO[Any, DomainError, Unit] =\n    ZIO.fail(Baz("Oh uh!"))\n\n  val refined: ZIO[Any, DomainError, Unit] =\n    effect.refineOrDie {\n      case foo: Foo => foo\n      case bar: Bar => bar\n    }\n\n  def run = refined.catchAll(_ => ZIO.unit).debug\n}\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#refineOrDieWith")),"\u2014 In the two previous refine combinators, we were dealing with exceptional effects whose error channel type was ",(0,r.kt)("inlineCode",{parentName:"li"},"Throwable")," or a subtype of that. The ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#refineOrDieWith")," operator is a more powerful version of refining operators. It can work with any exceptional effect whether they are ",(0,r.kt)("inlineCode",{parentName:"li"},"Throwable")," or not. When we narrow down the failure space, some failures become defects. To convert those failures to defects, it takes a function from ",(0,r.kt)("inlineCode",{parentName:"li"},"E")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"Throwable"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def refineOrDieWith[E1](pf: PartialFunction[E, E1])(f: E => Throwable): ZIO[R, E1, A]\n}\n")),(0,r.kt)("p",null,"In the following example, we excluded the ",(0,r.kt)("inlineCode",{parentName:"p"},"BazError")," from recoverable errors, so it will be converted to a defect. In another word, we narrowed the whole space of ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),' errors down to just "FooError" and "BarError":'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def effect(i: String): ZIO[Any, String, Nothing] = {\n    if (i == "foo") ZIO.fail("FooError")\n    else if (i == "bar") ZIO.fail("BarError")\n    else ZIO.fail("BazError")\n  }\n\n  val refined: ZIO[Any, String, Nothing] =\n    effect("baz").refineOrDieWith {\n      case "FooError" | "BarError" => "Oh Uh!"\n    }(e => new Throwable(e))\n\n  def run = refined.catchAll(_ => ZIO.unit)\n}\n')),(0,r.kt)("h4",{id:"unrefining"},"Unrefining"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#unrefineTo[E1 >: E]")),"\u2014 This operator ",(0,r.kt)("strong",{parentName:"li"},"broadens")," the type of the error channel from ",(0,r.kt)("inlineCode",{parentName:"li"},"E")," to the ",(0,r.kt)("inlineCode",{parentName:"li"},"E1")," and embeds some defects into it. So it is going from some fiber failures back to errors and thus making the error type ",(0,r.kt)("strong",{parentName:"li"},"larger"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def unrefineTo[E1 >: E]: ZIO[R, E1, A]\n}\n")),(0,r.kt)("p",null,"In the following example, we are going to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"parseInt")," by importing ",(0,r.kt)("inlineCode",{parentName:"p"},"String#toInt")," code from the standard scala library using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#succeed")," and then unrefining the error channel from ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException")," error type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.succeed(input.toInt)              // ZIO[Any, Nothing, Int]\n    .unrefineTo[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#unrefine")),"\u2014 It is a more powerful version of the previous operator. It takes a partial function from ",(0,r.kt)("inlineCode",{parentName:"li"},"Throwable")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"E1")," and converts those defects to recoverable errors:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def unrefine[E1 >: E](pf: PartialFunction[Throwable, E1]): ZIO[R, E1, A]\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class Foo(msg: String) extends Throwable(msg)\ncase class Bar(msg: String) extends Throwable(msg)\ncase class Baz(msg: String) extends Throwable(msg)\n\nobject MainApp extends ZIOAppDefault {\n  def unsafeOpThatMayThrows(i: String): String =\n    if (i == "foo")\n      throw Foo("Oh uh!")\n    else if (i == "bar")\n      throw Bar("Oh Error!")\n    else if (i == "baz")\n      throw Baz("Oh no!")\n    else i\n\n  def effect(i: String): ZIO[Any, Nothing, String] =\n    ZIO.succeed(unsafeOpThatMayThrows(i))\n\n  val unrefined: ZIO[Any, Foo, String] =\n    effect("foo").unrefine { case e: Foo => e }\n\n  def run = unrefined.catchAll(_ => ZIO.unit)\n}\n')),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#unrefine")," we can have more control to unrefine a ZIO effect that may die because of some defects, for example in the following example we are going to convert both ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Bar")," defects to recoverable errors and remain ",(0,r.kt)("inlineCode",{parentName:"p"},"Baz")," unrecoverable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val unrefined: ZIO[Any, Throwable, String] =\n  effect("foo").unrefine {\n    case e: Foo => e\n    case e: Bar => e\n  }\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#unrefineWith")),"- This is the most powerful version of unrefine operators. It takes a partial function, as the previous operator, and then tries to broaden the failure space by converting some of the defects to typed recoverable errors. If it doesn't find any defect, it will apply the ",(0,r.kt)("inlineCode",{parentName:"li"},"f")," which is a function from ",(0,r.kt)("inlineCode",{parentName:"li"},"E")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"E1"),", and map all typed errors using this function:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def unrefineWith[E1](pf: PartialFunction[Throwable, E1])(f: E => E1): ZIO[R, E1, A]\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  case class Foo(msg: String) extends Exception(msg)\n  case class Bar(msg: String) extends Exception(msg)\n\n  val effect: ZIO[Any, Foo, Nothing] =\n    ZIO.ifZIO(Random.nextBoolean)(\n      onTrue = ZIO.fail(Foo("Oh uh!")),\n      onFalse = ZIO.die(Bar("Boom!"))\n    )\n\n  val unrefined: ZIO[Any, String, Nothing] =\n    effect\n      .unrefineWith {\n        case e: Bar => e.getMessage\n      }(e => e.getMessage)\n\n  def run = unrefined.cause.debug\n}\n')),(0,r.kt)("h3",{id:"converting-option-on-values-to-option-on-errors-and-vice-versa"},"Converting Option on Values to Option on Errors and Vice Versa"),(0,r.kt)("p",null,"We can extract a value from a Some using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#some")," and then we can unsome it again using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#unsome"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.attempt(Option("something")) // ZIO[Any, Throwable, Option[String]]\n  .some                          // ZIO[Any, Option[Throwable], String]\n  .unsome                        // ZIO[Any, Throwable, Option[String]]\n')),(0,r.kt)("h3",{id:"flattening-optional-error-types"},"Flattening Optional Error Types"),(0,r.kt)("p",null,"If we have an optional error of type ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," in the error channel, we can flatten it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," type using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#flattenErrorOption")," operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef parseInt(input: String): ZIO[Any, Option[String], Int] =\n  if (input.isEmpty)\n    ZIO.fail(Some("empty input"))\n  else\n    try {\n      ZIO.succeed(input.toInt)\n    } catch {\n      case _: NumberFormatException => ZIO.fail(None)\n    }\n\ndef flattenedParseInt(input: String): ZIO[Any, String, Int] =\n  parseInt(input).flattenErrorOption("non-numeric input")\n\nval r1: ZIO[Any, String, Int] = flattenedParseInt("zero")\nval r2: ZIO[Any, String, Int] = flattenedParseInt("")\nval r3: ZIO[Any, String, Int] = flattenedParseInt("123")\n')),(0,r.kt)("h3",{id:"merging-the-error-channel-into-the-success-channel"},"Merging the Error Channel into the Success Channel"),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#merge")," we can merge the error channel into the success channel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval merged : ZIO[Any, Nothing, String] =\n  ZIO.fail("Oh uh!") // ZIO[Any, String, Nothing]\n    .merge           // ZIO[Any, Nothing, String]\n')),(0,r.kt)("p",null,"If the error and success channels were of different types, it would choose the supertype of both."),(0,r.kt)("h3",{id:"flipping-the-error-and-success-channels"},"Flipping the Error and Success Channels"),(0,r.kt)("p",null,"Sometimes, we would like to apply some methods on the error channel which are specific for the success channel, or we want to apply some methods on the success channel which are specific for the error channel. Therefore, we can flip the error and success channel and before flipping back, we can perform the right operator on flipped channels:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def flip: ZIO[R, A, E]\n  def flipWith[R1, A1, E1](f: ZIO[R, A, E] => ZIO[R1, A1, E1]): ZIO[R1, E1, A1]\n}\n")),(0,r.kt)("p",null,"Assume we have the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval evens: ZIO[Any, List[String], List[Int]] =\n  ZIO.validate(List(1, 2, 3, 4, 5)) { n =>\n    if (n % 2 == 0)\n      ZIO.succeed(n)\n    else\n      ZIO.fail(s"$n is not even")\n  }\n')),(0,r.kt)("p",null,"We want to reverse the order of errors. In order to do that instead of using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#mapError"),", we can map the error channel by using flip operators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval r1: ZIO[Any, List[String], List[Int]] = evens.mapError(_.reverse)\nval r2: ZIO[Any, List[String], List[Int]] = evens.flip.map(_.reverse).flip\nval r3: ZIO[Any, List[String], List[Int]] = evens.flipWith(_.map(_.reverse))\n")),(0,r.kt)("h3",{id:"rejecting-some-success-values"},"Rejecting Some Success Values"),(0,r.kt)("p",null,"We can reject some success values using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#reject")," operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def reject[E1 >: E](pf: PartialFunction[A, E1]): ZIO[R, E1, A]\n\n  def rejectZIO[R1 <: R, E1 >: E](\n    pf: PartialFunction[A, ZIO[R1, E1, E1]]\n  ): ZIO[R1, E1, A]\n}\n")),(0,r.kt)("p",null,"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"PartialFunction")," matches, it will reject that success value and convert that to a failure, otherwise it will continue with the original success value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval myApp: ZIO[Any, String, Int] =\n  Random\n    .nextIntBounded(20)\n    .reject {\n      case n if n % 2 == 0 => s"even number rejected: $n"\n      case 5               => "number 5 was rejected"\n    }\n    .debug\n')),(0,r.kt)("h3",{id:"zoom-inout-on-left-or-right-side-of-an-either-value"},"Zoom in/out on Left or Right Side of An Either Value"),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," ZIO values, we can zoom in or out on the left or right side of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),", as well as we can do the inverse and zoom out."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval eitherEffect: ZIO[Any, Exception, Either[String, Int]] = ???\n\neitherEffect // ZIO[Any, Exception, Either[String, Int]]\n  .left      // ZIO[Any, Either[Exception, Int], String]\n  .unleft    // ZIO[Any, Exception, Either[String, Int]]    // ZIO[Any, Exception, Either[String, Int]]\n\neitherEffect // ZIO[Any, Exception, Either[String, Int]]\n  .right     // ZIO[Any, Either[String, Exception], Int]\n  .unright   // ZIO[Any, Exception, Either[String, Int]]\n")),(0,r.kt)("h3",{id:"converting-optional-values-to-optional-errors-and-vice-versa"},"Converting Optional Values to Optional Errors and Vice Versa"),(0,r.kt)("p",null,"Assume we have the following effect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval nextRandomEven: ZIO[Any, String, Option[Int]] =\n  Random.nextInt\n    .reject {\n      case n if n < 0 => s"$n is negative!"\n    }\n    .map{\n      case n if n % 2 == 0 => Some(n)\n      case _               => None\n    }\n')),(0,r.kt)("p",null,"Now we can convert this effect which is optional on the success channel to an effect that is optional on the error channel using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#some")," operator and also the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#unsome")," to reverse this conversion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"nextRandomEven // ZIO[Any, String, Option[Int]]\n  .some        // ZIO[Any, Option[String], Int]\n  .unsome      // ZIO[Any, String, Option[Int]]\n")),(0,r.kt)("p",null,"Sometimes instead of converting optional values to optional errors, we can perform one of the following operations:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#someOrElse")),"\u2014 Extract the optional value if it is not empty or return the given default:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval getEnv: ZIO[Any, Nothing, Option[String]] = ???\n\nval result: ZIO[Any, Nothing, String] =\n  getEnv.someOrElse("development")\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#someOrElseZIO")),"\u2014 Like the ",(0,r.kt)("inlineCode",{parentName:"li"},"ZIO#someOrElse")," but the effectful version:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Config\n\nval list: List[Config] = ???\n\nval getCurrentConfig: ZIO[Any, Nothing, Option[Config]] = ZIO.succeed(list.headOption)\nval getRemoteConfig : ZIO[Any, Throwable, Config]       = ZIO.attempt(new Config {})\n\nval config: ZIO[Any, Throwable, Config] =\n  getCurrentConfig.someOrElseZIO(getRemoteConfig)\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"ZIO#someOrFail")),"\u2014 It converts the ZIO effect of an optional value to an exceptional effect:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef head(list: List[Int]): ZIO[Any, NoSuchElementException, Int] =\n  ZIO\n    .succeed(list.headOption)\n    .someOrFail(new NoSuchElementException("empty list"))\n')),(0,r.kt)("p",null,"In the above example, we can also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#someOrFailException")," which will directly convert the unexceptional effect to the exceptional effect with the error type of ",(0,r.kt)("inlineCode",{parentName:"p"},"NoSuchElementException"),"."),(0,r.kt)("h3",{id:"uncovering-the-underlying-cause-of-an-effect"},"Uncovering the Underlying Cause of an Effect"),(0,r.kt)("p",null,"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#cause")," operation we can expose the cause, and then by using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#uncause")," we can reverse this operation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIO[-R, +E, +A] {\n  def cause: URIO[R, Cause[E]]\n  def uncause[E1 >: E](implicit ev: A IsSubtypeOfOutput Cause[E1]): ZIO[R, E1, Unit]\n}\n")),(0,r.kt)("p",null,"In the following example, we expose and then untrace the underlying cause:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val f1: ZIO[Any, String, Int] =\n    ZIO.fail("Oh uh!").as(1)\n\n  val f2: ZIO[Any, String, Int] =\n    ZIO.fail("Oh error!").as(2)\n\n  val myApp: ZIO[Any, String, (Int, Int)] = f1 zipPar f2\n\n  def run = myApp.cause.map(_.untraced).debug\n}\n')),(0,r.kt)("p",null,"Sometimes the ",(0,r.kt)("a",{parentName:"p",href:"#map-and-flatmap-on-error-channel"},(0,r.kt)("inlineCode",{parentName:"a"},"ZIO#mapErrorCause"))," operator is a better choice when we just want to map the underlying cause without exposing the cause."),(0,r.kt)("h2",{id:"best-practices"},"Best Practices"),(0,r.kt)("h3",{id:"model-domain-errors-using-algebraic-data-types"},"Model Domain Errors Using Algebraic Data Types"),(0,r.kt)("p",null,"It is best to use ",(0,r.kt)("em",{parentName:"p"},"algebraic data types (ADTs)")," when modeling errors within the same domain or subdomain."),(0,r.kt)("p",null,"Sealed traits allow us to introduce an error type as a common supertype and all errors within a domain are part of that error type by extending that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait UserServiceError extends Exception\n\ncase class InvalidUserId(id: ID) extends UserServiceError\ncase class ExpiredAuth(id: ID)   extends UserServiceError\n")),(0,r.kt)("p",null,"In this case, the super error type is ",(0,r.kt)("inlineCode",{parentName:"p"},"UserServiceError"),". We sealed that trait, and we extend it by two cases, ",(0,r.kt)("inlineCode",{parentName:"p"},"InvalidUserId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ExpiredAuth"),". Because it is sealed, if we have a reference to a ",(0,r.kt)("inlineCode",{parentName:"p"},"UserServiceError")," we can match against it and the Scala compiler knows there are two possibilities for a ",(0,r.kt)("inlineCode",{parentName:"p"},"UserServiceError"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"userServiceError match {\n  case InvalidUserId(id) => ???\n  case ExpiredAuth(id)   => ???\n}\n")),(0,r.kt)("p",null,"This is a sum type, and also an enumeration. The Scala compiler knows only two of these ",(0,r.kt)("inlineCode",{parentName:"p"},"UserServiceError")," exist. If we don't match on all of them, it is going to warn us. We can add the ",(0,r.kt)("inlineCode",{parentName:"p"},"-Xfatal-warnings")," compiler option which treats warnings as errors. By turning on the fatal warning, we will have type-safety control on expected errors. So sealing these traits gives us great power."),(0,r.kt)("p",null,"Also extending all of our errors from a common supertype helps the ZIO's combinators like flatMap to auto widen to the most specific error type."),(0,r.kt)("p",null,"Let's say we have this for-comprehension here that calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"userAuth")," function, and it can fail with ",(0,r.kt)("inlineCode",{parentName:"p"},"ExpiredAuth"),", and then we call ",(0,r.kt)("inlineCode",{parentName:"p"},"userProfile")," that fails with ",(0,r.kt)("inlineCode",{parentName:"p"},"InvalidUserID"),", and then we call ",(0,r.kt)("inlineCode",{parentName:"p"},"generateEmail")," that can't fail at all, and finally we call ",(0,r.kt)("inlineCode",{parentName:"p"},"sendEmail")," which can fail with ",(0,r.kt)("inlineCode",{parentName:"p"},"EmailDeliveryError"),". We have got a lot of different errors here:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val myApp: IO[Exception, Receipt] =\n  for {\n    service <- userAuth(token)                // IO[ExpiredAuth, UserService]\n    profile <- service.userProfile(userId)    // IO[InvalidUserId, Profile]\n    body    <- generateEmail(orderDetails)    // IO[Nothing, String]\n    receipt <- sendEmail("Your order detail",\n       body, profile.email)                   // IO[EmailDeliveryError, Unit]\n  } yield receipt\n')),(0,r.kt)("p",null,"In this example, the flatMap operations auto widens the error type to the most specific error type possible. As a result, the inferred error type of this for-comprehension will be ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception")," which gives us the best information we could hope to get out of this. We have lost information about the particulars of this. We no longer know which of these error types it is. We know it is some type of ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception")," which is more information than nothing."),(0,r.kt)("h3",{id:"use-union-types-to-be-more-specific-about-error-types"},"Use Union Types to Be More Specific About Error Types"),(0,r.kt)("p",null,"In Scala 3, we have an exciting new feature called union types. By using the union operator, we can encode multiple error types. Using this facility, we can have more precise information on typed errors."),(0,r.kt)("p",null,"Let's see an example of ",(0,r.kt)("inlineCode",{parentName:"p"},"Storage")," service which have ",(0,r.kt)("inlineCode",{parentName:"p"},"upload"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"download")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"delete")," api:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntype Name = String\n\nenum StorageError extends Exception {\n  case ObjectExist(name: Name)            extends StorageError\n  case ObjectNotExist(name: Name)         extends StorageError\n  case PermissionDenied(cause: String)    extends StorageError\n  case StorageLimitExceeded(limit: Int)   extends StorageError\n  case BandwidthLimitExceeded(limit: Int) extends StorageError\n}\n\nimport StorageError.*\n\ntrait Storage {\n  def upload(\n      name: Name,\n      obj: Array[Byte]\n  ): ZIO[Any, ObjectExist | StorageLimitExceeded, Unit]\n\n  def download(\n      name: Name\n  ): ZIO[Any, ObjectNotExist | BandwidthLimitExceeded, Array[Byte]]\n\n  def delete(name: Name): ZIO[Any, ObjectNotExist | PermissionDenied, Unit]\n}\n")),(0,r.kt)("p",null,"Union types allow us to get rid of the requirement to extend some sort of common error types like ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),". This allows us to have completely unrelated error types."),(0,r.kt)("p",null,"In the following example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"FooError")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BarError")," are two distinct error. They have no super common type like ",(0,r.kt)("inlineCode",{parentName:"p"},"FooBarError")," and also they are not extending ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," classes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.*\n\n// Two unrelated errors without having a common supertype\ntrait FooError\ntrait BarError\n\ndef foo: IO[FooError, Nothing] = ZIO.fail(new FooError {})\ndef bar: IO[BarError, Nothing] = ZIO.fail(new BarError {})\n\nval myApp: ZIO[Any, FooError | BarError, Unit] = for {\n  _ <- foo\n  _ <- bar\n} yield ()\n")),(0,r.kt)("h3",{id:"dont-type-unexpected-errors"},"Don't Type Unexpected Errors"),(0,r.kt)("p",null,"When we first discover typed errors, it may be tempting to put every error into the error type parameter. That is a mistake because we can't recover from all types of errors. When we encounter unexpected errors we can't do anything in those cases. We should let the application die. Let it crash is the erlang philosophy. It is a good philosophy for all unexpected errors. At best, we can sandbox it, but we should let it crash."),(0,r.kt)("p",null,"The context of a domain determines whether an error is expected or unexpected. When using typed errors, sometimes it is necessary to make a typed-error un-typed because in that case, we can't handle the error, and we should let the application crash."),(0,r.kt)("p",null,"For example, in the following example, we don't want to handle the ",(0,r.kt)("inlineCode",{parentName:"p"},"IOException")," so we can call ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#orDie")," to make the effect's failure unchecked. This will translate effect's failure to the death of the fiber running it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nConsole.printLine("Hello, World") // ZIO[Any, IOException, Unit]\n  .orDie                          // ZIO[Any, Nothing, Unit]\n')),(0,r.kt)("p",null,"If we have an effect that fails for some ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," we can pick certain recoverable errors out of that, and then we can just let the rest of them kill the fiber that is running that effect. The ZIO effect has a method called ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#refineOrDie")," that allows us to do that."),(0,r.kt)("p",null,"In the following example, calling ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#refineOrDie")," on an effect that has an error type ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," allows us to refine it to have an error type of ",(0,r.kt)("inlineCode",{parentName:"p"},"TemporaryUnavailable"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval response: ZIO[Any, Nothing, Response] =\n  ZIO\n    .attemptBlocking(\n      httpClient.fetchUrl(url)\n    ) // ZIO[Any, Throwable, Response]\n    .refineOrDie[TemporaryUnavailable] {\n      case e: TemporaryUnavailable => e\n    } // ZIO[Any, TemporaryUnavailable, Response]\n    .retry(\n      Schedule.fibonacci(1.second)\n    ) // ZIO[Any, TemporaryUnavailable, Response]\n    .orDie // ZIO[Any, Nothing, Response]\n")),(0,r.kt)("p",null,"In this example, we are importing the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchUrl")," which is a blocking operation into a ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," value. We know that in case of a service outage it will throw the ",(0,r.kt)("inlineCode",{parentName:"p"},"TemporaryUnavailable")," exception. This is an expected error, so we want that to be typed. We are going to reflect that in the error type. We only expect it, so we know how to recover from it."),(0,r.kt)("p",null,"Also, this operation may throw unexpected errors like ",(0,r.kt)("inlineCode",{parentName:"p"},"OutOfMemoryError"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"StackOverflowError"),", and so forth. Therefore, we don't include these errors since we won't be handling them at runtime. They are defects, and in case of unexpected errors, we should let the application crash."),(0,r.kt)("p",null,"Therefore, it is quite common to import a code that may throw exceptions, whether that uses expected errors for error handling or can fail for a wide variety of unexpected errors like disk unavailable, service unavailable, and so on. Generally, importing these operations end up represented as a ",(0,r.kt)("inlineCode",{parentName:"p"},"Task")," (",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO[Any, Throwable, A]"),"). So in order to make recoverable errors typed, we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#refineOrDie")," method."),(0,r.kt)("h3",{id:"dont-reflexively-log-errors"},"Don't Reflexively Log Errors"),(0,r.kt)("p",null,"In modern async concurrent applications with a lot of subsystems, if we do not type errors, we are not able to see what section of our code fails with what error. Therefore, this can be very tempting to log errors when they happen. So when we lose type-safety in the whole application it makes us be more sensitive and program defensively. Therefore, whenever we are calling an API we tend to catch its errors, log them as below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nsealed trait UploadError extends Exception\ncase class FileExist(name: String)          extends UploadError\ncase class FileNotExist(name: String)       extends UploadError\ncase class StorageLimitExceeded(limit: Int) extends UploadError\n\n/**\n * This API fail with `FileExist` failure when the provided file name exist.\n */\ndef upload(name: String): Task[Unit] = {\n    if (...)\n      ZIO.fail(FileExist(name))\n    else if (...)\n      ZIO.fail(StorageLimitExceeded(limit)) // This error is undocumented unintentionally\n    else\n      ZIO.attempt(...)\n}\n\nupload("contacts.csv").catchAll {\n  case FileExist(name) => delete("contacts.csv") *> upload("contacts.csv")\n  case _ =>\n    for {\n      _ <- ZIO.log(error.toString) // logging the error\n      _ <- ZIO.fail(error) // failing again (just like rethrowing exceptions in OOP)\n    } yield ()\n}\n')),(0,r.kt)("p",null,"In the above code when we see the ",(0,r.kt)("inlineCode",{parentName:"p"},"upload"),"'s return type we can't find out what types of error it may fail with. So as a programmer we need to read the API documentation, and see in what cases it may fail. Due to the fact that the documents may be outdated and they may not provide all error cases, we tend to add another case to cover all the other errors. Expert developers may prefer to read the implementation to find out all expected errors, but it is a tedious task to do."),(0,r.kt)("p",null,"We don't want to lose any errors. So if we do not use typed errors, it makes us defensive to log every error, regardless of whether they will occur or not."),(0,r.kt)("p",null,"When we are programming with typed errors, that allows us to never lose any errors. Even if we don't handle all, the error channel of our effect type demonstrate the type of remaining errors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val myApp: ZIO[Any, UploadError, Unit] =\n  upload("contacts.csv")\n    .catchSome {\n      case FileExist(name) => delete(name) *> upload(name)\n    }\n')),(0,r.kt)("p",null,"It is still going to be sent an unhandled error type as a result. Therefore, there is no way to lose any errors, and they propagate automatically through all the different subsystems in our application, which means we don't have to be fearful anymore. It will be handled by higher-level code, or if it doesn't it will be passed off to something that can."),(0,r.kt)("p",null,"If we handle all errors using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#catchAll")," the type of error channel become ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing")," which means there is no expected error remaining to handle:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val myApp: ZIO[Any, Nothing, Unit] =\n  upload("contacts.csv")\n    .catchAll {\n      case FileExist(name) =>\n        ZIO.unit // handling FileExist error case\n      case StorageLimitExceeded(limit) =>\n        ZIO.unit // handling StorageLimitExceeded error case\n    }\n')),(0,r.kt)("p",null,"When we type errors, we know that they can't be lost. So typed errors give us the ability to log less."),(0,r.kt)("h2",{id:"debugging"},"Debugging"),(0,r.kt)("p",null,"When we are writing an application using the ZIO effect, we are writing workflows as data transformers. So there are lots of cases where we need to debug our application by seeing how the data transformed through the workflow. We can add or remove debugging capability without changing the signature of our effect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.ifZIO(\n  Random.nextIntBounded(10)\n    .debug("random number")\n    .map(_ % 2)\n    .debug("remainder")\n    .map(_ == 0)\n)(\n  onTrue = ZIO.succeed("Success"),\n  onFalse = ZIO.succeed("Failure")\n).debug.repeatWhile(_ != "Success")\n')),(0,r.kt)("p",null,"The following could be one of the results of this program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"random number: 5\nremainder: 1\nFailure\nrandom number: 1\nremainder: 1\nFailure\nrandom number: 2\nremainder: 0\nSuccess\n")),(0,r.kt)("h2",{id:"logging"},"Logging"),(0,r.kt)("p",null,"ZIO has built-in logging functionality. This allows us to log within our application without adding new dependencies. ZIO logging doesn't require any services from the environment."),(0,r.kt)("p",null,"We can easily log inside our application using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.log")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.log("Application started!")\n')),(0,r.kt)("p",null,"The output would be something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'[info] timestamp=2021-10-06T07:23:29.974297029Z level=INFO thread=#2 message="Application started!" file=ZIOLoggingExample.scala line=6 class=zio.examples.ZIOLoggingExample$ method=run\n')),(0,r.kt)("p",null,"To log with a specific log-level, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.logLevel")," combinator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logLevel(LogLevel.Warning) {\n  ZIO.log("The response time exceeded its threshold!")\n}\n')),(0,r.kt)("p",null,"Or we can use the following functions directly:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.logDebug")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.logError")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.logFatal")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.logInfo")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZIO.logWarning"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logError("File does not exist: ~/var/www/favicon.ico")\n')),(0,r.kt)("p",null,"It also supports logging spans:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logSpan("myspan") {\n  ZIO.sleep(1.second) *> ZIO.log("The job is finished!")\n}\n')),(0,r.kt)("p",null,"ZIO Logging calculates and records the running duration of the span and includes that in logging data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'[info] timestamp=2021-10-06T07:29:57.816775631Z level=INFO thread=#2 message="The job is done!" myspan=1013ms file=ZIOLoggingExample.scala line=8 class=zio.examples.ZIOLoggingExample$ method=run\n')),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Let's write an application that takes numerator and denominator from the user and then print the result back to the user:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      a <- readNumber("Enter the first number  (a): ")\n      b <- readNumber("Enter the second number (b): ")\n      r <- divide(a, b)\n      _ <- Console.printLine(s"a / b: $r")\n    } yield ()\n\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\n    Console.print(msg) *> Console.readLine.map(_.toInt)\n\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\n    if (b == 0)\n      ZIO.die(new ArithmeticException("divide by zero")) // unexpected error\n    else\n      ZIO.succeed(a / b)\n}\n')),(0,r.kt)("p",null,"Now let's try to enter the zero for the second number and see what happens:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'Please enter the first number  (a): 5\nPlease enter the second number (b): 0\ntimestamp=2022-02-14T09:39:53.981143209Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.ArithmeticException: divide by zero\nat MainApp$.$anonfun$divide$1(MainApp.scala:16)\nat zio.ZIO$.$anonfun$die$1(ZIO.scala:3384)\nat zio.internal.FiberContext.runUntil(FiberContext.scala:255)\nat zio.internal.FiberContext.run(FiberContext.scala:115)\nat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)\nat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)\nat java.base/java.lang.Thread.run(Thread.java:831)\nat <empty>.MainApp.divide(MainApp.scala:16)"\n')),(0,r.kt)("p",null,"As we see, because we entered the zero for the denominator, the ",(0,r.kt)("inlineCode",{parentName:"p"},"ArithmeticException")," defect, makes the application crash."),(0,r.kt)("p",null,"Defects are any ",(0,r.kt)("em",{parentName:"p"},"unexpected errors")," that we are not going to handle. They will propagate through our application stack until they crash the whole."),(0,r.kt)("p",null,"Defects have many roots, most of them are from a programming error. Errors will happen when we haven't written the application with best practices. For example, one of these practices is that we should validate the inputs before providing them to the ",(0,r.kt)("inlineCode",{parentName:"p"},"divide")," function. So if the user entered the zero as the denominator, we can retry and ask the user to return another number:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      a <- readNumber("Enter the first number  (a): ")\n      b <- readNumber("Enter the second number (b): ").repeatUntil(_ != 0)\n      r <- divide(a, b)\n      _ <- Console.printLine(s"a / b: $r")\n    } yield ()\n\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\n    Console.print(msg) *> Console.readLine.map(_.toInt)\n\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] = ZIO.succeed(a / b)\n}\n')),(0,r.kt)("p",null,"Another note about defects is that they are invisible, and they are not typed. We cannot expect what defects will happen by observing the typed error channel. In the above example, when we run the application and enter noninteger input, another defect, which is called ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException")," will crash the application:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'Enter the first number  (a): five\ntimestamp=2022-02-18T06:36:25.984665171Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.NumberFormatException: For input string: "five"\n    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n    at java.base/java.lang.Integer.parseInt(Integer.java:660)\n    at java.base/java.lang.Integer.parseInt(Integer.java:778)\n    at scala.collection.StringOps$.toInt$extension(StringOps.scala:910)\n    at MainApp$.$anonfun$readNumber$3(MainApp.scala:16)\n    at MainApp$.$anonfun$readNumber$3$adapted(MainApp.scala:16)\n  ...\n    at <empty>.MainApp.run(MainApp.scala:9)"\n')),(0,r.kt)("p",null,"The cause of this defect is also a programming error, which means we haven't validated input when parsing it. So let's try to validate the input, and make sure that it is a number. We know that if the entered input does not contain a parsable ",(0,r.kt)("inlineCode",{parentName:"p"},"Int")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"String#toInt")," throws the ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException")," exception. As we want this exception to be typed, we import the ",(0,r.kt)("inlineCode",{parentName:"p"},"String#toInt")," function using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.attempt")," constructor. Using this constructor the function signature would be as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ndef parseInput(input: String): ZIO[Any, Throwable, Int] =\n  ZIO.attempt(input.toInt)\n")),(0,r.kt)("p",null,"Since the ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException")," is an expected error, and we want to handle it. So we type the error channel as ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException"),"."),(0,r.kt)("p",null,"To be more specific, we would like to narrow down the error channel to the ",(0,r.kt)("inlineCode",{parentName:"p"},"NumberFormatException"),", so we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"refineToOrDie")," operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ndef parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.attempt(input.toInt)                 // ZIO[Any, Throwable, Int]\n    .refineToOrDie[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n")),(0,r.kt)("p",null,"The same result can be achieved by succeeding the ",(0,r.kt)("inlineCode",{parentName:"p"},"String#toInt")," and then widening the error channel using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#unrefineTo")," operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ndef parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.succeed(input.toInt)                 // ZIO[Any, Nothing, Int]\n    .unrefineTo[NumberFormatException]     // ZIO[Any, NumberFormatException, Int]\n")),(0,r.kt)("p",null,"Now, let's refactor the example with recent changes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      a <- readNumber("Enter the first number  (a): ")\n      b <- readNumber("Enter the second number (b): ").repeatUntil(_ != 0)\n      r <- divide(a, b)\n      _ <- Console.printLine(s"a / b: $r")\n    } yield ()\n\n  def parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\n    ZIO.attempt(input.toInt).refineToOrDie[NumberFormatException]\n\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\n    (Console.print(msg) *> Console.readLine.flatMap(parseInput))\n      .retryUntil(!_.isInstanceOf[NumberFormatException])\n      .refineToOrDie[IOException]\n\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] = ZIO.succeed(a / b)\n}\n')))}u.isMDXComponent=!0}}]);