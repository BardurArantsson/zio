"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[1694],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>s});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var p=a.createContext({}),u=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(p.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,i=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=u(t),s=l,d=m["".concat(p,".").concat(s)]||m[s]||h[s]||i;return t?a.createElement(d,r(r({ref:n},c),{},{components:t})):a.createElement(d,r({ref:n},c))}));function s(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var i=t.length,r=new Array(i);r[0]=m;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var u=2;u<i;u++)r[u]=t[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1801:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var a=t(7462),l=(t(7294),t(3905));const i={id:"zchannel",title:"ZChannel"},r=void 0,o={unversionedId:"reference/stream/zchannel",id:"reference/stream/zchannel",title:"ZChannel",description:"Channels are the nexus of communications, which support both reading and writing. They allow us to have a unidirectional flow of data from the input to the output.",source:"@site/docs/reference/stream/zchannel.md",sourceDirName:"reference/stream",slug:"/reference/stream/zchannel",permalink:"/reference/stream/zchannel",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/stream/zchannel.md",tags:[],version:"current",frontMatter:{id:"zchannel",title:"ZChannel"},sidebar:"reference-sidebar",previous:{title:"Sink",permalink:"/reference/stream/sink"},next:{title:"SubscriptionRef",permalink:"/reference/stream/subscription-ref"}},p={},u=[{value:"Creation",id:"creation",level:2},{value:"<code>ZChannel.succeed</code>",id:"zchannelsucceed",level:3},{value:"<code>ZChannel.fail</code>",id:"zchannelfail",level:3},{value:"<code>ZChannel.write*</code>",id:"zchannelwrite",level:3},{value:"<code>ZChannel.read*</code>",id:"zchannelread",level:3},{value:"Simple Echo Channel",id:"simple-echo-channel",level:4},{value:"Echo Channel Forever",id:"echo-channel-forever",level:4},{value:"Replicator Channel",id:"replicator-channel",level:4},{value:"Counter Channel",id:"counter-channel",level:4},{value:"Dedupe Channel",id:"dedupe-channel",level:4},{value:"Buffered Channel",id:"buffered-channel",level:3},{value:"Operations",id:"operations",level:2},{value:"Piping",id:"piping",level:3},{value:"Sequencing",id:"sequencing",level:3},{value:"Concatenating",id:"concatenating",level:3},{value:"Zipping",id:"zipping",level:3},{value:"Mapping",id:"mapping",level:3},{value:"Mapping The Terminal Done Value (<code>OutDone</code>)",id:"mapping-the-terminal-done-value-outdone",level:4},{value:"Mapping The Done Value of The Input Port (<code>InDone</code>)",id:"mapping-the-done-value-of-the-input-port-indone",level:4},{value:"Mapping The Error Value of The Output Port (<code>OutErr</code>)",id:"mapping-the-error-value-of-the-output-port-outerr",level:4},{value:"Mapping The Output Elements of a Channel (<code>OutElem</code>)",id:"mapping-the-output-elements-of-a-channel-outelem",level:4},{value:"Mapping The Input Elements of a Channel (<code>InElem</code>)",id:"mapping-the-input-elements-of-a-channel-inelem",level:4},{value:"Merging",id:"merging",level:3},{value:"Collecting",id:"collecting",level:3},{value:"Converting",id:"converting",level:3},{value:"Running a channel",id:"running-a-channel",level:3},{value:"Channel Interruption",id:"channel-interruption",level:3},{value:"concatMap",id:"concatmap",level:3},{value:"mergeMap",id:"mergemap",level:3},{value:"collect",id:"collect",level:3}],c={toc:u};function h(e){let{components:n,...i}=e;return(0,l.kt)("wrapper",(0,a.Z)({},c,i,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Channels are the nexus of communications, which support both reading and writing. They allow us to have a unidirectional flow of data from the input to the output. "),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel[-Env, -InErr, -InElem, -InDone, +OutErr, +OutElem, +OutDone]")," requires some environment ",(0,l.kt)("inlineCode",{parentName:"p"},"Env")," and have two main operations:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"It can read some data ",(0,l.kt)("inlineCode",{parentName:"p"},"InElem")," from the input port, and finally can terminate with a done value of type ",(0,l.kt)("inlineCode",{parentName:"p"},"InDone"),". If the read operation fails, the channel will terminate with an error of type ",(0,l.kt)("inlineCode",{parentName:"p"},"InErr"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"It can write some data ",(0,l.kt)("inlineCode",{parentName:"p"},"OutElem")," to the output port, and finally terminate the channel with a done value of type ",(0,l.kt)("inlineCode",{parentName:"p"},"OutDone"),". If the write operation fails, the channel will terminate with an error of type ",(0,l.kt)("inlineCode",{parentName:"p"},"OutErr"),"."))),(0,l.kt)("p",null,"They are an underlying abstraction for ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZPipeline"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZSink"),". In ZIO Streams, we call the input port ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream"),", the output port ",(0,l.kt)("inlineCode",{parentName:"p"},"ZSink"),", and the middle part ",(0,l.kt)("inlineCode",{parentName:"p"},"ZPipeline"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," can write some elements to the ",(0,l.kt)("em",{parentName:"p"},"output"),", and it can terminate with some sort of ",(0,l.kt)("em",{parentName:"p"},"done")," value. The ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," uses this ",(0,l.kt)("em",{parentName:"p"},"done")," value to notify the downstream ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," that its emission of elements is finished. In ZIO, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream")," is encoded as an output side of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," can read from its input, and it can also terminate with some sort of ",(0,l.kt)("em",{parentName:"p"},"done")," value, which is an upstream result. So a ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," has the ",(0,l.kt)("em",{parentName:"p"},"input type"),", and the ",(0,l.kt)("em",{parentName:"p"},"input done type"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," uses this ",(0,l.kt)("em",{parentName:"p"},"done")," value to determine when the upstream ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," finishes its emission. In ZIO, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZSink")," is encoded as an input side of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," can read from its input, do some transformation on the elements, and write to its output. In ZIO, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZPipeline")," is encoded as a middle part of both sides of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel"),". Pipelines accept a stream as input and return the transformed stream as output."))),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"Note:"))),(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel")," is an underlying abstraction. So we do not usually need to use it directly. So if you are learning ZIO Streams, we recommend you to focus on ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZPipeline"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZSink")," data types.")),(0,l.kt)("p",null,"Let's take a look at how ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZPipeline")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZSink")," are defined using ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZChannel[-Env, -InErr, -InElem, -InDone, +OutErr, +OutElem, +OutDone] \n\ncase class ZStream[-R, +E, +A] (\n  val channel: ZChannel[R, Any, Any, Any, E, Chunk[A], Any]\n)\n\ncase class ZSink[-R, +E, -In, +L, +Z] (\n  val channel: ZChannel[R, ZNothing, Chunk[In], Any, E, Chunk[L], Z]\n)\n\ncase class ZPipeline[-R, +E, -In, +Out] (\n  val channel: ZChannel[R, ZNothing, Chunk[In], Any, E, Chunk[Out], Any]\n)\n")),(0,l.kt)("p",null,"So we can say that:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"ZStream[R, E, A]")," is a channel that uses ",(0,l.kt)("inlineCode",{parentName:"p"},"R")," as its environment, produce ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk[A]")," to its output port, can terminate with ",(0,l.kt)("inlineCode",{parentName:"p"},"Any")," success value or can terminate with a failure of type ",(0,l.kt)("inlineCode",{parentName:"p"},"E"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"ZPipeline[R, Err, In, Out]")," is a channel that uses ",(0,l.kt)("inlineCode",{parentName:"p"},"R")," as its environment, consumes ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk[Int]")," from its input port, and produces ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk[Out]")," to its output port.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"ZSink[R, E, In, L , Z]")," is a channel that uses ",(0,l.kt)("inlineCode",{parentName:"p"},"R")," as its environment, consumes ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk[In]")," from its input port, and produces ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk[L]")," to its output port as its leftovers, and can terminate with a success value of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Z")," or can terminate with a failure of type ",(0,l.kt)("inlineCode",{parentName:"p"},"E"),"."))),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"ZIO Streams 2.x",src:t(9007).Z,width:"554",height:"146"})),(0,l.kt)("p",null,"Channels compose in a variety of ways:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Piping"),"\u2014 One channel can be piped to another channel, assuming the input type of the second is the same as the output type of the first. We can pipe data from a channel that reads from the input port to a channel that writes to the output port, by using the ",(0,l.kt)("inlineCode",{parentName:"p"},"pipeTo")," or ",(0,l.kt)("inlineCode",{parentName:"p"},">>>")," operator.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Sequencing"),"\u2014 The terminal value of one channel can be used to create another channel, and both the first channel and the function that makes the second channel can be composed into a channel. We use the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel#flatMap")," to sequence the channels.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Concating"),"\u2014 The output of one channel can be used to create other channels, which are all concatenated together. The first channel and the function that makes the other channels can be composed into a channel. We use ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel#concat*")," operators to do this."))),(0,l.kt)("p",null,"Finally, we can run a channel by using the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel#run*")," operators."),(0,l.kt)("h2",{id:"creation"},"Creation"),(0,l.kt)("h3",{id:"zchannelsucceed"},(0,l.kt)("inlineCode",{parentName:"h3"},"ZChannel.succeed")),(0,l.kt)("p",null,"Creates a channel that succeeds with a given done value, e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.succeed(42)"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nval channel: ZChannel[Any, Any, Any, Any, Nothing, Nothing, Int] = \n  ZChannel.succeed(42)\n")),(0,l.kt)("p",null,"This channel doesn't produce any data but succeeds with a done value of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Int"),". Let's try to ",(0,l.kt)("inlineCode",{parentName:"p"},"runCollect")," this channel and see what happens:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"channel.runCollect.debug\n")),(0,l.kt)("p",null,"The output of the ",(0,l.kt)("inlineCode",{parentName:"p"},"runCollect")," operation is a tuple of two elements: the first is a chunk of data that the channel produced, and the second is the done value. Because this channel doesn't produce any data, the first element is an empty chunk, but it has a 42 as the done value in the second element."),(0,l.kt)("h3",{id:"zchannelfail"},(0,l.kt)("inlineCode",{parentName:"h3"},"ZChannel.fail")),(0,l.kt)("p",null,"Creates a channel that fails with a given error, e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},'ZChannel.fail(new Exception("error"))'),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import java.io.IOException\nimport zio.stream._\n\nval channel: ZChannel[Any, Any, Any, Any, Exception, Nothing, Nothing] = \n  ZChannel.fail(new Exception("error"))\n')),(0,l.kt)("h3",{id:"zchannelwrite"},(0,l.kt)("inlineCode",{parentName:"h3"},"ZChannel.write*")),(0,l.kt)("p",null,"Create a channel that writes given elements to the output port:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.stream._\n\nZChannel.write(1).runCollect.debug\n// Output: (Chunk(1),()) \n\nZChannel.writeAll(1, 2, 3).runCollect.debug\n// Output: (Chunk(1,2,3),()) \n\nZChannel.writeChunk(Chunk(1, 2, 3)).runCollect.debug\n")),(0,l.kt)("h3",{id:"zchannelread"},(0,l.kt)("inlineCode",{parentName:"h3"},"ZChannel.read*")),(0,l.kt)("p",null,"Create a channel that reads elements from the input port and returns that as a done value:"),(0,l.kt)("p",null,"Let's start with the simplest read operation, ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.read"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nval read: ZChannel[Any, Any, Int, Any, None.type, Nothing, Int] = \n  ZChannel.read[Int]\n")),(0,l.kt)("p",null,"To test this channel, we can create a writer channel and then pipe that to the reader channel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nval read = ZChannel.read[Int]  \n\n(ZChannel.write(1) >>> read).runCollect.debug\n")),(0,l.kt)("p",null,"In the above example, the writer channel writes the value 1 to the output port, and the reader channel reads the value from the input port and then returns it as a done value."),(0,l.kt)("p",null,"If we compose multiple read operations, we can read more values from the input port:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nval read = ZChannel.read[Int]  \n\n(ZChannel.writeAll(1, 2, 3) >>> (read *> read)).runCollect.debug\n// Output: (Chunk(),2) \n\n(ZChannel.writeAll(1, 2, 3) >>> (read *> read *> read)).runCollect.debug\n")),(0,l.kt)("p",null,"Another useful read operation is ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.readWith"),". Using this operator, after reading a value from the input port, instead of returning it as a done value, we have the ability to pass the input value to another channel."),(0,l.kt)("p",null,"Let's try some examples:"),(0,l.kt)("h4",{id:"simple-echo-channel"},"Simple Echo Channel"),(0,l.kt)("p",null,"Assume we want to read a value from the input port and then print it to the console, we can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.readWith")," operator to do this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\n\nval producer = \n  ZChannel.write(1)\n  \nval consumer = \n  ZChannel.readWith(\n    (i: Int) => ZChannel.fromZIO(Console.printLine("Consumed: " + i)),\n    (_: Any) => ZChannel.unit,\n    (_: Any) => ZChannel.unit\n  )\n\n(producer >>> consumer).run\n')),(0,l.kt)("h4",{id:"echo-channel-forever"},"Echo Channel Forever"),(0,l.kt)("p",null,"We can also recursively compose channels to create a more complex channel. In the following example, we are going to continuously read values from the console and write them back to the console:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream.ZChannel\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val producer: ZChannel[Any, Any, Any, Any, IOException, String, Nothing] =\n    ZChannel\n      .fromZIO(Console.readLine("Please enter some text: "))\n      .flatMap(i => ZChannel.write(i) *> producer)\n\n  val consumer: ZChannel[Any, Any, String, Any, IOException, Nothing, Unit] =\n    ZChannel.readWith(\n      (i: String) => i match {\n        case "exit" => ZChannel.unit\n        case _ => ZChannel.fromZIO(Console.printLine("Consumed: " + i)) *> consumer\n      },\n      (_: Any) => ZChannel.unit,\n      (_: Any) => ZChannel.unit\n    )\n\n  def run = (producer >>> consumer).run\n}\n')),(0,l.kt)("h4",{id:"replicator-channel"},"Replicator Channel"),(0,l.kt)("p",null,"In this example, we are going to create a channel that replicates any input values to the output port."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.stream._\n\nobject MainApp extends ZIOAppDefault {\n  lazy val doubler: ZChannel[Any, Any, Int, Any, Nothing, Int, Unit] =\n    ZChannel.readWith(\n      (i: Int) => ZChannel.writeAll(i, i) *> doubler,\n      (_: Any) => ZChannel.unit,\n      (_: Any) => ZChannel.unit\n    )\n  def run = (ZChannel.writeAll(1,2,3,4,5) >>> doubler).runCollect.debug\n}\n")),(0,l.kt)("h4",{id:"counter-channel"},"Counter Channel"),(0,l.kt)("p",null,"We can also use ",(0,l.kt)("inlineCode",{parentName:"p"},"Ref")," to create a channel with an updatable state. For example, we can create a channel that keeps track number of all the values that it has read and finally returns it as the done value:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\n\nobject MainApp extends ZIOAppDefault {\n  val counter = {\n      def count(c: Int): ZChannel[Any, Any, Int, Any, String, Int, Int] =\n        ZChannel.readWith(\n          (i: Int) => ZChannel.write(i) *> count(c + 1),\n          (_: Any) => ZChannel.fail("error"),\n          (_: Any) => ZChannel.succeed(c)\n        )\n\n      count(0)\n    }\n\n  def run = (ZChannel.writeAll(1, 2, 3, 4, 5) >>> counter).runCollect.debug\n}\n')),(0,l.kt)("h4",{id:"dedupe-channel"},"Dedupe Channel"),(0,l.kt)("p",null,"Sometimes we want to remove duplicate values from the input port. We need to have a state that keeps track of the values that have been seen. So if a value is seen for the first time, we can write it to the output port. If a value is duplicated, we can ignore it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.stream._\n\nimport scala.collection.immutable.HashSet\n\nobject MainApp extends ZIOAppDefault {\n  val dedup =\n    ZChannel.fromZIO(Ref.make[HashSet[Int]](HashSet.empty)).flatMap { ref =>\n      lazy val inner: ZChannel[Any, Any, Int, Any, Nothing, Int, Unit] =\n        ZChannel.readWith(\n          (i: Int) =>\n            ZChannel\n              .fromZIO(ref.modify(s => (s contains i, s incl i)))\n              .flatMap {\n                case true  => ZChannel.unit\n                case false => ZChannel.write(i)\n              } *> inner,\n          (_: Any) => ZChannel.unit,\n          (_: Any) => ZChannel.unit\n        )\n      inner\n    }\n\n  def run =\n    (ZChannel.writeAll(1, 2, 2, 3, 3, 4, 2, 5, 5) >>> dedup).runCollect.debug\n}\n")),(0,l.kt)("h3",{id:"buffered-channel"},"Buffered Channel"),(0,l.kt)("p",null,"With help of ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.buffer")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.bufferChunk"),", we can create a channel backed by a buffer."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the buffer is full, the channel puts the values in the buffer to the output port."),(0,l.kt)("li",{parentName:"ul"},"If the buffer is empty, the channel reads the value from the input port and puts it in the output port.")),(0,l.kt)("p",null,"Assume we have a channel written as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.stream._\n\ndef buffered(input: Int) =\n  ZChannel\n    .fromZIO(Ref.make(input))\n    .flatMap { ref =>\n      ZChannel.buffer[Any, Int, Unit](\n        0,\n        i => if (i == 0) true else false,\n        ref\n      )\n    }\n")),(0,l.kt)("p",null,"If the buffer is empty (zero value), the ",(0,l.kt)("inlineCode",{parentName:"p"},"buffered")," channel passes the ",(0,l.kt)("inlineCode",{parentName:"p"},"1")," to the output port:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"(ZChannel.write(1) >>> buffered(0)).runCollect.debug\n")),(0,l.kt)("p",null,"If the buffer is full, the channel puts the value from the buffer to the output port:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"(ZChannel.write(1) >>> buffered(0)).runCollect.debug\n")),(0,l.kt)("h2",{id:"operations"},"Operations"),(0,l.kt)("h3",{id:"piping"},"Piping"),(0,l.kt)("p",null,"The values from the output port of the first channel are passed to the input port of the second channel when we pipe a channel to another channel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\n(ZChannel.writeAll(1,2,3) >>> (ZChannel.read[Int] <*> ZChannel.read[Int])).runCollect.debug\n")),(0,l.kt)("h3",{id:"sequencing"},"Sequencing"),(0,l.kt)("p",null,"In order to sequence channels, we can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel#flatMap")," operator. When we use the ",(0,l.kt)("inlineCode",{parentName:"p"},"flatMap")," operator, we have the ability to chain two channels together. After the first channel is finished, we can create a new channel based on the terminal value of the first channel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\n\nZChannel\n  .fromZIO(\n    Console.readLine("Please enter a number: ").map(_.toInt)\n  )\n  .flatMap {\n    case n if n < 0 => ZChannel.fail("Number must be positive")\n    case n          => ZChannel.writeAll((0 to n): _*)\n  }\n  .runCollect\n  .debug\n')),(0,l.kt)("h3",{id:"concatenating"},"Concatenating"),(0,l.kt)("p",null,"Suppose there is a channel that creates a new channel for each element of the outer channel and emits them to the output port. We can use ",(0,l.kt)("inlineCode",{parentName:"p"},"concatOut")," to concatenate all the inner channels into a single channel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\n\nZChannel\n  .writeAll("a", "b", "c")\n  .mapOut { l =>\n    ZChannel.writeAll((1 to 3).map(i => s"$l$i"):_*) \n  }\n  .concatOut\n  .runCollect\n  .debug\n')),(0,l.kt)("p",null,"We can do the same with ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.concatAll"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\n\nZChannel\n  .concatAll(\n    ZChannel\n      .writeAll("a", "b", "c")\n      .mapOut { l =>\n        ZChannel.writeAll((1 to 3).map(i => s"$l$i"): _*)\n      }\n  )\n  .runCollect\n  .debug\n')),(0,l.kt)("h3",{id:"zipping"},"Zipping"),(0,l.kt)("p",null,"We have two categories of ",(0,l.kt)("inlineCode",{parentName:"p"},"zip")," operators: ordinary ",(0,l.kt)("inlineCode",{parentName:"p"},"zipXYZ")," operators which run sequentially, and parallel ",(0,l.kt)("inlineCode",{parentName:"p"},"zipXYZ")," operators which run in parallel."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"zip"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"<*>")," operator:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'val first = ZChannel.write(1,2,3) *> ZChannel.succeed("Done!")\nval second = ZChannel.write(4,5,6) *> ZChannel.succeed("Bye!")\n\n(first <*> second).runCollect.debug\n// Output: (Chunk((1,2,3),(4,5,6)),(Done!,Bye!))\n')),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"zipRight"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"*>")," operator:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"(first *> second).runCollect.debug\n")),(0,l.kt)("ol",{start:3},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"zipLeft"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"<*")," operator:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"(first <* second).runCollect.debug\n")),(0,l.kt)("h3",{id:"mapping"},"Mapping"),(0,l.kt)("h4",{id:"mapping-the-terminal-done-value-outdone"},"Mapping The Terminal Done Value (",(0,l.kt)("inlineCode",{parentName:"h4"},"OutDone"),")"),(0,l.kt)("p",null,"The ordinary ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," operator is used to map the done value of a channel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nZChannel.writeAll(1, 2, 3).map(_ => 5).runCollect.debug\n")),(0,l.kt)("h4",{id:"mapping-the-done-value-of-the-input-port-indone"},"Mapping The Done Value of The Input Port (",(0,l.kt)("inlineCode",{parentName:"h4"},"InDone"),")"),(0,l.kt)("p",null,"To map the done value of the input port, we use the ",(0,l.kt)("inlineCode",{parentName:"p"},"contramap")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\n\n(ZChannel.succeed("5") >>>\n  ZChannel\n    .readWith(\n      (i: Int) => ZChannel.write(ZChannel.write(i)),\n      (_: Any) => ZChannel.unit,\n      (d: Int) => ZChannel.succeed(d * 2)\n    )\n    .contramap[String](_.toInt)).runCollect.debug\n')),(0,l.kt)("h4",{id:"mapping-the-error-value-of-the-output-port-outerr"},"Mapping The Error Value of The Output Port (",(0,l.kt)("inlineCode",{parentName:"h4"},"OutErr"),")"),(0,l.kt)("p",null,"To map the failure value of a channel, we use the ",(0,l.kt)("inlineCode",{parentName:"p"},"mapError")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\n\nval channel =\n  ZChannel\n    .fromZIO(Console.readLine("Please enter you name: "))\n    .mapError(_.toString)\n')),(0,l.kt)("h4",{id:"mapping-the-output-elements-of-a-channel-outelem"},"Mapping The Output Elements of a Channel (",(0,l.kt)("inlineCode",{parentName:"h4"},"OutElem"),")"),(0,l.kt)("p",null,"To map the output elements of a channel, we use the ",(0,l.kt)("inlineCode",{parentName:"p"},"mapOutput")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nZChannel.writeAll(1,2,3).mapOut(_ * 2).runCollect.debug\n")),(0,l.kt)("h4",{id:"mapping-the-input-elements-of-a-channel-inelem"},"Mapping The Input Elements of a Channel (",(0,l.kt)("inlineCode",{parentName:"h4"},"InElem"),")"),(0,l.kt)("p",null,"To map the input elements of a channel, we use the ",(0,l.kt)("inlineCode",{parentName:"p"},"contramapIn")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\n\n(ZChannel.write("123") >>> ZChannel.read[Int].contramapIn[String](_.toInt * 2)).runCollect.debug\n')),(0,l.kt)("h3",{id:"merging"},"Merging"),(0,l.kt)("p",null,"Merge operators are used to merging multiple channels into a single channel. They are used to combine the output port of channels concurrently. Every time any of the channels produces a value, the output port of the resulting channel will produce a value."),(0,l.kt)("p",null,"Assume we have the following channel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.stream._\n\ndef iterate(\n    from: Int,\n    to: Int\n): ZChannel[Any, Any, Any, Any, Nothing, Int, Unit] =\n  if (from <= to)\n    ZChannel.write(from) *>\n      ZChannel.fromZIO(\n        Random\n          .nextLongBounded(1000)\n          .flatMap(delay => ZIO.sleep(Duration.fromMillis(delay)))\n      ) *> iterate(from + 1, to)\n  else ZChannel.unit\n")),(0,l.kt)("p",null,"Now let's merge some channels:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\n\nZChannel\n  .mergeAllUnbounded(\n    ZChannel.writeAll(\n      iterate(1, 3),\n      iterate(4, 6),\n      iterate(6, 9)\n    )\n  )\n  .mapOutZIO(i => Console.print(i + " "))\n  .runDrain\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.mergeAllUnbounded")," uses the maximum buffer size, which is ",(0,l.kt)("inlineCode",{parentName:"p"},"Int.MaxValue")," by default. This means that if we use this operator for long-running channels, which produce a lot of values, it can cause the program to run out of memory."),(0,l.kt)("p",null,"We have another operator called ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.mergeAll"),", which allows us to specify the buffer size, the concurrency level, and also the strategy for merging the channels."),(0,l.kt)("p",null,"Note that if we want to merge channels sequentially, we can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"zip")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"flatMap")," operators:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\n(iterate(1, 3) <*> iterate(4, 6) <*> iterate(6, 9)).runCollect.debug\n// Output: (Chunk(1,2,3,4,5,6,7,8,9),())\n")),(0,l.kt)("h3",{id:"collecting"},"Collecting"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"collectElements")," collects all the elements of the channel along with its done value as a tuple and returns a new channel with a terminal value of that tuple:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nZChannel.writeAll(1,2,3,4,5)\n  .collectElements\n  .runCollect\n  .debug\n")),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"emitCollect")," is like the ",(0,l.kt)("inlineCode",{parentName:"li"},"collectElements")," operator, but it emits the result of the collection to the output port of the new channel:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nZChannel.writeAll(1,2,3,4,5)\n  .emitCollect\n  .runCollect\n  .debug\n")),(0,l.kt)("h3",{id:"converting"},"Converting"),(0,l.kt)("p",null,"We can convert a channel to other data types using the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.toXYZ")," methods:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#toStream")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#toPipeline")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#toSink")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#toPull")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#toQueue"))),(0,l.kt)("h3",{id:"running-a-channel"},"Running a channel"),(0,l.kt)("p",null,"To run a channel, we can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.runXYZ")," methods:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#run"),"\u2014 The ",(0,l.kt)("inlineCode",{parentName:"li"},"run")," method is the simplest way to run a channel. It only runs a channel that doesn't read any input or write any output."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#runCollect"),"\u2014 It will run a channel and collects the output and finally returns it along with the done value of the channel."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#runDrain"),"\u2014 It will run a channel and ignore any emitted output."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZChannel#runScoped"),"\u2014 Using this method, we can run a channel in a scope. So all the finalizers of the scope will be run before the channel is closed.")),(0,l.kt)("h3",{id:"channel-interruption"},"Channel Interruption"),(0,l.kt)("p",null,"We can interrupt a channel using the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZChannel.interruptWhen")," operator. It takes a ZIO effect that will be evaluated, if it finishes before the channel is closed, it will interrupt the channel, and the terminal value of the returned channel will be the success value of the effect:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\n\ndef randomNumbers: ZChannel[Any, Any, Any, Any, Nothing, Int, Nothing] =\n  ZChannel\n    .fromZIO(Random.nextIntBounded(100))\n    .flatMap(ZChannel.write) *>\n    ZChannel.fromZIO(ZIO.sleep(1.second)) *> randomNumbers\n\nrandomNumbers.interruptWhen(ZIO.sleep(3.seconds).as("Done!")).runCollect.debug\n// One output: (Chunk(84,57,70),Done!)\n')),(0,l.kt)("p",null,"Another version of ",(0,l.kt)("inlineCode",{parentName:"p"},"interruptWhen")," takes a ",(0,l.kt)("inlineCode",{parentName:"p"},"Promise")," as an argument. It will interrupt the channel when the promise is fulfilled:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nfor {\n  p <- Promise.make[Nothing, Unit]\n  f <- randomNumbers\n    .interruptWhen(p)\n    .mapOutZIO(e => Console.printLine(e))\n    .runDrain\n    .fork\n  _ <- p.succeed(()).delay(5.seconds)\n  _ <- f.join\n} yield ()\n")),(0,l.kt)("h3",{id:"concatmap"},"concatMap"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"concatMap")," is a combination of two operators: mapping and concatenation. Using this operator, we can map every emitted element of a channel (outer channel) to a new channel (inner channels), and then concatenate all the inner channels into a single channel. The concatenation is done ",(0,l.kt)("strong",{parentName:"p"},"sequentially"),", so we use this operator when the order of the elements is important:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\n\nZChannel\n  .writeAll("a", "b", "c")\n  .concatMap { l =>\n    def inner(from: Int, to: Int): ZChannel[Any, Any, Any, Any, Nothing, String, Unit] =\n      if (from <= to) ZChannel.write(s"$l$from") *> inner(from + 1, to)\n      else ZChannel.unit  \n    inner(0, 5)\n  }\n  .runCollect\n  .debug\n')),(0,l.kt)("p",null,"In the above example, we create a new channel for every element of the outer channel. The new inner channel is responsible for emitting from zero to five with the label of the outer channel. When an inner channel is done, it moves to the next inner channel sequentially. There is a similar operator called ",(0,l.kt)("inlineCode",{parentName:"p"},"mergeMap")," that works in parallel and doesn't preserve the order of the elements."),(0,l.kt)("h3",{id:"mergemap"},"mergeMap"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"mergeMap")," is a combination of two operators: mapping and merging. Using this operator, we can map every emitted element of a channel (outer channel) to a new channel (inner channel), and then run all the inner channels in parallel and merge them into a single channel. The merge operation is done ",(0,l.kt)("strong",{parentName:"p"},"in parallel"),", so we use this operator when the order of the elements is not important, and we want to process all inner channels in parallel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.stream._\nimport zio.stream.ZChannel._\n\nZChannel\n  .writeAll("a", "b", "c")\n  .mergeMap(8, 1, MergeStrategy.BackPressure) { l =>\n    def inner(\n        from: Int,\n        to: Int\n    ): ZChannel[Any, Any, Any, Any, Nothing, String, Unit] =\n      if (from <= to) ZChannel.write(s"$l$from") *> inner(from + 1, to)\n      else ZChannel.unit\n    inner(0, 5)\n  }\n  .runCollect\n  .debug\n')),(0,l.kt)("h3",{id:"collect"},"collect"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"collect")," is a combination of two operations: filtering and mapping. Using this operator, we can filter the elements of a channel using a partial function, and then map the filtered elements:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.stream._\n\nZChannel\n  .writeAll((1 to 10): _*)\n  .collect { case i if i % 3 == 0 => i * 2 }\n  .runCollect\n  .debug\n")))}h.isMDXComponent=!0},9007:(e,n,t)=>{t.d(n,{Z:()=>a});const a="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjwhLS0gR2VuZXJhdGVkIGJ5IE1pY3Jvc29mdCBWaXNpbywgU1ZHIEV4cG9ydCB6aW8tc3RyZWFtcy0yLnguc3ZnIFBhZ2UtMSAtLT4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpldj0iaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzIgoJCXhtbG5zOnY9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vdmlzaW8vMjAwMy9TVkdFeHRlbnNpb25zLyIgd2lkdGg9IjUuNzY3MzZpbiIgaGVpZ2h0PSIxLjUxNzM2aW4iCgkJdmlld0JveD0iMCAwIDQxNS4yNSAxMDkuMjUiIHhtbDpzcGFjZT0icHJlc2VydmUiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIgY2xhc3M9InN0NSI+Cgk8djpkb2N1bWVudFByb3BlcnRpZXMgdjpsYW5nSUQ9IjEwMzMiIHY6dmlld01hcmt1cD0iZmFsc2UiPgoJCTx2OnVzZXJEZWZzPgoJCQk8djp1ZCB2Om5hbWVVPSJtc3ZOb0F1dG9Db25uZWN0IiB2OnZhbD0iVlQwKDEpOjI2Ii8+CgkJPC92OnVzZXJEZWZzPgoJPC92OmRvY3VtZW50UHJvcGVydGllcz4KCgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJPCFbQ0RBVEFbCgkJLnN0MSB7ZmlsbDp1cmwoI2dyYWQwLTUpO3N0cm9rZTojMDAwMDAwO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utd2lkdGg6MS4yNX0KCQkuc3QyIHtmaWxsOiMwMDAwMDA7Zm9udC1mYW1pbHk6Q2FsaWJyaTtmb250LXNpemU6MS41ZW19CgkJLnN0MyB7bWFya2VyLWVuZDp1cmwoI21ya3I0LTIxKTtzdHJva2U6IzAwMDAwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjF9CgkJLnN0NCB7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLXdpZHRoOjAuMjg0MDkwOTA5MDkwOTF9CgkJLnN0NSB7ZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO2ZvbnQtc2l6ZToxMnB4O292ZXJmbG93OnZpc2libGU7c3Ryb2tlLWxpbmVjYXA6c3F1YXJlO3N0cm9rZS1taXRlcmxpbWl0OjN9CgldXT4KCTwvc3R5bGU+CgoJPGRlZnMgaWQ9IlBhdHRlcm5zX0FuZF9HcmFkaWVudHMiPgoJCTxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZDAtNSIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjAiIGdyYWRpZW50VHJhbnNmb3JtPSJyb3RhdGUoOTAgMC41IDAuNSkiPgoJCQk8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCQk8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNkOGQ4ZDgiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8ZGVmcyBpZD0iTWFya2VycyI+CgkJPGcgaWQ9ImxlbmQ0Ij4KCQkJPHBhdGggZD0iTSAyIDEgTCAwIDAgTCAyIC0xIEwgMiAxICIgc3R5bGU9InN0cm9rZTpub25lIi8+CgkJPC9nPgoJCTxtYXJrZXIgaWQ9Im1ya3I0LTIxIiBjbGFzcz0ic3Q0IiB2OmFycm93VHlwZT0iNCIgdjphcnJvd1NpemU9IjIiIHY6c2V0YmFjaz0iNy4wNCIgcmVmWD0iLTcuMDQiIG9yaWVudD0iYXV0byIKCQkJCW1hcmtlclVuaXRzPSJzdHJva2VXaWR0aCIgb3ZlcmZsb3c9InZpc2libGUiPgoJCQk8dXNlIHhsaW5rOmhyZWY9IiNsZW5kNCIgdHJhbnNmb3JtPSJzY2FsZSgtMy41MiwtMy41MikgIi8+CgkJPC9tYXJrZXI+Cgk8L2RlZnM+Cgk8ZyB2Om1JRD0iMCIgdjppbmRleD0iMSIgdjpncm91cENvbnRleHQ9ImZvcmVncm91bmRQYWdlIj4KCQk8dGl0bGU+UGFnZS0xPC90aXRsZT4KCQk8djpwYWdlUHJvcGVydGllcyB2OmRyYXdpbmdTY2FsZT0iMSIgdjpwYWdlU2NhbGU9IjEiIHY6ZHJhd2luZ1VuaXRzPSIxOSIgdjpzaGFkb3dPZmZzZXRYPSI5IiB2OnNoYWRvd09mZnNldFk9Ii05Ii8+CgkJPHY6bGF5ZXIgdjpuYW1lPSJDb25uZWN0b3IiIHY6aW5kZXg9IjAiLz4KCQk8ZyBpZD0iZ3JvdXAxLTEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4LjYyNSwtMTguNjI1KSIgdjptSUQ9IjEiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCTx0aXRsZT5TaGVldC4xPC90aXRsZT4KCQkJPGcgaWQ9InNoYXBlMi0yIiB2Om1JRD0iMiIgdjpncm91cENvbnRleHQ9InNoYXBlIj4KCQkJCTx0aXRsZT5TaGVldC4yPC90aXRsZT4KCQkJCTxkZXNjPlpTdHJlYW08L2Rlc2M+CgkJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCQk8djp0ZXh0UmVjdCBjeD0iNTQiIGN5PSI3My4yNSIgd2lkdGg9IjEwOC4wMSIgaGVpZ2h0PSI3MiIvPgoJCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQkJPHRleHQgeD0iMjMuNTIiIHk9Ijc4LjY1IiBjbGFzcz0ic3QyIiB2OmxhbmdJRD0iMTAzMyI+PHY6cGFyYWdyYXBoIHY6aG9yaXpBbGlnbj0iMSIvPjx2OnRhYkxpc3QvPlpTdHJlYW08L3RleHQ+CQkJPC9nPgoJCQk8ZyBpZD0ic2hhcGUzLTciIHY6bUlEPSIzIiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNSwwKSI+CgkJCQk8dGl0bGU+U2hlZXQuMzwvdGl0bGU+CgkJCQk8ZGVzYz5aUGlwZWxpbmU8L2Rlc2M+CgkJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCQk8djp0ZXh0UmVjdCBjeD0iNTQiIGN5PSI3My4yNSIgd2lkdGg9IjEwOC4wMSIgaGVpZ2h0PSI3MiIvPgoJCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQkJPHRleHQgeD0iMjAuNTMiIHk9Ijc4LjY1IiBjbGFzcz0ic3QyIiB2OmxhbmdJRD0iMTAzMyI+PHY6cGFyYWdyYXBoIHY6aG9yaXpBbGlnbj0iMSIvPjx2OnRhYkxpc3QvPlpQaXBlbGluZTwvdGV4dD4JCQk8L2c+CgkJCTxnIGlkPSJzaGFwZTQtMTEiIHY6bUlEPSI0IiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3MCwwKSI+CgkJCQk8dGl0bGU+U2hlZXQuNDwvdGl0bGU+CgkJCQk8ZGVzYz5aU2luazwvZGVzYz4KCQkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJCTx2OnRleHRSZWN0IGN4PSI1NCIgY3k9IjczLjI1IiB3aWR0aD0iMTA4LjAxIiBoZWlnaHQ9IjcyIi8+CgkJCQk8cmVjdCB4PSIwIiB5PSIzNy4yNSIgd2lkdGg9IjEwOCIgaGVpZ2h0PSI3MiIgcng9IjkiIHJ5PSI5IiBjbGFzcz0ic3QxIi8+CgkJCQk8dGV4dCB4PSIzNC43NyIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlNpbms8L3RleHQ+CQkJPC9nPgoJCQk8ZyBpZD0iZ3JvdXA1LTE1IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNDMsLTI3KSIgdjptSUQ9IjUiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCQk8dGl0bGU+U2hlZXQuNTwvdGl0bGU+CgkJCQk8ZyBpZD0ic2hhcGU2LTE2IiB2Om1JRD0iNiIgdjpncm91cENvbnRleHQ9InNoYXBlIiB2OmxheWVyTWVtYmVyPSIwIj4KCQkJCQk8dGl0bGU+RHluYW1pYyBjb25uZWN0b3I8L3RpdGxlPgoJCQkJCTxwYXRoIGQ9Ik0wIDEwMC4yNSBMMTkuOTYgMTAwLjI1IiBjbGFzcz0ic3QzIi8+CgkJCQk8L2c+CgkJCTwvZz4KCQkJPGcgaWQ9Imdyb3VwNy0yMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA4LjQ1LC0yOC44KSIgdjptSUQ9IjciIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCQk8dGl0bGU+U2hlZXQuNzwvdGl0bGU+CgkJCQk8ZyBpZD0ic2hhcGU4LTIzIiB2Om1JRD0iOCIgdjpncm91cENvbnRleHQ9InNoYXBlIiB2OmxheWVyTWVtYmVyPSIwIj4KCQkJCQk8dGl0bGU+RHluYW1pYyBjb25uZWN0b3I8L3RpdGxlPgoJCQkJCTxwYXRoIGQ9Ik0wIDEwMC4yNSBMMTkuOTYgMTAwLjI1IiBjbGFzcz0ic3QzIi8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+Cjwvc3ZnPgo="}}]);