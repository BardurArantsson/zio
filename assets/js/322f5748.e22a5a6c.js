"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[5572],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),k=d(n),c=i,g=k["".concat(p,".").concat(c)]||k[c]||s[c]||l;return n?a.createElement(g,r(r({ref:t},m),{},{components:n})):a.createElement(g,r({ref:t},m))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=k;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var d=2;d<l;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},1206:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return d},toc:function(){return m},default:function(){return k}});var a=n(7462),i=n(3366),l=(n(7294),n(3905)),r=["components"],o={id:"zio-2.x-migration-guide",title:"ZIO 2.x Migration Guide"},p=void 0,d={unversionedId:"howto/migrate/zio-2.x-migration-guide",id:"howto/migrate/zio-2.x-migration-guide",isDocsHomePage:!1,title:"ZIO 2.x Migration Guide",description:"In this guide we want to introduce the migration process to ZIO 2.x. So if you have a project written in ZIO 1.x and want to migrate that to ZIO 2.x, this article is for you.",source:"@site/docs/howto/migrate/migration-guide.md",sourceDirName:"howto/migrate",slug:"/howto/migrate/zio-2.x-migration-guide",permalink:"/next/howto/migrate/zio-2.x-migration-guide",editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/howto/migrate/migration-guide.md",tags:[],version:"current",frontMatter:{id:"zio-2.x-migration-guide",title:"ZIO 2.x Migration Guide"},sidebar:"howto-sidebar",previous:{title:"How to Migrate from Monix to ZIO?",permalink:"/next/howto/migrate/from-monix"}},m=[{value:"Guidelines for Library Authors",id:"guidelines-for-library-authors",children:[],level:2},{value:"ZIO",id:"zio",children:[{value:"Removed Methods",id:"removed-methods",children:[],level:3},{value:"ZIO 2.0 Naming Conventions",id:"zio-20-naming-conventions",children:[],level:3},{value:"Lazy Evaluation of Parameters",id:"lazy-evaluation-of-parameters",children:[],level:3},{value:"Composable Zips",id:"composable-zips",children:[],level:3},{value:"Compositional Concurrency",id:"compositional-concurrency",children:[],level:3},{value:"Either Values",id:"either-values",children:[],level:3},{value:"Descriptive Errors",id:"descriptive-errors",children:[],level:3}],level:2},{value:"ZIO App",id:"zio-app",children:[{value:"ZIOApp",id:"zioapp",children:[],level:3}],level:2},{value:"Fiber",id:"fiber",children:[],level:2},{value:"Platform, Executor, and Runtime",id:"platform-executor-and-runtime",children:[{value:"Method Deprecation and Renaming",id:"method-deprecation-and-renaming",children:[],level:3},{value:"Runtime Config Aspect",id:"runtime-config-aspect",children:[],level:3},{value:"Compositional Runtime Config",id:"compositional-runtime-config",children:[],level:3}],level:2},{value:"ZLayer",id:"zlayer",children:[{value:"Functions to Layers",id:"functions-to-layers",children:[],level:3},{value:"Accessing a Service from the Environment",id:"accessing-a-service-from-the-environment",children:[],level:3},{value:"Accessing Multiple Services in the Environment",id:"accessing-multiple-services-in-the-environment",children:[],level:3},{value:"Building the Dependency Graph",id:"building-the-dependency-graph",children:[],level:3},{value:"ZLayer Debugging",id:"zlayer-debugging",children:[],level:3},{value:"Module Pattern",id:"module-pattern",children:[],level:3},{value:"Other Changes",id:"other-changes",children:[],level:3}],level:2},{value:"ZManaged",id:"zmanaged",children:[],level:2},{value:"ZRef",id:"zref",children:[],level:2},{value:"Semaphore and TSemaphore",id:"semaphore-and-tsemaphore",children:[],level:2},{value:"ZQueue",id:"zqueue",children:[],level:2},{value:"ZIO Test",id:"zio-test",children:[{value:"Smart Constructors",id:"smart-constructors",children:[],level:3},{value:"Smart Assertion",id:"smart-assertion",children:[],level:3},{value:"Compositional Specs",id:"compositional-specs",children:[],level:3}],level:2},{value:"ZIO Streams",id:"zio-streams",children:[],level:2},{value:"ZIO Services",id:"zio-services",children:[{value:"Blocking Service",id:"blocking-service",children:[],level:3},{value:"Clock Service",id:"clock-service",children:[],level:3},{value:"Console Service",id:"console-service",children:[],level:3}],level:2},{value:"Other New Features",id:"other-new-features",children:[{value:"Smart Constructors",id:"smart-constructors-1",children:[],level:3},{value:"ZState",id:"zstate",children:[],level:3},{value:"ZHub",id:"zhub",children:[],level:3},{value:"ZIO Aspects",id:"zio-aspects",children:[],level:3},{value:"Debugging",id:"debugging",children:[],level:3},{value:"Logging",id:"logging",children:[],level:3},{value:"Compile-time Execution Tracing",id:"compile-time-execution-tracing",children:[],level:3}],level:2}],s={toc:m};function k(e){var t=e.components,o=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},s,o,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"In this guide we want to introduce the migration process to ZIO 2.x. So if you have a project written in ZIO 1.x and want to migrate that to ZIO 2.x, this article is for you. "),(0,l.kt)("p",null,"ZIO uses the ",(0,l.kt)("a",{parentName:"p",href:"https://scalacenter.github.io/scalafix/"},"Scalafix")," for automatic migration. Scalafix is a code migration tool that takes a rewrite rule and reads the source code, converting deprecated features to newer ones, and then writing the result back to the source code. "),(0,l.kt)("p",null,"ZIO has a migration rule named ",(0,l.kt)("inlineCode",{parentName:"p"},"Zio2Upgrade")," which migrates a ZIO 1.x code base to the ZIO 2.x. This migration rule covers most of the changes. Therefore, to migrate a ZIO project to 2.x, we prefer to apply the ",(0,l.kt)("inlineCode",{parentName:"p"},"Zio2Upgrade")," rule to the existing code. After that, we can go to the source code and fix the remaining compilation issues:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"First, we should ensure that all of our direct and transitive dependencies ",(0,l.kt)("a",{parentName:"p",href:"https://docs.google.com/spreadsheets/d/1QIKgavognTRgh84xAqPTJriJ1VDGbaw8S1fmzMGgf98/"},"have released their compatible versions with ZIO 2.x"),". Note that we shouldn't update our dependencies to the 2.x compatible versions, before running scalafix.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Next, we need to install the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/sbt-scalafix"},"Scalafix SBT Plugin"),", by adding the following line into ",(0,l.kt)("inlineCode",{parentName:"p"},"project/plugins.sbt")," file:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'// project/plugins.sbt\naddSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "<version>")\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"We are ready to apply the migration rule:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'sbt "scalafixEnable; scalafixAll github:zio/zio/Zio2Upgrade?sha=series/2.x" \n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"After running scalafix, it's time to upgrade ZIO dependencies. If we are using one of the following dependencies, we need to bump them into the ",(0,l.kt)("inlineCode",{parentName:"p"},"2.x")," version:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio"         % "2.0.0"\nlibraryDependencies += "dev.zio" %% "zio-streams" % "2.0.0"\nlibraryDependencies += "dev.zio" %% "zio-test"    % "2.0.0"\n')),(0,l.kt)("p",{parentName:"li"},"Other than ZIO, we should upgrade all other (official or community) ZIO libraries we are using in our ",(0,l.kt)("inlineCode",{parentName:"p"},"build.sbt")," file.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Now, we have performed most of the migration. Finally, we should fix the remaining compilation errors with the help of the remaining sections in this article."))),(0,l.kt)("h2",{id:"guidelines-for-library-authors"},"Guidelines for Library Authors"),(0,l.kt)("p",null,"As a contributor to ZIO ecosystem libraries, we also should cover these guidelines:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"We should add ",(0,l.kt)("em",{parentName:"p"},"implicit trace parameter")," to all our codebase, this prevents the guts of our library from messing up the user's execution trace. "),(0,l.kt)("p",{parentName:"li"},"Let's see an example of that in the ZIO source code:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-diff"},"trait ZIO[-R, +E, +A] {\n-  def map[B](f: A => B): ZIO[R, E, B] =\n     flatMap(a => ZIO.succeedNow(f(a)))\n+  def map[B](f: A => B)(implicit trace: ZTraceElement): ZIO[R, E, B] = \n     flatMap(a => ZIO.succeedNow(f(a)))\n}\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"All parameters to operators returning an effect ",(0,l.kt)("a",{parentName:"p",href:"#lazy-evaluation-of-parameters"},"should be by-name"),". Also, we should be sure to capture any parameters that are referenced more than once as a lazy val in our implementation to prevent ",(0,l.kt)("em",{parentName:"p"},"double evaluation"),". "),(0,l.kt)("p",{parentName:"li"},"The overall pattern in implementing such methods will be:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-diff"},"- def foreachParN[A](n: Int)(a: Iterable[A]) = {\n    ... // The function body\n- }\n+ def foreachParN[A](n0: => Int)(a0: => Iterable[A]) = \n+   ZIO.suspendSucceed {\n+    val n = n0 \n+    val a = a0\n      ... // The function body\n+   }\n")),(0,l.kt)("p",{parentName:"li"},"As a result, the code will be robust to ",(0,l.kt)("em",{parentName:"p"},"double evaluation")," as well as to ",(0,l.kt)("em",{parentName:"p"},"side-effects embedded within parameters"),".")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"We should update names to match ",(0,l.kt)("a",{parentName:"p",href:"#zio-20-naming-conventions"},"ZIO 2.0 naming conventions"),".")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"ZIO 2.0 introduced ",(0,l.kt)("a",{parentName:"p",href:"#compositional-concurrency"},"new structured concurrently operators")," which helps us to change the regional parallelism settings of our application. So if applicable, we should use these operators instead of the old parallel operators."))),(0,l.kt)("h2",{id:"zio"},"ZIO"),(0,l.kt)("h3",{id:"removed-methods"},"Removed Methods"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arrow Combinators")," \u2014 (",(0,l.kt)("inlineCode",{parentName:"p"},"+++"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"|||"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"onSecond"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"onFirst"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"second"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"first"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"onRight"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"onLeft"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"andThen"),", ",(0,l.kt)("inlineCode",{parentName:"p"},">>>"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"compose"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"<<<"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"identity"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"swap"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"join"),")"),(0,l.kt)("p",null,"As the ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 2.0")," encourages users to use ",(0,l.kt)("inlineCode",{parentName:"p"},"Has")," with the environment ",(0,l.kt)("inlineCode",{parentName:"p"},"R")," (",(0,l.kt)("inlineCode",{parentName:"p"},"Has[R]"),"), it doesn't make sense to have arrow combinators. An arrow makes the ",(0,l.kt)("inlineCode",{parentName:"p"},"R")," parameter as the ",(0,l.kt)("em",{parentName:"p"},"input")," of the arrow function, and it doesn't match properly with environments with the ",(0,l.kt)("inlineCode",{parentName:"p"},"Has")," data type. So In ZIO 2.0, all arrow combinators are removed, and we need to use alternatives like doing monadic for-comprehension style ",(0,l.kt)("inlineCode",{parentName:"p"},"flatMap")," with combinators like ",(0,l.kt)("inlineCode",{parentName:"p"},"provide"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"zip"),", and so on."),(0,l.kt)("h3",{id:"zio-20-naming-conventions"},"ZIO 2.0 Naming Conventions"),(0,l.kt)("p",null,"In ZIO 2.0, the name of constructors and operators becomes more ergonomic and simple. They reflect more about their purpose rather than just using idiomatic jargon of category theory or functional terms in functional programming with Haskell."),(0,l.kt)("p",null,"Here are some of the most important changes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Multiple ways of doing the same thing are removed")," \u2014 For example:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Both ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.succeed")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.effectTotal")," do the same thing. So in ZIO 2.0 we just have one version of these constructors which is ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.succeed"),"."),(0,l.kt)("li",{parentName:"ul"},"The bind operator ",(0,l.kt)("inlineCode",{parentName:"li"},">>=")," is removed. So we just have one way to flatMap which is the ",(0,l.kt)("inlineCode",{parentName:"li"},"flatMap")," method. Therefore, the ",(0,l.kt)("inlineCode",{parentName:"li"},">>=")," method doesn't surprise the non-Haskellers."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#get")," method was essentially a more constrained version of ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#some"),". So the ",(0,l.kt)("inlineCode",{parentName:"li"},"get")," method is deprecated."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"ZIO.attempt")," instead of ",(0,l.kt)("inlineCode",{parentName:"strong"},"ZIO.effect"))," \u2014 In ZIO 2.0 all ZIO constructors like ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.effect*")," that create a ZIO from a side effect are deprecated and renamed to the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.attempt*")," version. For example, when we are reading from a file, it's more meaning full to say we are attempting to read from a file instead of saying we have an effect of reading from a file.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"ZIO")," instead of the ",(0,l.kt)("inlineCode",{parentName:"strong"},"M")," suffix")," \u2014 In effectful operations, the ",(0,l.kt)("inlineCode",{parentName:"p"},"M")," suffix is renamed to the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO")," suffix. In ZIO 1.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"M")," suffix in an effectful operation means that the operation works with monad in a monadic context. This naming convention is the legacy of Haskell jargon. In ZIO 2.x, all these suffixes are renamed to the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO"),". For example, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ifM")," operator is renamed to ",(0,l.kt)("inlineCode",{parentName:"p"},"ifZIO"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"Discard")," instead of the underscore ",(0,l.kt)("inlineCode",{parentName:"strong"},"_")," suffix")," \u2014 The underscore suffix is another legacy naming convention from Haskell's world. In ZIO 1.x, the underscore suffix means we are going to discard the result. The underscore version works exactly like the one without the underscore, but it discards the result and returns ",(0,l.kt)("inlineCode",{parentName:"p"},"Unit")," in the ZIO context. For example, the ",(0,l.kt)("inlineCode",{parentName:"p"},"collectAll_")," operator renamed to ",(0,l.kt)("inlineCode",{parentName:"p"},"collectAllDiscard"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"as"),", ",(0,l.kt)("inlineCode",{parentName:"strong"},"to"),", ",(0,l.kt)("inlineCode",{parentName:"strong"},"into")," prefixes")," \u2014 The ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#asService")," method is renamed to ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#toLayer")," and also the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#to")," is renamed to the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#intoPromise"),". So now we have three categories of conversion:"),(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"as")," \u2014 The ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#as")," method and its variants like ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#asSome"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#asSomeError")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#asService")," are used when transforming the ",(0,l.kt)("inlineCode",{parentName:"li"},"A")," inside of a ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO"),", generally as shortcuts for ",(0,l.kt)("inlineCode",{parentName:"li"},"map(aToFoo(_))"),"."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"to")," \u2014 The ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#to")," method and its variants like ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#toLayer"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#toManaged"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#toFuture")," are used when the ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO")," is transformed into something else other than the ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO")," data-type."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"into")," \u2014 All ",(0,l.kt)("inlineCode",{parentName:"li"},"into*")," methods, accept secondary data-type, modify it with the result of the current effect (e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"ZIO#intoPromise"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"ZStream#intoHub"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"ZStream#intoQueue")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"ZStream#intoManaged"),")")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#>>=")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#flatMap"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#bimap")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#mapBoth"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#mapEffect")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#mapAttempt"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#filterOrElse_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#filterOrElse"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#foldCauseM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#foldCauseZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#foldM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#foldZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#foldTraceM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#foldTraceZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#get")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#some"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#optional")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#unoption"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#someOrElseM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#someOrElseZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.forkAll_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.forkAllDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#forkInternal")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#fork"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#forkOn")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#onExecutionContext(ec).fork"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.fromFiberM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.fromFiberZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.require")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.someOrFail"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#on")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#onExecutionContext"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#rejectM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#rejectZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#run")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#exit"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#timeoutHalt")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#timeoutFailCause"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#to")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#intoPromise"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#asService")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.accessM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.accessZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.fromFunctionM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.accessZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.fromFunction")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.access"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.services")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.service"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.bracket")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.acquireReleaseWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.bracketExit")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.acquireReleaseExitWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.bracketAuto")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.acquireReleaseWithAuto"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#bracket")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#acquireReleaseWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#bracket_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#acquireRelease"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#bracketExit")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#acquireReleaseExitWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#bracketExit")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#acquireReleaseExitWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#bracketOnError")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#acquireReleaseOnErrorWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#toManaged_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#toManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.collectAll_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllPar_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllParDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllParN_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllParNDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#collectM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#collectZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effect")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attempt"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectAsync")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.async"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectAsyncInterrupt")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.asyncInterrupt"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectAsyncM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.asyncZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectAsyncMaybe")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.asyncMaybe"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectBlocking")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlocking"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectBlockingCancelable")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingCancelable"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectBlockingIO")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectBlockingInterrupt")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingInterrupt"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectSuspend")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.suspend"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectSuspendTotal")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.suspendSucceed"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectSuspendTotalWith")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.suspendSucceedWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectSuspendWith")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.suspendWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.effectTotal")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.succeed"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.foreach_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.foreachDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.foreachPar_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.foreachParDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.foreachParN_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.foreachParNDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#replicateM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#replicateZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#replicateM_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#replicateZIODiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.halt")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.failCause"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.haltWith")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.failCauseWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.ifM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.ifZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.loop_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.loopDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.whenCaseM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.whenCaseZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.whenM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.whenZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.unlessM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.unlessZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#unlessM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#unlessZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#whenM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#whenZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#repeatUntilM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#repeatUntilZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#repeatWhileM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#repeatWhileZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#retryUntilM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#retryUntilZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#retryWhileM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#retryWhileZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.replicateM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.replicateZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.replicateM_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.replicateZIODiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.validate_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.validateDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.validatePar_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.validateParDiscard"))))),(0,l.kt)("h3",{id:"lazy-evaluation-of-parameters"},"Lazy Evaluation of Parameters"),(0,l.kt)("p",null,"In ZIO 2.x, we changed the signature of those functions that return effects to use ",(0,l.kt)("em",{parentName:"p"},"by-name parameters"),". And we also encourage library authors to do the same for any functions that return effects."),(0,l.kt)("p",null,"Our motivation for this change was a common mistake among new users of ZIO, which they ",(0,l.kt)("em",{parentName:"p"},"accidentally embed raw effects")," inside the function they pass to ZIO constructors and operators. This mistake may produce some unwanted behaviors."),(0,l.kt)("p",null,"Let's see an example of this anti-pattern in ZIO 1.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.bracket({\n  val random = scala.util.Random.nextInt()\n  ZIO.succeed(random)\n})(_ => ZIO.unit)(x => console.putStrLn(x.toString)).repeatN(2)\n")),(0,l.kt)("p",null,"The newbie user expects that this program prints 3 different random numbers, while the output would be something as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"1085597917\n1085597917\n1085597917\n")),(0,l.kt)("p",null,"This is because the user incorrectly introduced a raw effect into the ",(0,l.kt)("inlineCode",{parentName:"p"},"acquire")," parameter of ",(0,l.kt)("inlineCode",{parentName:"p"},"bracket")," operation. As the ",(0,l.kt)("inlineCode",{parentName:"p"},"acuqire")," is ",(0,l.kt)("em",{parentName:"p"},"by-value parameter"),", the value passed to the function evaluated ",(0,l.kt)("em",{parentName:"p"},"eagerly"),", only once:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def bracket[R, E, A](acquire: ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n")),(0,l.kt)("p",null,"If we make the ",(0,l.kt)("inlineCode",{parentName:"p"},"acquire")," to ",(0,l.kt)("em",{parentName:"p"},"by-name parameter"),", we can prevent these mistakes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-diff"},"- def bracket[R, E, A](acquire: ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n+ def bracket[R, E, A](acquire: => ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n")),(0,l.kt)("p",null,"So, in ZIO 2.x if we accidentally introduce an effect to the ZIO parameters, the lazy parameter prevents the program from producing undesired behaviors:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"// Note that in ZIO 2.x, the `bracket` is deprecated and renamed to the `acquireReleaseWith`. In this example to prevent the consistency of our example, we used the `bracket`.\n\nZIO.bracket({\n  val random = scala.util.Random.nextInt()\n  ZIO.succeed(random)\n})(_ => ZIO.unit)(x => console.putStrLn(x.toString)).repeatN(2)\n")),(0,l.kt)("p",null,"The output would be something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"355191016\n2046799548\n333146616\n")),(0,l.kt)("h3",{id:"composable-zips"},"Composable Zips"),(0,l.kt)("p",null,"In ZIO 2.x, when we are zipping together different effects:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Tuple"),"s are not nested."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Unit"),"s do not contribute to the output.")),(0,l.kt)("p",null,"Assume we have these effects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val x1: UIO[Int]     = ZIO.succeed(???)\nval x2: UIO[Unit]    = ZIO.succeed(???)\nval x3: UIO[String]  = ZIO.succeed(???)\nval x4: UIO[Boolean] = ZIO.succeed(???)\n")),(0,l.kt)("p",null,"In ZIO 1.x, the output of zipping together these effects are nested:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val zipped = x1 <*> x2 <*> x3 <*> x4\n// zipped: ZIO[Any, Nothing, (((Int, Unit), String), Boolean)] = zio.ZIO$FlatMap@3ed3c202\n")),(0,l.kt)("p",null,"While in ZIO 2.x, we have more ergonomics result type and also the ",(0,l.kt)("inlineCode",{parentName:"p"},"Unit")," data-type doesn't contribute to the output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val zipped = x1 <*> x2 <*> x3 <*> x4\n// zipped: ZIO[Any, Nothing, (Int, String, Boolean)] = <function1>\n")),(0,l.kt)("p",null,"This change is not only for the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO")," data type but also for all other data types like ",(0,l.kt)("inlineCode",{parentName:"p"},"ZManaged"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZSTM"),", etc."),(0,l.kt)("p",null,"As we have compositional zips, we do not longer need higher arity zips in ZIO 1.x like ",(0,l.kt)("inlineCode",{parentName:"p"},"mapN"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"mapParN"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Gen#zipN"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"Gen#crossN"),". They are deprecated in ZIO 2.x."),(0,l.kt)("p",null,"Here is the list of ",(0,l.kt)("inlineCode",{parentName:"p"},"zip")," variants that are deprecated:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#&&&")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#zip"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.tupled")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.zip"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.tupledPar")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.zipPar"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.mapN")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.zip"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.mapParN")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.zipPar"))))),(0,l.kt)("h3",{id:"compositional-concurrency"},"Compositional Concurrency"),(0,l.kt)("p",null,"We introduced two operations that modify the parallel factor of a concurrent ZIO effect, ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#withParallelism")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#withParallelismUnbounded"),". This makes the maximum number of fibers for parallel operators as a regional setting. Therefore, all parallelism operators ending in ",(0,l.kt)("inlineCode",{parentName:"p"},"N"),", such as ",(0,l.kt)("inlineCode",{parentName:"p"},"foreachParN")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"collectAllParN"),", have been deprecated:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"foreachParN")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"foreachPar"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"foreachParN_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"foreachParDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAllParN")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAllPar"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAllParN_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAllParDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAllWithParN")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAllWithPar"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAllSuccessesParN")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAllSuccessesPar"))))),(0,l.kt)("p",null,"Having separate methods for changing the parallelism factor of a parallel effect deprecates lots of extra operators and makes concurrency more compositional."),(0,l.kt)("p",null,"So instead of writing a parallel task like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.foreachParN(8)(urls)(download)\n")),(0,l.kt)("p",null,"We should use the ",(0,l.kt)("inlineCode",{parentName:"p"},"withParallelism")," method:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.foreachPar(urls)(download).withParallelism(8)\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"withParallelismUnbounded")," method is useful when we want to run a parallel effect with an unbounded maximum number of fibers:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.foreachPar(urls)(download).withParallelismUnbounded\n")),(0,l.kt)("h3",{id:"either-values"},"Either Values"),(0,l.kt)("p",null,"In ZIO 1.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#left")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#right")," operators are lossy, and they don't preserve the information on the other side of ",(0,l.kt)("inlineCode",{parentName:"p"},"Either")," after the transformation."),(0,l.kt)("p",null,"For example, assume we have an effect of type ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO[Any, Throwable, Left[Int, String]]"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val effect         = Task.effect(Left[Int, String](5))\n// effect: ZIO[Any, Throwable, Left[Int, String]]\nval leftProjection = effect.left\n// leftProjection: ZIO[Any, Option[Throwable], Int]\n")),(0,l.kt)("p",null,"The error channel of ",(0,l.kt)("inlineCode",{parentName:"p"},"leftProjection")," doesn't contain type information of the other side of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Left[Int, String]"),", which is ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),". So after projecting to the left, we can not go back to the original effect."),(0,l.kt)("p",null,"In ZIO 2.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#left")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#right"),", contains all type information so then we can ",(0,l.kt)("inlineCode",{parentName:"p"},"unleft")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"unright")," to inverse that projection:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val effect         = ZIO.attempt(Left[Int, String](5))\n// effect: Task[Left[Int, String]] = zio.ZIO$SucceedWith@427a7d9b\nval leftProjection = effect.left\n// leftProjection: ZIO[Any, Either[Throwable, String], Int] = <function1>\nval unlefted       = leftProjection.map(_ * 2).unleft \n// unlefted: ZIO[Any, Throwable, Either[Int, String]] = <function1>\n")),(0,l.kt)("p",null,"So the error channel of the output of ",(0,l.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"right")," operators is changed from ",(0,l.kt)("inlineCode",{parentName:"p"},"Option")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"Either"),"."),(0,l.kt)("h3",{id:"descriptive-errors"},"Descriptive Errors"),(0,l.kt)("p",null,"ZIO's type system uses implicit evidence to ensure type safety, and some level of correctness at compile time. In ZIO 2.x, the ",(0,l.kt)("em",{parentName:"p"},"subtype evidence"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"<:<")," replaced by these two descriptive implicit evidences:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"IsSubtypeOfOutput"))," \u2014 The ",(0,l.kt)("inlineCode",{parentName:"p"},"O1 IsSubtypeOfOutput O2")," ensures that the output type ",(0,l.kt)("inlineCode",{parentName:"p"},"O1")," is subtype of ",(0,l.kt)("inlineCode",{parentName:"p"},"O2"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"IsSubtypeOfError"))," \u2014 The ",(0,l.kt)("inlineCode",{parentName:"p"},"E1 IsSubtypeOfError E2")," ensures that the error type ",(0,l.kt)("inlineCode",{parentName:"p"},"E1")," is a subtype of ",(0,l.kt)("inlineCode",{parentName:"p"},"E2")))),(0,l.kt)("p",null,"Now we have more descriptive errors at compile time in the vast majority of operators."),(0,l.kt)("p",null,"Let's just see an example of each one. In ZIO 1.x, the compiler print obscurant error messages:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.fail("Boom!").orDie\n// error: Cannot prove that String <:< Throwable.\n// ZIO.fail("Boom!").orDie\n// ^^^^^^^^^^^^^^^^^^^^^^^\n\nZIO.succeed(Set(3,4)).head\n// error: Cannot prove that scala.collection.immutable.Set[Int] <:< List[B].\n// ZIO.succeed(Set(3, 4)).head\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n')),(0,l.kt)("p",null,"Now in ZIO 2.x we have such informative error messages:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.fail("Boom!").orDie\n// error: This operator requires that the error type be a subtype of Throwable but the actual type was String.\n// ZIO.fail("Boom!").orDie\n// ^^^^^^^^^^^^^^^^^^^^^^^\n\nZIO.succeed(Set(3, 4, 3)).head\n// error: This operator requires that the output type be a subtype of List[B] but the actual type was scala.collection.immutable.Set[Int].\n// ZIO.succeed(Set(3, 4, 3)).head\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n')),(0,l.kt)("h2",{id:"zio-app"},"ZIO App"),(0,l.kt)("h3",{id:"zioapp"},"ZIOApp"),(0,l.kt)("p",null,"In ZIO 1.x, we were used to writing ZIO applications using the ",(0,l.kt)("inlineCode",{parentName:"p"},"zio.App")," trait:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.App\nimport zio.Console._\n\nobject MyApp extends zio.App {\n  def run(args: List[String]) = \n    startMyApp(args).exitCode\n}\n")),(0,l.kt)("p",null,"Now in ZIO 2.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"zio.App")," trait is deprecated and, we have the ",(0,l.kt)("inlineCode",{parentName:"p"},"zio.ZIOAppDefault")," trait which is simpler than the former approach (Note that the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZApp")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ManagedApp")," are also deprecated, and we should use the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIOAppDefault")," instead):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.ZIOAppDefault\nimport zio.Console._\n\nobject MyApp extends ZIOAppDefault {\n  def run =\n    for {\n      arguments <- getArgs\n      _         <- startMyApp(arguments) \n    } yield ()\n}\n")),(0,l.kt)("p",null,"In ZIO 1.x, ",(0,l.kt)("inlineCode",{parentName:"p"},"run")," is the main function of our application, which will be passed the command-line arguments to our application:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def run(args: List[String]): URIO[R, ExitCode]\n")),(0,l.kt)("p",null,"While in most cases we don't write command-line applications, and we don't use it, in ZIO 2.x, we created the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIOAppArgs")," service and a helper method called ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIOApp#args")," which obtains access to the command-line arguments of our application:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIOApp { self =>\n  final def args: ZIO[Has[ZIOAppArgs], Nothing, Chunk[String]] = ZIO.service[ZIOAppArgs].map(_.args)\n}\n")),(0,l.kt)("h2",{id:"fiber"},"Fiber"),(0,l.kt)("p",null,"We deprecated the ",(0,l.kt)("inlineCode",{parentName:"p"},"Fiber.ID")," and moved it to the ",(0,l.kt)("inlineCode",{parentName:"p"},"zio")," package and called it the ",(0,l.kt)("inlineCode",{parentName:"p"},"FiberId"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Fiber.ID")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.FiberID"))))),(0,l.kt)("h2",{id:"platform-executor-and-runtime"},"Platform, Executor, and Runtime"),(0,l.kt)("h3",{id:"method-deprecation-and-renaming"},"Method Deprecation and Renaming"),(0,l.kt)("p",null,"We renamed the ",(0,l.kt)("inlineCode",{parentName:"p"},"Platform")," data type to the ",(0,l.kt)("inlineCode",{parentName:"p"},"RuntimeConfig"),", and moved it from the ",(0,l.kt)("inlineCode",{parentName:"p"},"zio.internal")," to the ",(0,l.kt)("inlineCode",{parentName:"p"},"zio")," package with some member deprecation:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.internal.Platfom")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.RuntimeConfig"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Platform#withBlockingExecutor")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"RuntimeConfig#copy"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Platform#withExecutor")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"RuntimeConfig#copy"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Platform#withFatal")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"RuntimeConfig#copy"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Platform#withReportFatal")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"RuntimeConfig#copy"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Platform#withReportFailure")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"RuntimeConfig#copy"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Platform#withSupervisor")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"RuntimeConfig#copy"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Platform#withTracing")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"RuntimeConfig#copy"))))),(0,l.kt)("p",null,"Also, we moved the ",(0,l.kt)("inlineCode",{parentName:"p"},"Executor")," from ",(0,l.kt)("inlineCode",{parentName:"p"},"zio.internal")," to the ",(0,l.kt)("inlineCode",{parentName:"p"},"zio")," package:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.internal.Executor")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Executor"))))),(0,l.kt)("p",null,"In regard to renaming the ",(0,l.kt)("inlineCode",{parentName:"p"},"Platform")," data-type to the ",(0,l.kt)("inlineCode",{parentName:"p"},"RuntimeConfig")," we have some similar renaming in other data-types like ",(0,l.kt)("inlineCode",{parentName:"p"},"Runtime")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Runtime#mapPlatform")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Runtime#mapRuntimeConfig"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Runtime#platfom")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Runtime#runtimeConfig"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.platfom")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.runtimeConfig"))))),(0,l.kt)("h3",{id:"runtime-config-aspect"},"Runtime Config Aspect"),(0,l.kt)("p",null,"ZIO 2.x, introduced a new data-type called ",(0,l.kt)("inlineCode",{parentName:"p"},"RuntimeConfigAspect")," with the following methods:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"addLogger")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"addReportFailure")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"addReportFatal")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"addSupervisor")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"identity")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setBlockingExecutor")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setExecutor")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setTracing"))),(0,l.kt)("h3",{id:"compositional-runtime-config"},"Compositional Runtime Config"),(0,l.kt)("p",null,"ZIO 2.x allows us to run part of an effect on a different ",(0,l.kt)("inlineCode",{parentName:"p"},"RuntimeConfig"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.withRuntimeConfig(newRuntimeConfiguration)(effect)\n")),(0,l.kt)("p",null,"After running the effect on the specified runtime configuration, it will restore the old runtime configuration."),(0,l.kt)("h2",{id:"zlayer"},"ZLayer"),(0,l.kt)("h3",{id:"functions-to-layers"},"Functions to Layers"),(0,l.kt)("p",null,"In ZIO 1.x, when we want to write a service that depends on other services, we need to use ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.fromService*")," variants with a lot of boilerplate:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'val live: URLayer[Clock with Console, Logging] =\n  ZLayer.fromServices[Clock.Service, Console.Service, Logging.Service] {\n    (clock: Clock.Service, console: Console.Service) =>\n      new Service {\n        override def log(line: String): UIO[Unit] =\n          for {\n            current <- clock.currentDateTime.orDie\n            _ <- console.putStrLn(current.toString + "--" + line).orDie\n          } yield ()\n      }\n  }\n')),(0,l.kt)("p",null,"ZIO 2.x deprecates all ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.fromService*")," functions:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromService")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServices")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServiceM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServicesM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServiceManaged")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServicesManaged")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServiceMany")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServicesMany")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServiceManyM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServicesManyM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServiceManyManaged")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromServicesManyManaged")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"toLayer"))))),(0,l.kt)("p",null,"Instead, it provides the ",(0,l.kt)("inlineCode",{parentName:"p"},"toLayer")," extension methods for functions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'case class LoggingLive(console: Console, clock: Clock) extends Logging {\n  override def log(line: String): UIO[Unit] =\n    for {\n      current <- clock.currentDateTime.orDie\n      _       <- console.putStrLn(current.toString + "--" + line).orDie\n    } yield ()\n}\n\nobject LoggingLive {\n  val layer: URLayer[Has[Console] with Has[Clock], Has[Logging]] =\n    (LoggingLive(_, _)).toLayer[Logging]\n}\n')),(0,l.kt)("p",null,"Note that the ",(0,l.kt)("inlineCode",{parentName:"p"},"LoggingLive(_, _)")," is a ",(0,l.kt)("inlineCode",{parentName:"p"},"Function2")," of type ",(0,l.kt)("inlineCode",{parentName:"p"},"(Console, Clock) => LoggingLive"),". As the ZIO 2.x provides the ",(0,l.kt)("inlineCode",{parentName:"p"},"toLayer")," extension method for all ",(0,l.kt)("inlineCode",{parentName:"p"},"Function")," arities, we can call the ",(0,l.kt)("inlineCode",{parentName:"p"},"toLayer")," on any function to convert that to the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer"),". Unlike the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.fromService*")," functions, this can completely infer the input types, so it saves us from a lot of boilerplates we have had in ZIO 1.x."),(0,l.kt)("h3",{id:"accessing-a-service-from-the-environment"},"Accessing a Service from the Environment"),(0,l.kt)("p",null,"Assume we have a service named ",(0,l.kt)("inlineCode",{parentName:"p"},"Logging"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"trait Logging {\n  def log(line: String): UIO[Unit]\n}\n")),(0,l.kt)("p",null,"In ZIO 1.x, when we wanted to access a service from the environment, we used the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.access")," + ",(0,l.kt)("inlineCode",{parentName:"p"},"Has#get")," combination (",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.access(_.get)"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val logging: URIO[Has[Logging], Logging] = ZIO.access(_.get)\n")),(0,l.kt)("p",null,"Also, to create accessor methods, we used the following code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def log(line: String): URIO[Has[Logging], Unit] = ZIO.accessM(_.get.log(line))\n")),(0,l.kt)("p",null,"ZIO 2.x reduces one level of indirection by using ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.service")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val logging : URIO[Has[Logging], Logging] = ZIO.service\n")),(0,l.kt)("p",null,"And to write the accessor method in ZIO 2.x, we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWith")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def log(line: String): URIO[Has[Logging], Unit] = ZIO.serviceWith(_.log(line))\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n")),(0,l.kt)("h3",{id:"accessing-multiple-services-in-the-environment"},"Accessing Multiple Services in the Environment"),(0,l.kt)("p",null,"In ZIO 1.x, we could access multiple services using higher arity service accessors like ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.services")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZManaged.services"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  (console, random) <- ZIO.services[Console, Random]\n  randomInt         <- random.nextInt\n  _                 <- console.printLine(s"The next random number: $randomInt")\n} yield ()\n')),(0,l.kt)("p",null,"They were ",(0,l.kt)("em",{parentName:"p"},"deprecated")," as we can achieve the same functionality using ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.service")," with for-comprehension syntax, which is more idiomatic and scalable way of accessing multiple services in the environment:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  console   <- ZIO.service[Console]\n  random    <- ZIO.service[Random]\n  randomInt <- random.nextInt\n  _         <- console.printLine(s"The next random number: $randomInt")\n} yield ()\n')),(0,l.kt)("h3",{id:"building-the-dependency-graph"},"Building the Dependency Graph"),(0,l.kt)("p",null,"To create the dependency graph in ZIO 1.x, we should compose the required layers manually. As the ordering of layer compositions matters, and also we should care about composing layers in both vertical and horizontal manner, it would be a cumbersome job to create a dependency graph with a lot of boilerplates."),(0,l.kt)("p",null,"Assume we have the following dependency graph with two top-level dependencies:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"           DocRepo                ++          UserRepo\n      ____/   |   \\____                       /     \\\n     /        |        \\                     /       \\\n Logging  Database  BlobStorage          Logging   Database\n    |                    |                  |\n Console              Logging            Console\n                         |       \n                      Console    \n")),(0,l.kt)("p",null,"In ZIO 1.x, we had to compose these different layers together to create the whole application dependency graph:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val appLayer: URLayer[Any, Has[DocRepo] with Has[UserRepo]] =\n  (((Console.live >>> Logging.live) ++ Database.live ++ (Console.live >>> Logging.live >>> BlobStorage.live)) >>> DocRepo.live) ++\n    (((Console.live >>> Logging.live) ++ Database.live) >>> UserRepo.live)\n    \nval res: ZIO[Any, Nothing, Unit] = myApp.provideLayer(appLayer)\n")),(0,l.kt)("p",null,"As the development of our application progress, the number of layers will grow, and maintaining the dependency graph would be tedious and hard to debug."),(0,l.kt)("p",null,"For example, if we miss the ",(0,l.kt)("inlineCode",{parentName:"p"},"Logging.live")," dependency, the compile-time error would be very messy:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"myApp.provideLayer(\n  ((Database.live ++ BlobStorage.live) >>> DocRepo.live) ++\n    (Database.live >>> UserRepo.live)\n)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"type mismatch;\n found   : zio.URLayer[zio.Has[Logging] with zio.Has[Database] with zio.Has[BlobStorage],zio.Has[DocRepo]]\n    (which expands to)  zio.ZLayer[zio.Has[Logging] with zio.Has[Database] with zio.Has[BlobStorage],Nothing,zio.Has[DocRepo]]\n required: zio.ZLayer[zio.Has[Database] with zio.Has[BlobStorage],?,?]\n    ((Database.live ++ BlobStorage.live) >>> DocRepo.live) ++\n")),(0,l.kt)("p",null,"In ZIO 2.x, we can automatically construct layers with friendly compile-time hints, using ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#inject")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val res: ZIO[Any, Nothing, Unit] =\n  myApp.inject(\n    Console.live,\n    Logging.live,\n    Database.live,\n    BlobStorage.live,\n    DocRepo.live,\n    UserRepo.live\n  )\n")),(0,l.kt)("p",null,"The order of dependencies doesn't matter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val res: ZIO[Any, Nothing, Unit] =\n  myApp.inject(\n    DocRepo.live,\n    BlobStorage.live,\n    Logging.live,\n    Database.live,\n    UserRepo.live,\n    Console.live\n  )\n")),(0,l.kt)("p",null,"If we miss some dependencies, it doesn't compile, and the compiler gives us the clue:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val app: ZIO[Any, Nothing, Unit] =\n  myApp.inject(\n    DocRepo.live,\n    BlobStorage.live,\n//    Logging.live,\n    Database.live,\n    UserRepo.live,\n    Console.live\n  )\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  ZLayer Wiring Error  \n\n\u276f missing Logging\n\u276f     for DocRepo.live\n\n\u276f missing Logging\n\u276f     for UserRepo.live\n")),(0,l.kt)("p",null,"We can also directly construct a layer using ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.wire"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val layer = ZLayer.wire[Has[DocRepo] with Has[UserRepo]](\n  Console.live,\n  Logging.live,\n  DocRepo.live,\n  Database.live,\n  BlobStorage.live,\n  UserRepo.live\n)\n")),(0,l.kt)("p",null,"And also the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.wireSome")," helps us to construct a layer which requires on some service and produces some other services (",(0,l.kt)("inlineCode",{parentName:"p"},"URLayer[Int, Out]"),") using ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.wireSome[In, Out]"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val layer = ZLayer.wireSome[Has[Console], Has[DocRepo] with Has[UserRepo]](\n  Logging.live,\n  DocRepo.live,\n  Database.live,\n  BlobStorage.live,\n  UserRepo.live\n)\n")),(0,l.kt)("p",null,"In ZIO 1.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#provideSomeLayer")," provides environment partially:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val app: ZIO[Has[Console], Nothing, Unit] =\n  myApp.provideSomeLayer[Has[Console]](\n    ((Logging.live ++ Database.live ++ (Console.live >>> Logging.live >>> BlobStorage.live)) >>> DocRepo.live) ++\n      (((Console.live >>> Logging.live) ++ Database.live) >>> UserRepo.live)\n  )\n")),(0,l.kt)("p",null,"In ZIO 2.x, we have a similar functionality but for injection, which is the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#injectSome[Rest](l1, l2, ...)")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val app: ZIO[Has[Console], Nothing, Unit] =\n  myApp.injectSome[Has[Console]](\n    Logging.live,\n    DocRepo.live,\n    Database.live,\n    BlobStorage.live,\n    UserRepo.live\n  )\n")),(0,l.kt)("p",null,"In ZIO 1.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#provideCustomLayer")," takes the part of the environment that is not part of ",(0,l.kt)("inlineCode",{parentName:"p"},"ZEnv")," and gives us an effect that only depends on the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZEnv"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val app: ZIO[zio.ZEnv, Nothing, Unit] = \n  myApp.provideCustomLayer(\n    ((Logging.live ++ Database.live ++ (Logging.live >>> BlobStorage.live)) >>> DocRepo.live) ++\n      ((Logging.live ++ Database.live) >>> UserRepo.live)\n  )\n")),(0,l.kt)("p",null,"In ZIO 2.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO#injectCustom")," does the similar but for the injection:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val app: ZIO[zio.ZEnv, Nothing, Unit] =\n  myApp.injectCustom(\n    Logging.live,\n    DocRepo.live,\n    Database.live,\n    BlobStorage.live,\n    UserRepo.live\n  )\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Note:\nAll ",(0,l.kt)("inlineCode",{parentName:"p"},"provide*")," methods are not deprecated, and they are still necessary and useful for low-level and custom cases. But, in ZIO 2.x, in most cases, it's easier to use ",(0,l.kt)("inlineCode",{parentName:"p"},"inject"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"wire")," methods.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x and 2.x (manually)"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x (automatically)"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#provide")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#inject"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#provideSomeLayer")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#injectSome"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#provideCustomLayer")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO#injectCustom"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Composing manually using ",(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer")," combinators"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer#wire"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Composing manually using ",(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer")," combinators"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer#wireSome"))))),(0,l.kt)("h3",{id:"zlayer-debugging"},"ZLayer Debugging"),(0,l.kt)("p",null,"To debug ZLayer construction, we have two built-in layers, i.e., ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.tree")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.mermaid"),". For example, by including ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.mermaid")," into our layer construction, the compiler generates the following debug information:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val layer = ZLayer.wire[Has[DocRepo] with Has[UserRepo]](\n  Console.live,\n  Logging.live,\n  DocRepo.live,\n  Database.live,\n  BlobStorage.live,\n  UserRepo.live,\n  ZLayer.Debug.mermaid\n)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"[info]   ZLayer Wiring Graph  \n[info] \n[info] \u25c9 DocRepo.live\n[info] \u251c\u2500\u25d1 Logging.live\n[info] \u2502 \u2570\u2500\u25d1 Console.live\n[info] \u251c\u2500\u25d1 Database.live\n[info] \u2570\u2500\u25d1 BlobStorage.live\n[info]   \u2570\u2500\u25d1 Logging.live\n[info]     \u2570\u2500\u25d1 Console.live\n[info] \n[info] \u25c9 UserRepo.live\n[info] \u251c\u2500\u25d1 Logging.live\n[info] \u2502 \u2570\u2500\u25d1 Console.live\n[info] \u2570\u2500\u25d1 Database.live\n[info] \n[info] Mermaid Live Editor Link\n[info] https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZ3JhcGhcbiAgICBDb25zb2xlLmxpdmVcbiAgICBCbG9iU3RvcmFnZS5saXZlIC0tPiBMb2dnaW5nLmxpdmVcbiAgICBMb2dnaW5nLmxpdmUgLS0+IENvbnNvbGUubGl2ZVxuICAgIFVzZXJSZXBvLmxpdmUgLS0+IExvZ2dpbmcubGl2ZVxuICAgIFVzZXJSZXBvLmxpdmUgLS0+IERhdGFiYXNlLmxpdmVcbiAgICBEb2NSZXBvLmxpdmUgLS0+IERhdGFiYXNlLmxpdmVcbiAgICBEb2NSZXBvLmxpdmUgLS0+IEJsb2JTdG9yYWdlLmxpdmVcbiAgICBEYXRhYmFzZS5saXZlXG4gICAgIiwibWVybWFpZCI6ICJ7XG4gIFwidGhlbWVcIjogXCJkZWZhdWx0XCJcbn0iLCAidXBkYXRlRWRpdG9yIjogdHJ1ZSwgImF1dG9TeW5jIjogdHJ1ZSwgInVwZGF0ZURpYWdyYW0iOiB0cnVlfQ==\n")),(0,l.kt)("h3",{id:"module-pattern"},"Module Pattern"),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"Module Pattern")," is one of the most important changes in ZIO 2.x. Let's take a look at services in ZIO 1.x before discussing changes. Here is a ",(0,l.kt)("inlineCode",{parentName:"p"},"Logging")," service that uses ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 1.0"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object logging {\n  // Defining the service type by wrapping the service interface with Has[_] data type\n  type Logging = Has[Logging.Service]\n\n  // Companion object that holds service interface and its live implementation\n  object Logging {\n    trait Service {\n      def log(line: String): UIO[Unit]\n    }\n    \n    // Live implementation of the Logging service\n    val live: ZLayer[Clock with Console, Nothing, Logging] =\n      ZLayer.fromServices[Clock.Service, Console.Service, Logging.Service] {\n        (clock: Clock.Service, console: Console.Service) =>\n          new Logging.Service {\n            override def log(line: String): UIO[Unit] =\n              for {\n                current <- clock.currentDateTime.orDie\n                _       <- console.putStrLn(s"$current--$line")\n              } yield ()\n          }\n      }\n  }\n\n  // Accessor Methods\n  def log(line: => String): URIO[Logging, Unit] =\n    ZIO.accessM(_.get.log(line))\n}\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"Logging")," service is a logger which depends on the ",(0,l.kt)("inlineCode",{parentName:"p"},"Console")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Clock")," services."),(0,l.kt)("p",null,"ZIO 2.x introduces the ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 2.0")," which is much more concise and has more ergonomics. Let's see how the ",(0,l.kt)("inlineCode",{parentName:"p"},"Logging")," service can be implemented using this new pattern:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'// Defining the Service Interface\ntrait Logging {\n  def log(line: String): UIO[Unit]\n}\n\n// Accessor Methods Inside the Companion Object\nobject Logging {\n  def log(line: String): URIO[Has[Logging], Unit] =\n    ZIO.serviceWith(_.log(line))\n}\n\n// Implementation of the Service Interface\ncase class LoggingLive(console: Console, clock: Clock) extends Logging {\n  override def log(line: String): UIO[Unit] =\n    for {\n      time <- clock.currentDateTime\n      _    <- console.printLine(s"$time--$line").orDie\n    } yield ()\n}\n\n// Converting the Service Implementation into the ZLayer\nobject LoggingLive {\n  val layer: URLayer[Has[Console] with Has[Clock], Has[Logging]] =\n    (LoggingLive(_, _)).toLayer[Logging]\n}\n')),(0,l.kt)("p",null,"As we see, we have the following changes:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Deprecation of Type Alias for ",(0,l.kt)("inlineCode",{parentName:"strong"},"Has")," Wrappers")," \u2014 In ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 1.0")," although the type aliases were to prevent using ",(0,l.kt)("inlineCode",{parentName:"p"},"Has[ServiceName]")," boilerplate everywhere, they were confusing, and led to doubly nested ",(0,l.kt)("inlineCode",{parentName:"p"},"Has[Has[ServiceName]]"),". So the ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 2.0")," doesn't anymore encourage using type aliases. Also, they were removed from all built-in ZIO services. So, the ",(0,l.kt)("inlineCode",{parentName:"p"},"type Console = Has[Console.Service]")," removed and the ",(0,l.kt)("inlineCode",{parentName:"p"},"Console.Service")," will just be ",(0,l.kt)("inlineCode",{parentName:"p"},"Console"),". ",(0,l.kt)("strong",{parentName:"p"},"We should explicitly wrap services with ",(0,l.kt)("inlineCode",{parentName:"strong"},"Has")," data types everywhere"),". ")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Introducing Constructor-based Dependency Injection")," \u2014 In ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 1.0")," when we wanted to create a service layer that depends on other services, we had to use ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer.fromService*")," constructors. The problem with the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer")," constructors is that there are too many constructors each one is useful for a specific use-case, but people had troubled in spending a lot of time figuring out which one to use. "),(0,l.kt)("p",{parentName:"li"},"In ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 2.0")," we don't worry about all these different ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer")," constructors. It recommends ",(0,l.kt)("strong",{parentName:"p"},"providing dependencies as interfaces through the case class constructor"),", and then we have direct access to all of these dependencies to implement the service. Finally, to create the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer")," we call ",(0,l.kt)("inlineCode",{parentName:"p"},"toLayer")," on the service implementation."),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"Note:"))),(0,l.kt)("p",{parentName:"blockquote"},"When implementing a service that doesn't have any dependency, our code might not compile:"),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"case class LoggingLive() extends Logging {\n  override def log(line: String): UIO[Unit] =\n    ZIO.attempt(println(line)).orDie\n}\n\nobject LoggingLive {\n  val layer: URLayer[Any, Has[Logging]] = LoggingLive().toLayer\n}\n")),(0,l.kt)("p",{parentName:"blockquote"},"Compiler Error:"),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre"},"value toLayer is not a member of LoggingLive\nval layer: URLayer[Any, Has[Logging]] = LoggingLive().toLayer\n")),(0,l.kt)("p",{parentName:"blockquote"},"The problem here is that the companion object won't automatically extend ",(0,l.kt)("inlineCode",{parentName:"p"},"() => Logging"),". So the workaround is doing that manually:"),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"object LoggingLive extends (() => Logging) {\n  val layer: URLayer[Any, Has[Logging]] = LoggingLive.toLayer\n}\n")),(0,l.kt)("p",{parentName:"blockquote"},"Or we can just write the ",(0,l.kt)("inlineCode",{parentName:"p"},"val layer: URLayer[Any, Has[Logging]] = (() => Logging).toLayer")," to fix that.")),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"Note:"))),(0,l.kt)("p",{parentName:"blockquote"},"The new pattern encourages us to parametrize ",(0,l.kt)("em",{parentName:"p"},"case classes")," to introduce service dependencies and then using ",(0,l.kt)("inlineCode",{parentName:"p"},"toLayer")," syntax as a very simple way that always works. But it doesn't enforce us to do that. We can also just pull whatever services we want from the environment using ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.service")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"ZManaged.service")," and then implement the service and call ",(0,l.kt)("inlineCode",{parentName:"p"},"toLayer")," on it:"),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:silent:nest","mdoc:silent:nest":!0},'object LoggingLive {\n  val layer: ZLayer[Has[Clock] with Has[Console], Nothing, Has[Logging]] =\n    (for {\n      console <- ZIO.service[Console]\n      clock   <- ZIO.service[Clock]\n    } yield new Logging {\n      override def log(line: String): UIO[Unit] =\n        for {\n          time <- clock.currentDateTime\n          _    <- console.printLine(s"$time--$line").orDie\n        } yield ()\n    }).toLayer\n}\n')))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Separated Interface")," \u2014 In the ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 2.0"),", ZIO supports the ",(0,l.kt)("em",{parentName:"p"},"Separated Interface")," pattern which encourages keeping the implementation of an interface decoupled from the client and its definition."),(0,l.kt)("p",{parentName:"li"}," As our application grows, where we define our layers matters more. ",(0,l.kt)("em",{parentName:"p"},"Separated Interface")," is a very useful pattern while we are developing a complex application. It helps us to reduce the coupling between application components. "),(0,l.kt)("p",{parentName:"li"}," Following two changes in ",(0,l.kt)("em",{parentName:"p"},"Module Pattern")," we can define the service definition in one package but its implementations in other packages:"),(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Flattened Structure")," \u2014 In the new pattern, everything is at the top level in a file. So the developer is not limited to package service definition and service implementation in one package."),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"Note")),":"),(0,l.kt)("p",{parentName:"blockquote"},"Module Pattern 2.0 supports the idea of ",(0,l.kt)("em",{parentName:"p"},"Separated Interface"),", but it doesn't enforce us grouping them into different packages and modules. The decision is up to us, based on the complexity and requirements of our application."))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Decoupling Interfaces from Implementation")," \u2014 Assume we have a complex application, and our interface is ",(0,l.kt)("inlineCode",{parentName:"p"},"Logging")," with different implementations that potentially depend on entirely different modules. Putting layers in the service definition means anyone depending on the service definition needs to depend on all the dependencies of all the implementations, which is not a good practice."),(0,l.kt)("p",{parentName:"li"},"In Module Pattern 2.0, layers are defined in the implementation's companion object, not in the interface's companion object. So instead of calling ",(0,l.kt)("inlineCode",{parentName:"p"},"Logging.live")," to access the live implementation we call ",(0,l.kt)("inlineCode",{parentName:"p"},"LoggingLive.layer"),".")))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Accessor Methods")," \u2014 The new pattern reduced one level of indirection on writing accessor methods. So instead of accessing the environment (",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.access/ZIO.accessM"),") and then retrieving the service from the environment (",(0,l.kt)("inlineCode",{parentName:"p"},"Has#get"),") and then calling the service method, the ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 2.0")," introduced the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWith")," that is a more concise way of writing accessor methods. For example, instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.accessM(_.get.log(line))")," we write ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWith(_.log(line))"),"."),(0,l.kt)("p",{parentName:"li"},"We also have accessor methods on the fly, by extending the companion object of the service interface with ",(0,l.kt)("inlineCode",{parentName:"p"},"Accessible"),", e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"object Logging extends Accessible[Logging]"),". So then we can simply access the ",(0,l.kt)("inlineCode",{parentName:"p"},"log")," method by calling the ",(0,l.kt)("inlineCode",{parentName:"p"},"Logging(_.log(line))")," method:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:silent:nest","mdoc:silent:nest":!0},'trait Logging {\n  def log(line: String): UIO[Unit]\n}\n\nobject Logging extends Accessible[Logging]\n\ndef log(line: String): ZIO[Has[Logging] with Has[Clock], Nothing, Unit] =\n  for {\n    clock <- ZIO.service[Clock]\n    now   <- clock.localDateTime\n    _     <- Logging(_.log(s"$now-$line"))\n  } yield ()\n')))),(0,l.kt)("p",null,"While Scala 3 doesn't support macro annotation like, so instead of using ",(0,l.kt)("inlineCode",{parentName:"p"},"@accessible"),", the ",(0,l.kt)("inlineCode",{parentName:"p"},"Accessible")," trait is a macro-less approach to create accessor methods specially for Scala 3 users."),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 1.0")," was somehow complicated and had some boilerplates. The ",(0,l.kt)("em",{parentName:"p"},"Module Pattern 2.0")," is so much familiar to people coming from an object-oriented world. So it is so much easy to learn for newcomers. The new pattern is much simpler."),(0,l.kt)("h3",{id:"other-changes"},"Other Changes"),(0,l.kt)("p",null,"Here is list of other deprecated methods:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromEffect")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromEffectMany")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromZIOMany"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromFunctionM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromFunctionZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromFunctionManyM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.fromFunctionManyZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.identity")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.environment"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.requires")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZLayer.environment"))))),(0,l.kt)("h2",{id:"zmanaged"},"ZManaged"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#&&&")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#zip"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#mapN")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#zip"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.mapM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.mapZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.mapParN")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.zipPar"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#>>=")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#flatMap"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#bimap")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#mapBoth"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#mapEffect")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#mapAttempt"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#flattenM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#flattenZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#get")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#some"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#someOrElseM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#someOrElseManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#asService")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#toLayer"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.services")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.service"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.foreach_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.foreachDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.foreachPar_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.foreachParDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.foreachParN_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.foreachParNDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#foldCauseM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#foldCauseManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#foldM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#foldManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.make")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.make_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireRelease"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeEffect")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseAttemptWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeEffect_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseAttempt"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeEffectTotal")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseSucceedWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeEffectTotal_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseSucceed"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeExit")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseExitWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeExit_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseExit"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeInterruptible")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseInterruptibleWith"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeInterruptible_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.acquireReleaseInterruptible"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.makeReserve")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.fromReservationZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.reserve")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.fromReservation"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#ifM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#ifManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.loop_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.loopDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#unlessM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#unlessManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#whenCaseM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#whenCaseManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#whenM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#whenManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.fromFunction")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.access"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.fromFunctionM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.accessManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.fromEffect")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.fromZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.fromEffectUninterruptible")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.fromZIOUninterruptible"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.effect")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.attempt"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.effectTotal")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.succeed"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#collectM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#collectManage"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#collectAll_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#collectAllDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#collectAllPar_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#collectAllParDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#collectAllParN_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#collectAllParNDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#use_")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#useDiscard"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.require")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.someOrFail"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.accessM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged.accessZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#rejectM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#rejectManaged"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#tapM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#tapZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#on")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#onExecutionContext"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#optional")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#unoption"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#halt")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZManaged#failCause"))))),(0,l.kt)("h2",{id:"zref"},"ZRef"),(0,l.kt)("p",null,"ZIO 2.x unifies ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRef")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRefM"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRefM")," becomes a subtype of ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRef")," that has additional capabilities (i.e. the ability to perform effects within the operations) at some cost to performance:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"RefM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ERefM")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ERef.Synchronized"))))),(0,l.kt)("p",null,"As the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRefM")," is renamed to ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRef.Synchronized"),"; now the ",(0,l.kt)("inlineCode",{parentName:"p"},"Synchronized")," is a subtype of ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRef"),". This change allows a ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRef.Synchronized")," to be used anywhere a ",(0,l.kt)("inlineCode",{parentName:"p"},"Ref")," is currently being used."),(0,l.kt)("p",null,"To perform the migration, after renaming these types to the newer ones (e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRefM")," renamed to ",(0,l.kt)("inlineCode",{parentName:"p"},"ZRef.Synchronized"),") we should perform the following method renames:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#dequeueRef")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#SubscriptionRef"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#getAndUpdate")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#getAndUpdateZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#getAndUpdateSome")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#getAndUpdateSomeZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#modify")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#modifyZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#modifySome")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#modifySomeZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#update")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#updateZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#updateAndGet")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#updateAndGetZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#updateSome")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#updateSomeZIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRefM#updateSomeAndGet")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZRef.Synchronized#updateSomeAndGetZIO"))))),(0,l.kt)("h2",{id:"semaphore-and-tsemaphore"},"Semaphore and TSemaphore"),(0,l.kt)("p",null,"In ZIO 1.x, we have two versions of Semaphore, ",(0,l.kt)("inlineCode",{parentName:"p"},"zio.Semaphore")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"zio.stm.TSemaphore"),". The former is the ordinary semaphore, and the latter is the STM one."),(0,l.kt)("p",null,"In ZIO 2.x, we removed the implementation of ",(0,l.kt)("inlineCode",{parentName:"p"},"zio.stm.Semaphore")," and used the ",(0,l.kt)("inlineCode",{parentName:"p"},"TSemaphore")," as its implementation. So, now the ",(0,l.kt)("inlineCode",{parentName:"p"},"Semaphore")," uses the ",(0,l.kt)("inlineCode",{parentName:"p"},"TSemaphore")," in its underlying. So to migrate a ",(0,l.kt)("inlineCode",{parentName:"p"},"Semaphore")," code base to the ZIO 2.x, we just need to commit ",(0,l.kt)("inlineCode",{parentName:"p"},"STM")," values to get back to the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO")," world."),(0,l.kt)("p",null,"ZIO 1.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.console.Console\n\nval myApp: ZIO[Console, Nothing, Unit] =\n  for {\n    semaphore <- Semaphore.make(4)\n    available <- ZIO.foreach((1 to 10).toList) { _ =>\n      semaphore.withPermit(semaphore.available)\n    }\n    _ <- zio.console.putStrLn(available.toString()).orDie\n  } yield ()\n")),(0,l.kt)("p",null,"ZIO 2.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval myApp: ZIO[Has[Console], Nothing, Unit] =\n  for {\n    semaphore <- Semaphore.make(4)\n    available <- ZIO.foreach((1 to 10).toList) { _ =>\n      semaphore.withPermit(semaphore.available.commit)\n    }\n    _ <- Console.printLine(available.toString()).orDie\n  } yield ()\n")),(0,l.kt)("p",null,"Also, there is a slight change on ",(0,l.kt)("inlineCode",{parentName:"p"},"TSemaphore#withPermit")," method. In ZIO 2.x, instead of accepting ",(0,l.kt)("inlineCode",{parentName:"p"},"STM")," values, it accepts only ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO")," values and returns the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO")," value."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"withPermit")),(0,l.kt)("th",{parentName:"tr",align:null},"Input"),(0,l.kt)("th",{parentName:"tr",align:null},"Output"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"STM[E, B]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"STM[E, B]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ZIO 2.x"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO[R, E, A])")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))))),(0,l.kt)("h2",{id:"zqueue"},"ZQueue"),(0,l.kt)("p",null,"In ZIO 2.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZQueue")," uses ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk")," consistently with other ZIO APIs like ZIO Streams. This will avoid unnecessary conversions between collection types, particularly for streaming applications where streams use ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk")," internally, but bulk take operations previously returned a ",(0,l.kt)("inlineCode",{parentName:"p"},"List")," on ",(0,l.kt)("inlineCode",{parentName:"p"},"ZQueue"),"."),(0,l.kt)("p",null,"Here is a list of affected APIs: ",(0,l.kt)("inlineCode",{parentName:"p"},"takeAll"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"takeUpTo"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"takeBetween"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"takeN"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"unsafePollAll"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"unsafePollN"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"unsafeOfferAll"),". Let's see an example:"),(0,l.kt)("p",null,"ZIO 1.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val taken: UIO[List[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _     <- queue.offer(10)\n  _     <- queue.offer(20)\n  list  <- queue.takeUpTo(5)\n} yield list\n")),(0,l.kt)("p",null,"ZIO 2.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val taken: UIO[Chunk[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _     <- queue.offer(10)\n  _     <- queue.offer(20)\n  chunk <- queue.takeUpTo(5)\n} yield chunk\n")),(0,l.kt)("h2",{id:"zio-test"},"ZIO Test"),(0,l.kt)("h3",{id:"smart-constructors"},"Smart Constructors"),(0,l.kt)("p",null,"By introducing smart constructors, we do not longer have the ",(0,l.kt)("inlineCode",{parentName:"p"},"testM")," function to create effectful test suits. Instead, we should use the ",(0,l.kt)("inlineCode",{parentName:"p"},"test")," function:"),(0,l.kt)("p",null,"ZIO 1.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'suite("ZRef") {\n  testM("updateAndGet") {\n    val result = ZRef.make(0).flatMap(_.updateAndGet(_ + 1))\n    assertM(result)(Assertion.equalTo(1))\n  }\n}\n')),(0,l.kt)("p",null,"ZIO 2.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'suite("ZRef") {\n  test("updateAndGet") {\n    val result = ZRef.make(0).flatMap(_.updateAndGet(_ + 1))\n    assertM(result)(Assertion.equalTo(1))\n  }\n}\n')),(0,l.kt)("p",null,"In ZIO 2.x, to create a test suite, it's not important that whether we are testing pure or effectful tests. The syntax is the same, and the ",(0,l.kt)("inlineCode",{parentName:"p"},"test"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"testM")," are unified. So the ",(0,l.kt)("inlineCode",{parentName:"p"},"testM")," was removed."),(0,l.kt)("h3",{id:"smart-assertion"},"Smart Assertion"),(0,l.kt)("p",null,"ZIO 2.x, introduced a new test method, named ",(0,l.kt)("inlineCode",{parentName:"p"},"assertTrue")," which allows us to assert an expected behavior using ordinary Scala expressions that return ",(0,l.kt)("inlineCode",{parentName:"p"},"Boolean")," values instead of specialized assertion operators."),(0,l.kt)("p",null,"So instead of writing following test assertions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'val list   = List(1, 2, 3, 4, 5)\nval number = 3\nval option = Option.empty[Int]\n\nsuite("ZIO 1.x Test Assertions")(\n  test("contains")(assert(list)(Assertion.contains(5))),\n  test("forall")(assert(list)(Assertion.forall(Assertion.assertion("even")()(actual => actual % 2 == 0)))),\n  test("less than")(assert(number)(Assertion.isLessThan(0))),\n  test("isSome")(assert(option)(Assertion.equalTo(Some(3))))\n)\n')),(0,l.kt)("p",null,"We can write them like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'suite("ZIO 2.x SmartAssertions")(\n  test("contains")(assertTrue(list.contains(5))),\n  test("forall")(assertTrue(list.forall(_ % 2 == 0))),\n  test("less than")(assertTrue(number < 0)),\n  test("isSome")(assertTrue(option.get == 3))\n)\n')),(0,l.kt)("p",null,"Smart Assertions are extremely expressive, so when a test fails:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"They highlight the exact section of the syntax with the path leading up to the left-hand side of the assertion that causes the failure."),(0,l.kt)("li",{parentName:"ul"},"They have the strong and nice diffing capability which shows where our expectation varies."),(0,l.kt)("li",{parentName:"ul"},"When using partial functions in test cases there is no problem with the happy path, but if something goes wrong, it is a little annoying to find what went wrong. But smart assertions are descriptive, e.g., when we call ",(0,l.kt)("inlineCode",{parentName:"li"},"Option#get")," to an optional value that is ",(0,l.kt)("inlineCode",{parentName:"li"},"None")," the test fails with a related error message: ",(0,l.kt)("inlineCode",{parentName:"li"},"Option was None")),(0,l.kt)("li",{parentName:"ul"},"They have lots of domains specific errors that talk to us in a language that we understand.")),(0,l.kt)("h3",{id:"compositional-specs"},"Compositional Specs"),(0,l.kt)("p",null,"In ZIO 1.x, we cannot compose specs directly, although if we can combine all children's specs via the suite itself:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'val fooSuite = suite("Foo")(fooSpec)\nval barSuite = suite("Bar")(barSpec)\nval bazSuite = suite("Baz")(bazSpec)\n\nval bigSuite = suite("big suite")(fooSuite, barSuite, bazSuite)\n')),(0,l.kt)("p",null,"Now in ZIO 2.x, we can compose two suites using ",(0,l.kt)("em",{parentName:"p"},"binary composition operator")," without having to unnecessarily nest them inside another suite just for purpose of composition:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val bigSuite = fooSuite + barSuite + bazSuite\n")),(0,l.kt)("h2",{id:"zio-streams"},"ZIO Streams"),(0,l.kt)("p",null,"ZIO Streams 2.x, does not include any significant API changes. Almost the same code we have for ZIO Stream 1.x, this will continue working and doesn't break our code. So we don't need to relearn any APIs. So we have maintained a quite good source compatibility, but have to forget some API elements."),(0,l.kt)("p",null,"So far, before ZIO 2.0, the ZIO Stream has included three main abstractions:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"ZStream"))," \u2014 represents the source of elements"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"ZSink"))," \u2014 represents consumers of elements that can be composed together to create composite consumers"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"ZTransducer"))," \u2014 represents generalized stateful and effectful stream processing")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"ZIO Streams 1.x",src:n(2347).Z})),(0,l.kt)("p",null,"In ZIO 2.0, we added an underlying abstraction called ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel"),". Channels are underlying both the ",(0,l.kt)("inlineCode",{parentName:"p"},"Stream")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Sink"),". So streams and sinks are just channels. So the ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," is an abstraction that unifies everything in ZIO Streams."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"ZChannel",src:n(199).Z})),(0,l.kt)("p",null,"Channels are nexuses of I/O operations, which support both reading and writing:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," can write some elements to the ",(0,l.kt)("em",{parentName:"p"},"output"),", and it can terminate with some sort of ",(0,l.kt)("em",{parentName:"p"},"done")," value. The ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," uses this ",(0,l.kt)("em",{parentName:"p"},"done")," value to notify the downstream ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," that its emission of elements finished. In ZIO 2.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream")," is encoded as an output side of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," can read from its input, and it can also terminate with some sort of ",(0,l.kt)("em",{parentName:"p"},"done")," value, which is an upstream result. So a ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," has the ",(0,l.kt)("em",{parentName:"p"},"input type"),", and the ",(0,l.kt)("em",{parentName:"p"},"input done type"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," uses this ",(0,l.kt)("em",{parentName:"p"},"done")," value to determine when the upstream ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel")," finishes its emission. In ZIO 2.x, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZSink")," is encoded as an input side of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel"),"."))),(0,l.kt)("p",null,"So we can say that streams are the output side and sinks are the input side of a ",(0,l.kt)("inlineCode",{parentName:"p"},"Channel"),". What about the middle part? In ZIO 1.x, this used to be known as the",(0,l.kt)("inlineCode",{parentName:"p"},"ZTransducer"),". Transducers were great for writing high-performance codecs (e.g. compression). They were really just a specialization of sinks. We have added transducers because things were not sufficiently efficient using sinks. If we were to write streaming codecs using sinks, they could be quite slow."),(0,l.kt)("p",null,"In ZIO 2.x, we removed the transducers, and they were deprecated. Instead, we realized we need something else for the middle part, and now it's called a ",(0,l.kt)("inlineCode",{parentName:"p"},"Pipeline")," in ZIO 2.x. Pipelines accept a stream as input and return the transformed stream as output."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"ZIO Streams 2.x",src:n(2456).Z})),(0,l.kt)("p",null,"Pipelines are basically an abstraction for composing a bunch of operations together that can be later applied to a stream. For example, we can create a pipeline that reads bytes, decodes them to the UTF-8 and splits the lines, and then splits on commas. So this is a very simple CSV parsing pipeline which we can later use with another stream to pipe into. "),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO Streams 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO Streams 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZChannel"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZStream")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZStream")," (backed by ",(0,l.kt)("inlineCode",{parentName:"td"},"ZChannel"),")")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZSink")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZSink")," (backed by ",(0,l.kt)("inlineCode",{parentName:"td"},"ZChannel"),")")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZTransducer")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZPipeline"))))),(0,l.kt)("h2",{id:"zio-services"},"ZIO Services"),(0,l.kt)("p",null,"There are two significant changes in ZIO Services:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"All ZIO services moved to the ",(0,l.kt)("inlineCode",{parentName:"p"},"zio")," package:"),(0,l.kt)("table",{parentName:"li"},(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.blocking.Blocking")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"#blocking-service"},"Removed"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.clock.Clock")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Clock"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.console.Console")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Console"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.random.Random")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Random"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.system.System")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.System"))))),(0,l.kt)("p",{parentName:"li"},"And their live implementations renamed and moved to a new path:"),(0,l.kt)("table",{parentName:"li"},(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Clock.Service.live")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Clock.ClockLive"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Console.Service.live")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Console.ConsoleLive"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.System.Service.live")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.System.SystemLive"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Random.Service.live")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.Random.RandomLive"))))))),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},"In ZIO 2.0 all type aliases like ",(0,l.kt)("inlineCode",{parentName:"li"},"type Logging = Has[Logging.Service]")," removed. So we should explicitly use ",(0,l.kt)("inlineCode",{parentName:"li"},"Has")," wrappers when we want to specify dependencies on ZIO services.")),(0,l.kt)("p",null,"So instead of writing ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer[Console with Clock, Nothing, ConsoleLogger]"),", we should write ",(0,l.kt)("inlineCode",{parentName:"p"},"ZLayer[Has[Console] with Has[Clock], Nothing, Has[ConsoleLogger]]"),", or when accessing services instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.service[Console.Service]")," we also now do ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.service[Console]"),"."),(0,l.kt)("h3",{id:"blocking-service"},"Blocking Service"),(0,l.kt)("p",null,"Since there is rarely a need to use a separate blocking thread pool, ZIO 2.0 created ",(0,l.kt)("em",{parentName:"p"},"one global blocking pool"),", and removed the Blocking service from ",(0,l.kt)("inlineCode",{parentName:"p"},"ZEnv")," and the built-in services."),(0,l.kt)("p",null,"All blocking operations were moved to the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO")," data type:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"zio.blocking.Blocking.*")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.*"))))),(0,l.kt)("p",null,"With some renaming stuffs:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x (",(0,l.kt)("inlineCode",{parentName:"th"},"zio.blocking.Blocking.*"),")"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x (",(0,l.kt)("inlineCode",{parentName:"th"},"ZIO.*"),")"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"effectBlocking")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlocking"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"effectBlockingCancelable")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingCancelable"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"effectBlockingIO")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingIO"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"effectBlockingInterrupt")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingInterrupt"))))),(0,l.kt)("p",null,"Now we have all the blocking operations under the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO")," data type as below:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.attemptBlocking")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.attemptBlockingCancelable")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.attemptBlockingIO")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.attemptBlockingInterrupt")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.blocking")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.blockingExecutor"))),(0,l.kt)("p",null,"We can also provide a user-defined blocking executor in ZIO 2.x with the ",(0,l.kt)("inlineCode",{parentName:"p"},"Runtime#withBlockingExecutor")," operator that constructs a new ",(0,l.kt)("inlineCode",{parentName:"p"},"Runtime")," with the specified blocking executor."),(0,l.kt)("h3",{id:"clock-service"},"Clock Service"),(0,l.kt)("p",null,"There is a slight change in the Clock service; the return value of the ",(0,l.kt)("inlineCode",{parentName:"p"},"currentDateTime"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"localDateTime")," methods changed from ",(0,l.kt)("inlineCode",{parentName:"p"},"IO")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"UIO"),", so they do not longer throw ",(0,l.kt)("inlineCode",{parentName:"p"},"DateTimeException"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Method Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Return Type (ZIO 1.x)"),(0,l.kt)("th",{parentName:"tr",align:null},"Return Type (ZIO 2.x)"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"currentDateTime")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"IO[OffsetDateTime]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"UIO[OffsetDateTime]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"localDateTime")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"IO[LocalDateTime]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"UIO[LocalDateTime]"))))),(0,l.kt)("p",null,"In ZIO 2.0, without changing any API, the ",(0,l.kt)("em",{parentName:"p"},"retrying"),", ",(0,l.kt)("em",{parentName:"p"},"repetition"),", and ",(0,l.kt)("em",{parentName:"p"},"scheduling")," logic moved into the ",(0,l.kt)("inlineCode",{parentName:"p"},"Clock")," service."),(0,l.kt)("p",null,"Working with these three time-related APIs, always made us require ",(0,l.kt)("inlineCode",{parentName:"p"},"Clock")," as our environment. So by moving these primitives into the ",(0,l.kt)("inlineCode",{parentName:"p"},"Clock")," service, now we can directly call them via the ",(0,l.kt)("inlineCode",{parentName:"p"},"Clock")," service. This change solves a common anti-pattern in ZIO 1.0, whereby a middleware that uses ",(0,l.kt)("inlineCode",{parentName:"p"},"Clock")," via this retrying, repetition, or scheduling logic must provide the ",(0,l.kt)("inlineCode",{parentName:"p"},"Clock")," layer on every method invocation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'trait Journal {\n  def append(log: String): ZIO[Any, Throwable, Unit]\n}\n\ntrait Logger {\n  def log(line: String): UIO[Unit]\n}\n\ncase class JournalLoggerLive(clock: Clock, journal: Journal) extends Logger {\n  override def log(line: String): UIO[Unit] = {\n    for {\n      current <- clock.currentDateTime\n      _ <- journal.append(s"$current--$line")\n        .retry(Schedule.exponential(2.seconds))\n        .provide(Has(clock))\n        .orDie\n    } yield ()\n  }\n}\n')),(0,l.kt)("p",null,"In ZIO 2.0, we can implement the logger service with a better ergonomic:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'case class JournalLoggerLive(clock: Clock, journal: Journal) extends Logger {\n  override def log(line: String): UIO[Unit] = {\n    for {\n      current <- clock.currentDateTime\n      _       <- clock.retry(\n                   journal.append(s"$current--$line")\n                )(Schedule.exponential(2.seconds)).orDie\n    } yield ()\n  }\n}\n')),(0,l.kt)("p",null,"Note that the ZIO API didn't change, but the ",(0,l.kt)("inlineCode",{parentName:"p"},"Clock")," trait became a bigger one, having more clock-related methods."),(0,l.kt)("h3",{id:"console-service"},"Console Service"),(0,l.kt)("p",null,"Method names in the ",(0,l.kt)("em",{parentName:"p"},"Console")," service were renamed to the more readable names:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,l.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"putStr")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"print"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"putStrErr")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"printError"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"putStrLn")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"printLine"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"putStrLnErr")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"printLineError"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"getStrLn")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"readLine"))))),(0,l.kt)("h2",{id:"other-new-features"},"Other New Features"),(0,l.kt)("h3",{id:"smart-constructors-1"},"Smart Constructors"),(0,l.kt)("p",null,"Every data type in ZIO (",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZManaged"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream"),", etc.) has a variety of constructor functions that are designed to ",(0,l.kt)("em",{parentName:"p"},"up convert")," some weaker type into the target type. Typically, these converter functions are named ",(0,l.kt)("inlineCode",{parentName:"p"},"fromXYZ"),", e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.fromEither"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZStream.fromZIO"),", etc."),(0,l.kt)("p",null,"While these are precise, ZIO 2.0 provides the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.from")," constructor which can intelligently choose the most likely constructor based on the input type. So instead of writing ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.fromEither(Right(3))")," we can easily write ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.from(Right(3))"),". Let's try some of them:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.fromOption(Some("Ok!"))\n// res16: IO[Option[Nothing], String] = <function1>\nZIO.from(Some("Ok!"))\n// res17: ZIO[Any, Option[Nothing], String] = <function1>\n\nZIO.fromEither(Right(3))\n// res18: IO[Nothing, Int] = <function1>\nZIO.from(Right(3))\n// res19: ZIO[Any, Nothing, Int] = <function1>\n\nZIO.fromFiber(Fiber.succeed("Ok!"))\n// res20: IO[Nothing, String] = <function1>\nZIO.from(Fiber.succeed("Ok!"))\n// res21: ZIO[Any, Nothing, String] = <function1>\n\nZManaged.fromZIO(ZIO.fromEither(Right("Ok!"))) \n// res22: ZManaged[Any, Nothing, String] = zio.ZManaged$$anon$2@2e2d2f95 \nZManaged.from(ZIO(Right("Ok!")))\n// res23: ZManaged[Any, Throwable, Right[Nothing, String]] = zio.ZManaged$$anon$2@56dfe627\n\nZStream.fromIterable(List(1,2,3)) \n// res24: ZStream[Any, Nothing, Int] = zio.stream.ZStream@4e5faab6 \nZStream.from(List(1,1,3))\n// res25: ZStream[Any, Nothing, Int] = zio.stream.ZStream@5fd89043\n\nZStream.fromChunk(Chunk(1,2,3))\n// res26: ZStream[Any, Nothing, Int] = zio.stream.ZStream@18ce4daa\nZStream.from(Chunk(1,2,3))\n// res27: ZStream[Any, Nothing, Int] = zio.stream.ZStream@31897e4a\n\nZStream.fromIterableZIO(ZIO.succeed(List(1,2,3)))\n// res28: ZStream[Any, Nothing, Int] = zio.stream.ZStream@23078d7\nZStream.from(ZIO.succeed(List(1,2,3)))\n// res29: ZStream[Any, Nothing, Int] = zio.stream.ZStream@19f1aa5a\n')),(0,l.kt)("h3",{id:"zstate"},"ZState"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"ZState")," is a new data type that the ZIO 2.0 introduced:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait ZState[S] {\n  def get: UIO[S]\n  def set(s: S): UIO[Unit]\n  def update(f: S => S): UIO[Unit]\n}\n")),(0,l.kt)("p",null,"We can ",(0,l.kt)("inlineCode",{parentName:"p"},"set"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"get"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"update")," the state which is part of the ZIO environment using ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.setState"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.getState"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.updateState")," operations:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject ZStateExample extends zio.ZIOAppDefault {\n  final case class MyState(counter: Int)\n\n  val app = for {\n    _     <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n    count <- ZIO.getStateWith[MyState](_.counter)\n    _     <- Console.printLine(count)\n  } yield count\n\n  def run = app.injectCustom(ZState.makeLayer(MyState(0)))\n}\n")),(0,l.kt)("h3",{id:"zhub"},"ZHub"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"ZHub")," is a new concurrent data structure like ",(0,l.kt)("inlineCode",{parentName:"p"},"ZQueue"),". While ",(0,l.kt)("inlineCode",{parentName:"p"},"ZQueue")," solves the problem of ",(0,l.kt)("em",{parentName:"p"},"distributing")," messages to multiple consumers, the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZHub")," solves the problem of ",(0,l.kt)("em",{parentName:"p"},"broadcasting")," the same message to multiple consumers."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"ZHub",src:n(1071).Z})),(0,l.kt)("p",null,"Here is an example of broadcasting messages to multiple subscribers:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  hub <- Hub.bounded[String](requestedCapacity = 2)\n  s1 = hub.subscribe\n  s2 = hub.subscribe\n  _ <- s1.zip(s2).use { case (left, right) =>\n    for {\n      _ <- hub.publish("Hello from a hub!")\n      _ <- left.take.flatMap(Console.printLine(_))\n      _ <- right.take.flatMap(Console.printLine(_))\n    } yield ()\n  }\n} yield ()\n')),(0,l.kt)("p",null,"Visit the ",(0,l.kt)("a",{parentName:"p",href:"/next/datatypes/concurrency/hub"},"Hub")," page to learn more about it."),(0,l.kt)("h3",{id:"zio-aspects"},"ZIO Aspects"),(0,l.kt)("p",null,"We introduced the",(0,l.kt)("inlineCode",{parentName:"p"},"ZIOAspect")," which enables us to modify the existing ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO")," effect with some additional aspects like debugging, tracing, retrying, and logging:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'val myApp: ZIO[Has[Random], Nothing, String] =\n  ZIO.ifZIO(\n    Random.nextIntBounded(10) @@ ZIOAspect.debug map (_ % 2 == 0)\n  )(onTrue = ZIO.succeed("Hello!"), onFalse = ZIO.succeed("Good Bye!")) @@\n    ZIOAspect.debug @@ ZIOAspect.logged("result")\n    \n// Sample Output:     \n// 2\n// Hello!\n// timestamp=2021-09-05T15:32:56.705901Z level=INFO thread=#2 message="result: Hello!" file=ZIOAspect.scala line=74 class=zio.ZIOAspect$$anon$4 method=apply\n')),(0,l.kt)("h3",{id:"debugging"},"Debugging"),(0,l.kt)("p",null,"ZIO 2.x introduces the ",(0,l.kt)("inlineCode",{parentName:"p"},"debug")," that is useful when we want to print something to the console for debugging purposes without introducing additional environmental requirements or error types:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'val myApp: ZIO[Has[Random], Nothing, String] =\n  ZIO\n    .ifZIO(\n      Random.nextIntBounded(10) debug("random") map (_ % 2 == 0)\n    )(\n      onTrue = ZIO.succeed("Hello!"),\n      onFalse = ZIO.succeed("Good Bye!")\n    )\n    .debug("result")\n// Sample Output\n// random: 2\n// result: Hello!\n')),(0,l.kt)("h3",{id:"logging"},"Logging"),(0,l.kt)("p",null,"ZIO 2.x supports a lightweight built-in logging facade that standardized the interface to logging functionality. So it doesn't replace existing logging libraries, but also we can plug it into one of the existing logging backends."),(0,l.kt)("p",null,"We can easily log using the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.log")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.log("Application started!")\n')),(0,l.kt)("p",null,"To log with a specific log-level, we can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"ZIO.logLevel")," combinator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logLevel(LogLevel.Warning) {\n  ZIO.log("The response time exceeded its threshold!")\n}\n')),(0,l.kt)("p",null,"Or we can use the following functions directly:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.logDebug")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.logError")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.logFatal")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.logInfo")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ZIO.logWarning"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logError("File does not exist: ~/var/www/favicon.ico")\n')),(0,l.kt)("p",null,"It also supports logging spans:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logSpan("myspan") {\n  ZIO.sleep(1.second) *> ZIO.log("The job is finished!")\n}\n')),(0,l.kt)("p",null,"ZIO Logging calculates the running duration of that span and includes that in the logging data corresponding to its span label."),(0,l.kt)("h3",{id:"compile-time-execution-tracing"},"Compile-time Execution Tracing"),(0,l.kt)("p",null,"ZIO 1.x's execution trace is not as useful as it could be because it contains tracing information for internal ZIO operators that it not helpful to the user is understanding where in their code an error occurred."),(0,l.kt)("p",null,"Let's say we have the following application, in ZIO 1.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.console.Console\n\nobject TracingExample extends zio.App {\n\n  def doSomething(input: Int): ZIO[Console, String, Unit] =\n    for {\n      _ <- console.putStrLn(s"Do something $input").orDie // line number 8\n      _ <- ZIO.fail("Boom!")\n      _ <- console.putStrLn("Finished my job").orDie\n    } yield ()\n\n  def myApp: ZIO[Console, String, Unit] =\n    for {\n      _ <- console.putStrLn("Hello!").orDie\n      _ <- doSomething(5)\n      _ <- console.putStrLn("Bye Bye!").orDie\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n')),(0,l.kt)("p",null,"The output would be something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Hello!\nDo something 5\nFiber failed.\nA checked error was not handled.\nBoom!\n\nFiber:Id(1634884059941,1) was supposed to continue to:\n  a future continuation at TracingExample$.myApp(TracingExample.scala:16)\n  a future continuation at zio.ZIO.exitCode(ZIO.scala:606)\n\nFiber:Id(1634884059941,1) execution trace:\n  at TracingExample$.doSomething(TracingExample.scala:8)\n  at zio.ZIO.orDieWith(ZIO.scala:1118)\n  at zio.ZIO.refineOrDieWith(ZIO.scala:1497)\n  at zio.console.package$Console$Service$.putStrLn(package.scala:44)\n  at zio.console.package$.putStrLn(package.scala:88)\n  at TracingExample$.myApp(TracingExample.scala:15)\n  at zio.ZIO.orDieWith(ZIO.scala:1118)\n  at zio.ZIO.refineOrDieWith(ZIO.scala:1497)\n  at zio.console.package$Console$Service$.putStrLn(package.scala:44)\n  at zio.console.package$.putStrLn(package.scala:88)\n\nFiber:Id(1634884059941,1) was spawned by:\n\nFiber:Id(1634884059516,0) was supposed to continue to:\n  a future continuation at zio.App.main(App.scala:59)\n  a future continuation at zio.App.main(App.scala:58)\n\nFiber:Id(1634884059516,0) ZIO Execution trace: <empty trace>\n\nFiber:Id(1634884059516,0) was spawned by: <empty trace>\n")),(0,l.kt)("p",null,"The execution trace, is somehow at a good degree informative, but it doesn't lead us to the exact point where the failure happened. It's a little hard to see what is going here. "),(0,l.kt)("p",null,"Let's rewrite the previous example in ZIO 2.0:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject TracingExample extends ZIOAppDefault {\n\n  def doSomething(input: Int): ZIO[Has[Console], String, Unit] =\n    for {\n      _ <- Console.printLine(s"Do something $input").orDie\n      _ <- ZIO.fail("Boom!") // line number 8\n      _ <- Console.printLine("Finished my job").orDie\n    } yield ()\n\n  def myApp: ZIO[Has[Console], String, Unit] =\n    for {\n      _ <- Console.printLine("Hello!").orDie\n      _ <- doSomething(5)\n      _ <- Console.printLine("Bye Bye!").orDie\n    } yield ()\n\n  def run = myApp\n}\n')),(0,l.kt)("p",null,"The output is more descriptive than the ZIO 1.x:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'Hello!\nDo something 5\ntimestamp=2021-10-22T06:24:57.958955503Z level=ERROR thread=#0 message="Fiber failed.\nA checked error was not handled.\nBoom!\n\nFiber:FiberId(1634883897813,2) was supposed to continue to:\n  a future continuation at \n  a future continuation at \n  a future continuation at \n  a future continuation at \n  a future continuation at \n  a future continuation at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:15:9)\n\nFiber:FiberId(1634883897813,2) execution trace:\n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:8:20)\n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:9)\n  at \n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:54)\n  at \n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:29)\n  at \n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:29)\n  at \n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:29)\n  at \n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:29)\n  at \n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:29)\n  at \n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:29)\n  at \n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:7:29)\n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:9)\n  at \n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:40)\n  at \n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:29)\n  at \n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:29)\n  at \n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:29)\n  at \n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:29)\n  at \n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:29)\n  at \n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:29)\n  at \n  at <empty>.TracingExample.myApp(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:14:29)\n  at \n')),(0,l.kt)("p",null,"As we see, the first line of execution trace, point to the exact location on the source code which causes the failure (",(0,l.kt)("inlineCode",{parentName:"p"},'ZIO.fail("Boom!")'),"), line number 8 and column 20:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Fiber:FiberId(1634883897813,2) execution trace:\n  at <empty>.TracingExample.doSomething(/home/user/sources/scala/zio/examples/shared/src/main/scala/TracingExample.scala:8:20)\n")),(0,l.kt)("p",null,"Another improvement about ZIO tracing is its performance. Tracing in ZIO 1.x slows down the application performance by two times. In ZIO 1.x, we wrap and unwrap every combinator at runtime to be able to trace the execution. While it is happening on the runtime, it takes a lot of allocations which all need to be garbage collected afterward. So it adds a huge amount of complexity at the runtime."),(0,l.kt)("p",null,"Some users often turn off the tracing when they need more speed, so they lose this ability to trace their application when something breaks."),(0,l.kt)("p",null,"In ZIO 2.x, we moved execution tracing from the run-time to the compile-time. This is done by capturing tracing information from source code at compile time using macros. So most tracing information is pre-allocated at startup and never needs garbage collected. As a result, we end up with much better performance in execution tracing."))}k.isMDXComponent=!0},1071:function(e,t,n){t.Z=n.p+"assets/images/zhub-ea552e52045d4185f6b1ca8e79e787f7.svg"},2347:function(e,t){t.Z="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjwhLS0gR2VuZXJhdGVkIGJ5IE1pY3Jvc29mdCBWaXNpbywgU1ZHIEV4cG9ydCB6aW8tc3RyZWFtcy0xLnN2ZyBQYWdlLTEgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZXY9Imh0dHA6Ly93d3cudzMub3JnLzIwMDEveG1sLWV2ZW50cyIKCQl4bWxuczp2PSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3Zpc2lvLzIwMDMvU1ZHRXh0ZW5zaW9ucy8iIHdpZHRoPSI1Ljc2NzM2aW4iIGhlaWdodD0iMS41MTczNmluIgoJCXZpZXdCb3g9IjAgMCA0MTUuMjUgMTA5LjI1IiB4bWw6c3BhY2U9InByZXNlcnZlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiIGNsYXNzPSJzdDYiPgoJPHY6ZG9jdW1lbnRQcm9wZXJ0aWVzIHY6bGFuZ0lEPSIxMDMzIiB2OnZpZXdNYXJrdXA9ImZhbHNlIj4KCQk8djp1c2VyRGVmcz4KCQkJPHY6dWQgdjpuYW1lVT0ibXN2Tm9BdXRvQ29ubmVjdCIgdjp2YWw9IlZUMCgxKToyNiIvPgoJCTwvdjp1c2VyRGVmcz4KCTwvdjpkb2N1bWVudFByb3BlcnRpZXM+CgoJPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCTwhW0NEQVRBWwoJCS5zdDEge2ZpbGw6dXJsKCNncmFkMC00KTtzdHJva2U6IzAwMDAwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjEuMjV9CgkJLnN0MiB7ZmlsbDojMDAwMDAwO2ZvbnQtZmFtaWx5OkNhbGlicmk7Zm9udC1zaXplOjEuNWVtfQoJCS5zdDMge21hcmtlci1lbmQ6dXJsKCNtcmtyNC0yMCk7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS13aWR0aDoxfQoJCS5zdDQge2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS13aWR0aDowLjI4NDA5MDkwOTA5MDkxfQoJCS5zdDUge2ZpbGw6bm9uZTtzdHJva2U6bm9uZTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjAuNzV9CgkJLnN0NiB7ZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO2ZvbnQtc2l6ZToxMnB4O292ZXJmbG93OnZpc2libGU7c3Ryb2tlLWxpbmVjYXA6c3F1YXJlO3N0cm9rZS1taXRlcmxpbWl0OjN9CgldXT4KCTwvc3R5bGU+CgoJPGRlZnMgaWQ9IlBhdHRlcm5zX0FuZF9HcmFkaWVudHMiPgoJCTxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZDAtNCIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjAiIGdyYWRpZW50VHJhbnNmb3JtPSJyb3RhdGUoOTAgMC41IDAuNSkiPgoJCQk8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCQk8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNkOGQ4ZDgiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8ZGVmcyBpZD0iTWFya2VycyI+CgkJPGcgaWQ9ImxlbmQ0Ij4KCQkJPHBhdGggZD0iTSAyIDEgTCAwIDAgTCAyIC0xIEwgMiAxICIgc3R5bGU9InN0cm9rZTpub25lIi8+CgkJPC9nPgoJCTxtYXJrZXIgaWQ9Im1ya3I0LTIwIiBjbGFzcz0ic3Q0IiB2OmFycm93VHlwZT0iNCIgdjphcnJvd1NpemU9IjIiIHY6c2V0YmFjaz0iNy4wNCIgcmVmWD0iLTcuMDQiIG9yaWVudD0iYXV0byIKCQkJCW1hcmtlclVuaXRzPSJzdHJva2VXaWR0aCIgb3ZlcmZsb3c9InZpc2libGUiPgoJCQk8dXNlIHhsaW5rOmhyZWY9IiNsZW5kNCIgdHJhbnNmb3JtPSJzY2FsZSgtMy41MiwtMy41MikgIi8+CgkJPC9tYXJrZXI+Cgk8L2RlZnM+Cgk8ZyB2Om1JRD0iMCIgdjppbmRleD0iMSIgdjpncm91cENvbnRleHQ9ImZvcmVncm91bmRQYWdlIj4KCQk8dGl0bGU+UGFnZS0xPC90aXRsZT4KCQk8djpwYWdlUHJvcGVydGllcyB2OmRyYXdpbmdTY2FsZT0iMSIgdjpwYWdlU2NhbGU9IjEiIHY6ZHJhd2luZ1VuaXRzPSIxOSIgdjpzaGFkb3dPZmZzZXRYPSI5IiB2OnNoYWRvd09mZnNldFk9Ii05Ii8+CgkJPHY6bGF5ZXIgdjpuYW1lPSJDb21tb24gSWNvbnMiIHY6aW5kZXg9IjAiLz4KCQk8djpsYXllciB2Om5hbWU9IkNvbm5lY3RvciIgdjppbmRleD0iMSIvPgoJCTx2OmxheWVyIHY6bmFtZT0iQ29udGFpbmVyIiB2OmluZGV4PSIyIi8+CgkJPGcgaWQ9InNoYXBlMS0xIiB2Om1JRD0iMSIgdjpncm91cENvbnRleHQ9InNoYXBlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOC42MjUsLTE4LjYyNSkiPgoJCQk8dGl0bGU+U2hlZXQuMTwvdGl0bGU+CgkJCTxkZXNjPlpTdHJlYW08L2Rlc2M+CgkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJPHY6dGV4dFJlY3QgY3g9IjU0IiBjeT0iNzMuMjUiIHdpZHRoPSIxMDguMDEiIGhlaWdodD0iNzIiLz4KCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQk8dGV4dCB4PSIyMy41MiIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlN0cmVhbTwvdGV4dD4JCTwvZz4KCQk8ZyBpZD0ic2hhcGUyLTYiIHY6bUlEPSIyIiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1My42MjUsLTE4LjYyNSkiPgoJCQk8dGl0bGU+U2hlZXQuMjwvdGl0bGU+CgkJCTxkZXNjPlpUcmFuc2R1Y2VyPC9kZXNjPgoJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCTx2OnRleHRSZWN0IGN4PSI1NCIgY3k9IjczLjI1IiB3aWR0aD0iMTA4LjAxIiBoZWlnaHQ9IjcyIi8+CgkJCTxyZWN0IHg9IjAiIHk9IjM3LjI1IiB3aWR0aD0iMTA4IiBoZWlnaHQ9IjcyIiByeD0iOSIgcnk9IjkiIGNsYXNzPSJzdDEiLz4KCQkJPHRleHQgeD0iOC44MiIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlRyYW5zZHVjZXI8L3RleHQ+CQk8L2c+CgkJPGcgaWQ9InNoYXBlNS0xMCIgdjptSUQ9IjUiIHY6Z3JvdXBDb250ZXh0PSJzaGFwZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjg4LjYyNSwtMTguNjI1KSI+CgkJCTx0aXRsZT5TaGVldC41PC90aXRsZT4KCQkJPGRlc2M+WlNpbms8L2Rlc2M+CgkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJPHY6dGV4dFJlY3QgY3g9IjU0IiBjeT0iNzMuMjUiIHdpZHRoPSIxMDguMDEiIGhlaWdodD0iNzIiLz4KCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQk8dGV4dCB4PSIzNC43NyIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlNpbms8L3RleHQ+CQk8L2c+CgkJPGcgaWQ9Imdyb3VwMTgtMTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2MS42MjUsLTQ1LjYyNSkiIHY6bUlEPSIxOCIgdjpncm91cENvbnRleHQ9Imdyb3VwIj4KCQkJPHRpdGxlPlNoZWV0LjE4PC90aXRsZT4KCQkJPGcgaWQ9InNoYXBlMTctMTUiIHY6bUlEPSIxNyIgdjpncm91cENvbnRleHQ9InNoYXBlIiB2OmxheWVyTWVtYmVyPSIxIj4KCQkJCTx0aXRsZT5EeW5hbWljIGNvbm5lY3RvcjwvdGl0bGU+CgkJCQk8cGF0aCBkPSJNMCAxMDAuMjUgTDE5Ljk2IDEwMC4yNSIgY2xhc3M9InN0MyIvPgoJCQk8L2c+CgkJPC9nPgoJCTxnIGlkPSJncm91cDE5LTIxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjcuMDc1LC00Ny40MjUpIiB2Om1JRD0iMTkiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCTx0aXRsZT5TaGVldC4xOTwvdGl0bGU+CgkJCTxnIGlkPSJzaGFwZTIwLTIyIiB2Om1JRD0iMjAiIHY6Z3JvdXBDb250ZXh0PSJzaGFwZSIgdjpsYXllck1lbWJlcj0iMSI+CgkJCQk8dGl0bGU+RHluYW1pYyBjb25uZWN0b3I8L3RpdGxlPgoJCQkJPHBhdGggZD0iTTAgMTAwLjI1IEwxOS45NiAxMDAuMjUiIGNsYXNzPSJzdDMiLz4KCQkJPC9nPgoJCTwvZz4KCQk8ZyBpZD0ic2hhcGUyMS0yNyIgdjptSUQ9IjIxIiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiPgoJCQk8dGl0bGU+U2hlZXQuMjE8L3RpdGxlPgoJCQk8cmVjdCB4PSIwIiB5PSIxLjI0OTk5IiB3aWR0aD0iNDE0IiBoZWlnaHQ9IjEwOCIgY2xhc3M9InN0NSIvPgoJCTwvZz4KCTwvZz4KPC9zdmc+Cg=="},2456:function(e,t){t.Z="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjwhLS0gR2VuZXJhdGVkIGJ5IE1pY3Jvc29mdCBWaXNpbywgU1ZHIEV4cG9ydCB6aW8tc3RyZWFtcy0yLnguc3ZnIFBhZ2UtMSAtLT4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpldj0iaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzIgoJCXhtbG5zOnY9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vdmlzaW8vMjAwMy9TVkdFeHRlbnNpb25zLyIgd2lkdGg9IjUuNzY3MzZpbiIgaGVpZ2h0PSIxLjUxNzM2aW4iCgkJdmlld0JveD0iMCAwIDQxNS4yNSAxMDkuMjUiIHhtbDpzcGFjZT0icHJlc2VydmUiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIgY2xhc3M9InN0NSI+Cgk8djpkb2N1bWVudFByb3BlcnRpZXMgdjpsYW5nSUQ9IjEwMzMiIHY6dmlld01hcmt1cD0iZmFsc2UiPgoJCTx2OnVzZXJEZWZzPgoJCQk8djp1ZCB2Om5hbWVVPSJtc3ZOb0F1dG9Db25uZWN0IiB2OnZhbD0iVlQwKDEpOjI2Ii8+CgkJPC92OnVzZXJEZWZzPgoJPC92OmRvY3VtZW50UHJvcGVydGllcz4KCgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJPCFbQ0RBVEFbCgkJLnN0MSB7ZmlsbDp1cmwoI2dyYWQwLTUpO3N0cm9rZTojMDAwMDAwO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utd2lkdGg6MS4yNX0KCQkuc3QyIHtmaWxsOiMwMDAwMDA7Zm9udC1mYW1pbHk6Q2FsaWJyaTtmb250LXNpemU6MS41ZW19CgkJLnN0MyB7bWFya2VyLWVuZDp1cmwoI21ya3I0LTIxKTtzdHJva2U6IzAwMDAwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjF9CgkJLnN0NCB7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLXdpZHRoOjAuMjg0MDkwOTA5MDkwOTF9CgkJLnN0NSB7ZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO2ZvbnQtc2l6ZToxMnB4O292ZXJmbG93OnZpc2libGU7c3Ryb2tlLWxpbmVjYXA6c3F1YXJlO3N0cm9rZS1taXRlcmxpbWl0OjN9CgldXT4KCTwvc3R5bGU+CgoJPGRlZnMgaWQ9IlBhdHRlcm5zX0FuZF9HcmFkaWVudHMiPgoJCTxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZDAtNSIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjAiIGdyYWRpZW50VHJhbnNmb3JtPSJyb3RhdGUoOTAgMC41IDAuNSkiPgoJCQk8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCQk8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNkOGQ4ZDgiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8ZGVmcyBpZD0iTWFya2VycyI+CgkJPGcgaWQ9ImxlbmQ0Ij4KCQkJPHBhdGggZD0iTSAyIDEgTCAwIDAgTCAyIC0xIEwgMiAxICIgc3R5bGU9InN0cm9rZTpub25lIi8+CgkJPC9nPgoJCTxtYXJrZXIgaWQ9Im1ya3I0LTIxIiBjbGFzcz0ic3Q0IiB2OmFycm93VHlwZT0iNCIgdjphcnJvd1NpemU9IjIiIHY6c2V0YmFjaz0iNy4wNCIgcmVmWD0iLTcuMDQiIG9yaWVudD0iYXV0byIKCQkJCW1hcmtlclVuaXRzPSJzdHJva2VXaWR0aCIgb3ZlcmZsb3c9InZpc2libGUiPgoJCQk8dXNlIHhsaW5rOmhyZWY9IiNsZW5kNCIgdHJhbnNmb3JtPSJzY2FsZSgtMy41MiwtMy41MikgIi8+CgkJPC9tYXJrZXI+Cgk8L2RlZnM+Cgk8ZyB2Om1JRD0iMCIgdjppbmRleD0iMSIgdjpncm91cENvbnRleHQ9ImZvcmVncm91bmRQYWdlIj4KCQk8dGl0bGU+UGFnZS0xPC90aXRsZT4KCQk8djpwYWdlUHJvcGVydGllcyB2OmRyYXdpbmdTY2FsZT0iMSIgdjpwYWdlU2NhbGU9IjEiIHY6ZHJhd2luZ1VuaXRzPSIxOSIgdjpzaGFkb3dPZmZzZXRYPSI5IiB2OnNoYWRvd09mZnNldFk9Ii05Ii8+CgkJPHY6bGF5ZXIgdjpuYW1lPSJDb25uZWN0b3IiIHY6aW5kZXg9IjAiLz4KCQk8ZyBpZD0iZ3JvdXAxLTEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4LjYyNSwtMTguNjI1KSIgdjptSUQ9IjEiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCTx0aXRsZT5TaGVldC4xPC90aXRsZT4KCQkJPGcgaWQ9InNoYXBlMi0yIiB2Om1JRD0iMiIgdjpncm91cENvbnRleHQ9InNoYXBlIj4KCQkJCTx0aXRsZT5TaGVldC4yPC90aXRsZT4KCQkJCTxkZXNjPlpTdHJlYW08L2Rlc2M+CgkJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCQk8djp0ZXh0UmVjdCBjeD0iNTQiIGN5PSI3My4yNSIgd2lkdGg9IjEwOC4wMSIgaGVpZ2h0PSI3MiIvPgoJCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQkJPHRleHQgeD0iMjMuNTIiIHk9Ijc4LjY1IiBjbGFzcz0ic3QyIiB2OmxhbmdJRD0iMTAzMyI+PHY6cGFyYWdyYXBoIHY6aG9yaXpBbGlnbj0iMSIvPjx2OnRhYkxpc3QvPlpTdHJlYW08L3RleHQ+CQkJPC9nPgoJCQk8ZyBpZD0ic2hhcGUzLTciIHY6bUlEPSIzIiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNSwwKSI+CgkJCQk8dGl0bGU+U2hlZXQuMzwvdGl0bGU+CgkJCQk8ZGVzYz5aUGlwZWxpbmU8L2Rlc2M+CgkJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCQk8djp0ZXh0UmVjdCBjeD0iNTQiIGN5PSI3My4yNSIgd2lkdGg9IjEwOC4wMSIgaGVpZ2h0PSI3MiIvPgoJCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQkJPHRleHQgeD0iMjAuNTMiIHk9Ijc4LjY1IiBjbGFzcz0ic3QyIiB2OmxhbmdJRD0iMTAzMyI+PHY6cGFyYWdyYXBoIHY6aG9yaXpBbGlnbj0iMSIvPjx2OnRhYkxpc3QvPlpQaXBlbGluZTwvdGV4dD4JCQk8L2c+CgkJCTxnIGlkPSJzaGFwZTQtMTEiIHY6bUlEPSI0IiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3MCwwKSI+CgkJCQk8dGl0bGU+U2hlZXQuNDwvdGl0bGU+CgkJCQk8ZGVzYz5aU2luazwvZGVzYz4KCQkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJCTx2OnRleHRSZWN0IGN4PSI1NCIgY3k9IjczLjI1IiB3aWR0aD0iMTA4LjAxIiBoZWlnaHQ9IjcyIi8+CgkJCQk8cmVjdCB4PSIwIiB5PSIzNy4yNSIgd2lkdGg9IjEwOCIgaGVpZ2h0PSI3MiIgcng9IjkiIHJ5PSI5IiBjbGFzcz0ic3QxIi8+CgkJCQk8dGV4dCB4PSIzNC43NyIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlNpbms8L3RleHQ+CQkJPC9nPgoJCQk8ZyBpZD0iZ3JvdXA1LTE1IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNDMsLTI3KSIgdjptSUQ9IjUiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCQk8dGl0bGU+U2hlZXQuNTwvdGl0bGU+CgkJCQk8ZyBpZD0ic2hhcGU2LTE2IiB2Om1JRD0iNiIgdjpncm91cENvbnRleHQ9InNoYXBlIiB2OmxheWVyTWVtYmVyPSIwIj4KCQkJCQk8dGl0bGU+RHluYW1pYyBjb25uZWN0b3I8L3RpdGxlPgoJCQkJCTxwYXRoIGQ9Ik0wIDEwMC4yNSBMMTkuOTYgMTAwLjI1IiBjbGFzcz0ic3QzIi8+CgkJCQk8L2c+CgkJCTwvZz4KCQkJPGcgaWQ9Imdyb3VwNy0yMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA4LjQ1LC0yOC44KSIgdjptSUQ9IjciIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCQk8dGl0bGU+U2hlZXQuNzwvdGl0bGU+CgkJCQk8ZyBpZD0ic2hhcGU4LTIzIiB2Om1JRD0iOCIgdjpncm91cENvbnRleHQ9InNoYXBlIiB2OmxheWVyTWVtYmVyPSIwIj4KCQkJCQk8dGl0bGU+RHluYW1pYyBjb25uZWN0b3I8L3RpdGxlPgoJCQkJCTxwYXRoIGQ9Ik0wIDEwMC4yNSBMMTkuOTYgMTAwLjI1IiBjbGFzcz0ic3QzIi8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+Cjwvc3ZnPgo="},199:function(e,t){t.Z="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjwhLS0gR2VuZXJhdGVkIGJ5IE1pY3Jvc29mdCBWaXNpbywgU1ZHIEV4cG9ydCB6aW8tc3RyZWFtcy16Y2hhbm5lbC5zdmcgUGFnZS0xIC0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiCgkJeG1sbnM6dj0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS92aXNpby8yMDAzL1NWR0V4dGVuc2lvbnMvIiB3aWR0aD0iNi4yNjA0MmluIiBoZWlnaHQ9IjIuMDEwNDJpbiIKCQl2aWV3Qm94PSIwIDAgNDUwLjc1IDE0NC43NSIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIiBjbGFzcz0ic3Q1Ij4KCTx2OmRvY3VtZW50UHJvcGVydGllcyB2OmxhbmdJRD0iMTAzMyIgdjp2aWV3TWFya3VwPSJmYWxzZSI+CgkJPHY6dXNlckRlZnM+CgkJCTx2OnVkIHY6bmFtZVU9Im1zdk5vQXV0b0Nvbm5lY3QiIHY6dmFsPSJWVDAoMSk6MjYiLz4KCQk8L3Y6dXNlckRlZnM+Cgk8L3Y6ZG9jdW1lbnRQcm9wZXJ0aWVzPgoKCTxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgk8IVtDREFUQVsKCQkuc3QxIHtmaWxsOm5vbmU7c3Ryb2tlOm5vbmU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS13aWR0aDowLjc1fQoJCS5zdDIge2ZpbGw6I2ZjZWJkZDtzdHJva2U6IzAwMDAwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjEuMjV9CgkJLnN0MyB7ZmlsbDojMDAwMDAwO2ZvbnQtZmFtaWx5OkNhbGlicmk7Zm9udC1zaXplOjEuNWVtfQoJCS5zdDQge2ZpbGw6dXJsKCNncmFkMC0xMSk7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS13aWR0aDoxLjI1fQoJCS5zdDUge2ZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtmb250LXNpemU6MTJweDtvdmVyZmxvdzp2aXNpYmxlO3N0cm9rZS1saW5lY2FwOnNxdWFyZTtzdHJva2UtbWl0ZXJsaW1pdDozfQoJXV0+Cgk8L3N0eWxlPgoKCTxkZWZzIGlkPSJQYXR0ZXJuc19BbmRfR3JhZGllbnRzIj4KCQk8bGluZWFyR3JhZGllbnQgaWQ9ImdyYWQwLTExIiB4MT0iMCIgeTE9IjAiIHgyPSIxIiB5Mj0iMCIgZ3JhZGllbnRUcmFuc2Zvcm09InJvdGF0ZSg5MCAwLjUgMC41KSI+CgkJCTxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CgkJCTxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2Q4ZDhkOCIgc3RvcC1vcGFjaXR5PSIxIi8+CgkJPC9saW5lYXJHcmFkaWVudD4KCTwvZGVmcz4KCTxnIHY6bUlEPSIwIiB2OmluZGV4PSIxIiB2Omdyb3VwQ29udGV4dD0iZm9yZWdyb3VuZFBhZ2UiPgoJCTx0aXRsZT5QYWdlLTE8L3RpdGxlPgoJCTx2OnBhZ2VQcm9wZXJ0aWVzIHY6ZHJhd2luZ1NjYWxlPSIxIiB2OnBhZ2VTY2FsZT0iMSIgdjpkcmF3aW5nVW5pdHM9IjE5IiB2OnNoYWRvd09mZnNldFg9IjkiIHY6c2hhZG93T2Zmc2V0WT0iLTkiLz4KCQk8djpsYXllciB2Om5hbWU9IkNvbm5lY3RvciIgdjppbmRleD0iMCIvPgoJCTxnIGlkPSJncm91cDQtMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjgwLC02NCkiIHY6bUlEPSI0IiB2Omdyb3VwQ29udGV4dD0iZ3JvdXAiPgoJCQk8dGl0bGU+U2hlZXQuNDwvdGl0bGU+CgkJPC9nPgoJCTxnIGlkPSJncm91cDYtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQ1LjQ1LC02NS44KSIgdjptSUQ9IjYiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCTx0aXRsZT5TaGVldC42PC90aXRsZT4KCQk8L2c+CgkJPGcgaWQ9InNoYXBlOC0zIiB2Om1JRD0iOCIgdjpncm91cENvbnRleHQ9InNoYXBlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOC4zNzUsLTE4LjM3NSkiPgoJCQk8dGl0bGU+U2hlZXQuODwvdGl0bGU+CgkJCTxyZWN0IHg9IjAiIHk9IjM2Ljc1IiB3aWR0aD0iNDE0IiBoZWlnaHQ9IjEwOCIgY2xhc3M9InN0MSIvPgoJCTwvZz4KCQk8ZyBpZD0ic2hhcGU5LTUiIHY6bUlEPSI5IiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4LjE4NzUsLTE4KSI+CgkJCTx0aXRsZT5TaGVldC45PC90aXRsZT4KCQkJPGRlc2M+WkNoYW5uZWw8L2Rlc2M+CgkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJPHY6dGV4dFJlY3QgY3g9IjIwNy4yODEiIGN5PSI5MS4wMzEyIiB3aWR0aD0iNDE0LjU3IiBoZWlnaHQ9IjEwNy40MzgiLz4KCQkJPHJlY3QgeD0iMCIgeT0iMzcuMzEyNSIgd2lkdGg9IjQxNC41NjIiIGhlaWdodD0iMTA3LjQzOCIgcng9IjkiIHJ5PSI5IiBjbGFzcz0ic3QyIi8+CgkJCTx0ZXh0IHg9IjE3My4yMyIgeT0iOTYuNDMiIGNsYXNzPSJzdDMiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WkNoYW5uZWw8L3RleHQ+CQk8L2c+CgkJPGcgaWQ9InNoYXBlMy04IiB2Om1JRD0iMyIgdjpncm91cENvbnRleHQ9InNoYXBlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMDcsLTM3KSI+CgkJCTx0aXRsZT5TaGVldC4zPC90aXRsZT4KCQkJPGRlc2M+WlNpbms8L2Rlc2M+CgkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJPHY6dGV4dFJlY3QgY3g9IjU0IiBjeT0iMTA4Ljc1IiB3aWR0aD0iMTA4LjAxIiBoZWlnaHQ9IjcyIi8+CgkJCTxyZWN0IHg9IjAiIHk9IjcyLjc1IiB3aWR0aD0iMTA4IiBoZWlnaHQ9IjcyIiByeD0iOSIgcnk9IjkiIGNsYXNzPSJzdDQiLz4KCQkJPHRleHQgeD0iMzQuNzciIHk9IjExNC4xNSIgY2xhc3M9InN0MyIgdjpsYW5nSUQ9IjEwMzMiPjx2OnBhcmFncmFwaCB2Omhvcml6QWxpZ249IjEiLz48djp0YWJMaXN0Lz5aU2luazwvdGV4dD4JCTwvZz4KCQk8ZyBpZD0ic2hhcGUxLTEzIiB2Om1JRD0iMSIgdjpncm91cENvbnRleHQ9InNoYXBlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNywtMzcpIj4KCQkJPHRpdGxlPlNoZWV0LjE8L3RpdGxlPgoJCQk8ZGVzYz5aU3RyZWFtPC9kZXNjPgoJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCTx2OnRleHRSZWN0IGN4PSI1NCIgY3k9IjEwOC43NSIgd2lkdGg9IjEwOC4wMSIgaGVpZ2h0PSI3MiIvPgoJCQk8cmVjdCB4PSIwIiB5PSI3Mi43NSIgd2lkdGg9IjEwOCIgaGVpZ2h0PSI3MiIgcng9IjkiIHJ5PSI5IiBjbGFzcz0ic3Q0Ii8+CgkJCTx0ZXh0IHg9IjIzLjUyIiB5PSIxMTQuMTUiIGNsYXNzPSJzdDMiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlN0cmVhbTwvdGV4dD4JCTwvZz4KCTwvZz4KPC9zdmc+Cg=="}}]);