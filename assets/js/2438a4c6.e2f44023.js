"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[1307],{3905:function(e,t,r){r.d(t,{Zo:function(){return s},kt:function(){return d}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),p=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},s=function(e){var t=p(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=p(r),d=o,k=m["".concat(c,".").concat(d)]||m[d]||u[d]||a;return r?n.createElement(k,i(i({ref:t},s),{},{components:r})):n.createElement(k,i({ref:t},s))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},3411:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return s},default:function(){return m}});var n=r(7462),o=r(3366),a=(r(7294),r(3905)),i=["components"],l={id:"zparkio",title:"ZparkIO"},c=void 0,p={unversionedId:"resources/ecosystem/community/zparkio",id:"resources/ecosystem/community/zparkio",isDocsHomePage:!1,title:"ZparkIO",description:"ZParkIO is a boilerplate framework to use Spark and ZIO together.",source:"@site/docs/resources/ecosystem/community/zparkio.md",sourceDirName:"resources/ecosystem/community",slug:"/resources/ecosystem/community/zparkio",permalink:"/next/resources/ecosystem/community/zparkio",editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/resources/ecosystem/community/zparkio.md",tags:[],version:"current",frontMatter:{id:"zparkio",title:"ZparkIO"}},s=[{value:"Introduction",id:"introduction",children:[],level:2},{value:"Installation",id:"installation",children:[],level:2},{value:"Example",id:"example",children:[],level:2},{value:"Resources",id:"resources",children:[],level:2}],u={toc:s};function m(e){var t=e.components,r=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/leobenkel/ZparkIO"},"ZParkIO")," is a boilerplate framework to use ",(0,a.kt)("em",{parentName:"p"},"Spark")," and ",(0,a.kt)("em",{parentName:"p"},"ZIO")," together."),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"ZparkIO")," enables us to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Wrap asynchronous and synchronous operations smoothly. So everything is wrapped in ZIO."),(0,a.kt)("li",{parentName:"ul"},"Have ZIO features in our spark jobs, like forking and joining fibers, parallelizing tasks, retrying, and timing-out."),(0,a.kt)("li",{parentName:"ul"},"Make our spark job much easier to debug")),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,a.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "com.leobenkel" %% "zparkio" % "[SPARK_VERSION]_[VERSION]"\n')),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"Using ",(0,a.kt)("em",{parentName:"p"},"ZparkIO")," we can write jobs like the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import com.leobenkel.zparkio.Services.SparkModule\nimport com.leobenkel.zparkio.Services.SparkModule.SparkModule\nimport com.leobenkel.zparkio.ZparkioApplicationTimeoutException\nimport org.apache.spark.sql.DataFrame\nimport zio.clock.Clock\nimport zio.duration.durationInt\nimport zio.{Schedule, Task, ZIO}\n\ndef readParquetFile[A](parquetPath: String): ZIO[Clock with SparkModule, Throwable, DataFrame] =\n  for {\n    spark <- SparkModule()\n    dataset <- Task(spark.read.parquet(parquetPath))\n      .retry(\n        Schedule.recurs(3) && Schedule.exponential(2.seconds)\n      )\n      .timeoutFail(ZparkioApplicationTimeoutException())(5.minutes)\n  } yield dataset\n")),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=bWgVGzb5-H8"},"Accelerating Spark with ZIO")," by Leo Benkel (December 2020) \u2014 Apache Spark is a powerful tool for distributed analytics but isn\u2019t built to offer rich primitives for local parallelism. Yet, using local parallelism, it is possible to dramatically improve the performance of ML projects\u2014for example, by fetching data sources in parallel. Historically, Scala projects have used Scala's Future for local parallelism, but increasingly, many projects have begun adopting ZIO as a better Future. Although powerful, ZIO is not easy to set up with Spark. In this talk, Leo will introduce an open-source library that handles all boilerplate so you can easily implement Spark and ZIO in your ML projects, and will then present detailed benchmarks showing how much additional performance can be obtained through local parallelism. Learn how to use ZIO to make Spark better and faster!")))}m.isMDXComponent=!0}}]);