<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="search" type="application/opensearchdescription+xml" title="ZIO" href="/opensearch.xml">
<link rel="stylesheet" href="/css/prism/prism-material-dark.css"><title data-react-helmet="true">Ref | ZIO</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://zio.dev/next/datatypes/concurrency/ref"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Ref | ZIO"><meta data-react-helmet="true" name="description" content="Ref[A] models a mutable reference to a value of type A in which we can store immutable data. The two basic operations are set, which fills the Ref with a new value, and get, which retrieves its current content."><meta data-react-helmet="true" property="og:description" content="Ref[A] models a mutable reference to a value of type A in which we can store immutable data. The two basic operations are set, which fills the Ref with a new value, and get, which retrieves its current content."><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://zio.dev/next/datatypes/concurrency/ref"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/next/datatypes/concurrency/ref" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/next/datatypes/concurrency/ref" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.6feee118.css">
<link rel="preload" href="/assets/js/runtime~main.183b2960.js" as="script">
<link rel="preload" href="/assets/js/main.eb82bc51.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_W2Cr themedImage--dark_oUvU"></div></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/version-1.x/overview/">Overview</a><a class="navbar__item navbar__link" href="/version-1.x/datatypes/">Data Types</a><a class="navbar__item navbar__link" href="/version-1.x/usecases/">Use Cases</a><a class="navbar__item navbar__link" href="/version-1.x/howto/">How to</a><a class="navbar__item navbar__link" href="/version-1.x/resources/">Resources</a><a class="navbar__item navbar__link" href="/version-1.x/about/">About</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/next/overview/">ZIO 2.x (WIP)</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/next/datatypes/concurrency/ref">ZIO 2.x (WIP)</a></li><li><a class="dropdown__link" href="/version-1.x/datatypes/concurrency/ref">ZIO 1.x</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/">Overview</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/core/zio/">Core Data Types</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/contextual/">Contextual Types</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/next/datatypes/fiber/">Concurrency</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/next/datatypes/fiber/">ZIO Fibers</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/next/datatypes/concurrency/">Concurrency Primitives</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/next/datatypes/concurrency/ref">Mutable References</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/next/datatypes/concurrency/ref">Ref</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/refsynchronized">Ref.Synchronized</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/promise">Promise</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/queue">Queue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/hub">Hub</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/semaphore">Semaphore</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/next/datatypes/stm/">STM</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/resource/">Resource Management</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/stream/">Streaming</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/metrics/">Metrics</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/test/">ZIO Test</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/misc/chunk">Miscellaneous</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for <!-- -->ZIO<!-- --> <b>ZIO 2.x (WIP)</b> version.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/version-1.x/datatypes/concurrency/ref">latest version</a></b> (<!-- -->ZIO 1.x<!-- -->).</div></div><div class="docItemContainer_vinB"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->ZIO 2.x (WIP)</span><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Ref</h1></header><p><code>Ref[A]</code> models a <strong>mutable reference</strong> to a value of type <code>A</code> in which we can store <strong>immutable</strong> data. The two basic operations are <code>set</code>, which fills the <code>Ref</code> with a new value, and <code>get</code>, which retrieves its current content.</p><p><code>Ref</code> provides us a way to functionally manage in-memory state. All operations on <code>Ref</code> are atomic and thread-safe, giving us a reliable foundation for synchronizing concurrent programs.</p><p><code>Ref</code>:</p><ul><li>is purely functional and referentially transparent</li><li>is concurrent-safe and lock-free</li><li>updates and modifies atomically</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="concurrent-stateful-application">Concurrent Stateful Application<a class="hash-link" href="#concurrent-stateful-application" title="Direct link to heading">â€‹</a></h2><p><strong><code>Ref</code> is the foundation for writing concurrent stateful applications</strong>. Anytime we need to share information between multiple fibers, and those fibers have to update the same information, they need to communicate through something that provides the guarantee of atomicity. Because <code>Ref</code> is <strong>concurrent-safe</strong>, we can share the same <code>Ref</code> among many fibers. All of which can update <code>Ref</code> concurrently, removing the worry of race conditions. Even if we had ten thousand fibers all updating the same <code>Ref</code>, as long as they are using atomic update and modify functions, we will have zero race conditions.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="operations">Operations<a class="hash-link" href="#operations" title="Direct link to heading">â€‹</a></h2><p>Though <code>Ref</code> has many operations, here we will introduce the most common and important ones.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="make">make<a class="hash-link" href="#make" title="Direct link to heading">â€‹</a></h3><p><code>Ref</code> is never empty, it always contains something. We can create a <code>Ref</code> by providing the initial value to its <code>make</code> method, a constructor of the <code>Ref</code> data type. We should pass an <strong>immutable value</strong> of type <code>A</code> to the constructor, and it returns an <code>UIO[Ref[A]]</code> value:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def make[A](a: A): UIO[Ref[A]]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As we can see, the output is wrapped in<code>UIO</code>, which means creating a <code>Ref</code> is effectful. Whenever we <code>make</code>, <code>update</code>, or <code>modify</code> the <code>Ref</code>, we are performing an effectful operation.</p><p>Let&#x27;s create some <code>Ref</code>s from immutable values:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val counterRef = Ref.make(0)</span><br></span><span class="token-line"><span class="token plain">// counterRef: UIO[Ref[Int]] = zio.ZIO$Succeed@7f54736f</span><br></span><span class="token-line"><span class="token plain">val stringRef = Ref.make(&quot;initial&quot;) </span><br></span><span class="token-line"><span class="token plain">// stringRef: UIO[Ref[String]] = zio.ZIO$Succeed@460d7154 </span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">sealed trait State</span><br></span><span class="token-line"><span class="token plain">case object Active  extends State</span><br></span><span class="token-line"><span class="token plain">case object Changed extends State</span><br></span><span class="token-line"><span class="token plain">case object Closed  extends State</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val stateRef = Ref.make(Active) </span><br></span><span class="token-line"><span class="token plain">// stateRef: UIO[Ref[Active.type]] = zio.ZIO$Succeed@2876f824</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p><em><strong>Warning</strong></em>:  </p><p>A big mistake when creating a <code>Ref</code> is trying to store mutable data inside it. A<code>Ref</code> must be used with <strong>immutable data</strong>. Otherwise, we lose our atomic guarantees, which can lead to collisions and race conditions. </p></blockquote><p>The following snippet compiles, but it leads to race conditions due to a mutable variable being provided to <code>make</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">// Compiles but don&#x27;t work properly</span><br></span><span class="token-line"><span class="token plain">var init = 0</span><br></span><span class="token-line"><span class="token plain">// init: Int = 0</span><br></span><span class="token-line"><span class="token plain">val counterRef = Ref.make(init)</span><br></span><span class="token-line"><span class="token plain">// counterRef: UIO[Ref[Int]] = zio.ZIO$Succeed@18dfa02f</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To correct this, we should change the <code>init</code> to be immutable:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val init = 0</span><br></span><span class="token-line"><span class="token plain">// init: Int = 0</span><br></span><span class="token-line"><span class="token plain">val counterRef = Ref.make(init)</span><br></span><span class="token-line"><span class="token plain">// counterRef: UIO[Ref[Int]] = zio.ZIO$Succeed@5d5ab5ba</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="get">get<a class="hash-link" href="#get" title="Direct link to heading">â€‹</a></h3><p>The <code>get</code> method returns the current value of the reference. Its return type is <code>IO[EB, B]</code> in which <code>B</code> is the value type of the effect and in the failure case, <code>EB</code> is the error type of that effect.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def get: IO[EB, B]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As the <code>make</code> and <code>get</code> methods of <code>Ref</code> are effectful, we can chain them together with <code>flatMap</code>. In the following example, we create a <code>Ref</code> with <code>initial</code> value, and then we acquire the current state with the <code>get</code> method:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">Ref.make(&quot;initial&quot;)</span><br></span><span class="token-line"><span class="token plain">   .flatMap(_.get)</span><br></span><span class="token-line"><span class="token plain">   .flatMap(current =&gt; Console.printLine(s&quot;current value of ref: $current&quot;))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We can refactor this to use a for-comprehension rather than a series of <code>flatMap</code>s to increase readability:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">for {</span><br></span><span class="token-line"><span class="token plain">  ref   &lt;- Ref.make(&quot;initial&quot;)</span><br></span><span class="token-line"><span class="token plain">  value &lt;- ref.get</span><br></span><span class="token-line"><span class="token plain">} yield assert(value == &quot;initial&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Note that, there is no way to access the shared state outside the monadic operations.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="set">set<a class="hash-link" href="#set" title="Direct link to heading">â€‹</a></h3><p>The <code>set</code> method atomically writes a new value to the <code>Ref</code>.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">for {</span><br></span><span class="token-line"><span class="token plain">  ref   &lt;- Ref.make(&quot;initial&quot;)</span><br></span><span class="token-line"><span class="token plain">  _     &lt;- ref.set(&quot;update&quot;)</span><br></span><span class="token-line"><span class="token plain">  value &lt;- ref.get</span><br></span><span class="token-line"><span class="token plain">} yield assert(value == &quot;update&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="update">update<a class="hash-link" href="#update" title="Direct link to heading">â€‹</a></h3><p>With <code>update</code>, we can atomically update the state of <code>Ref</code> with a given <strong>pure</strong> function, that is, it needs to be deterministic and free of side effects.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def update(f: A =&gt; A): IO[E, Unit]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Assume we have a counter, we can increase its value with the <code>update</code> method:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val counterInitial = 0</span><br></span><span class="token-line"><span class="token plain">for {</span><br></span><span class="token-line"><span class="token plain">  counterRef &lt;- Ref.make(counterInitial)</span><br></span><span class="token-line"><span class="token plain">  _          &lt;- counterRef.update(_ + 1)</span><br></span><span class="token-line"><span class="token plain">  value &lt;- counterRef.get</span><br></span><span class="token-line"><span class="token plain">} yield assert(value == 1)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p><strong>Note</strong>:  </p><p><code>update</code> is not the composition of <code>get</code> and <code>set</code>. This composition is not concurrent-safe. Whenever we need to update our state, we should use the <code>update</code> operation which modifies its <code>Ref</code> atomically. </p></blockquote><p>For example, the following snippet is not concurrent-safe:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">// Unsafe State Management</span><br></span><span class="token-line"><span class="token plain">object UnsafeCountRequests extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def request(counter: Ref[Int]) = for {</span><br></span><span class="token-line"><span class="token plain">    current &lt;- counter.get</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- counter.set(current + 1)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  private val initial = 0</span><br></span><span class="token-line"><span class="token plain">  private val myApp =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      ref &lt;- Ref.make(initial)</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- request(ref) zipPar request(ref)</span><br></span><span class="token-line"><span class="token plain">      rn &lt;- ref.get</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- Console.printLine(s&quot;total requests performed: $rn&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The above snippet doesn&#x27;t behave deterministically. This program sometimes prints <code>2</code> and sometimes prints <code>1</code>. We can fix it by using <code>update</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">// Safe State Management</span><br></span><span class="token-line"><span class="token plain">object CountRequests extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def request(counter: Ref[Int]): ZIO[Any, Nothing, Unit] = {</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- counter.update(_ + 1)</span><br></span><span class="token-line"><span class="token plain">      reqNumber &lt;- counter.get</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- Console.printLine(s&quot;request number: $reqNumber&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  private val initial = 0</span><br></span><span class="token-line"><span class="token plain">  private val myApp =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      ref &lt;- Ref.make(initial)</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- request(ref) zipPar request(ref)</span><br></span><span class="token-line"><span class="token plain">      rn &lt;- ref.get</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- Console.printLine(s&quot;total requests performed: $rn&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here is another use case of <code>update</code> to write a <code>repeat</code> combinator:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def repeat[E, A](n: Int)(io: IO[E, A]): IO[E, Unit] =</span><br></span><span class="token-line"><span class="token plain">  Ref.make(0).flatMap { iRef =&gt;</span><br></span><span class="token-line"><span class="token plain">    def loop: IO[E, Unit] = iRef.get.flatMap { i =&gt;</span><br></span><span class="token-line"><span class="token plain">      if (i &lt; n)</span><br></span><span class="token-line"><span class="token plain">        io *&gt; iRef.update(_ + 1) *&gt; loop</span><br></span><span class="token-line"><span class="token plain">      else</span><br></span><span class="token-line"><span class="token plain">        IO.unit</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">    loop</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="modify">modify<a class="hash-link" href="#modify" title="Direct link to heading">â€‹</a></h3><p><code>modify</code> is a more powerful version of <code>update</code>. It atomically modifies <code>Ref</code> by the given function, and also computes a return value. The function that we pass to <code>modify</code> needs to be a pure function; it needs to be deterministic and free of side effects.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def modify[B](f: A =&gt; (B, A)): IO[E, B]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Remember the <code>CountRequest</code> example. What if we want to log the number of each request inside the <code>request</code> function? Let&#x27;s see what happens if we write that function with the composition of <code>update</code> and <code>get</code> methods:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">// Unsafe in Concurrent Environment</span><br></span><span class="token-line"><span class="token plain">def request(counter: Ref[Int]) = {</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    _  &lt;- counter.update(_ + 1)</span><br></span><span class="token-line"><span class="token plain">    rn &lt;- counter.get</span><br></span><span class="token-line"><span class="token plain">    _  &lt;- Console.printLine(s&quot;request number received: $rn&quot;)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>What happens if, between running <code>update</code> and <code>get</code>, a second <code>update</code> occurs on another fiber? This would not behave deterministically in concurrent environments. So we need a way to perform a combination of <strong>get, set, get</strong> atomically. This is where <code>modify</code> comes in. Here we will edit <code>request</code> to use <code>modify</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">// Safe in Concurrent Environment</span><br></span><span class="token-line"><span class="token plain">def request(counter: Ref[Int]) = {</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    rn &lt;- counter.modify(c =&gt; (c + 1, c + 1))</span><br></span><span class="token-line"><span class="token plain">    _  &lt;- Console.printLine(s&quot;request number received: $rn&quot;)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="atomicreference-in-java">AtomicReference in Java<a class="hash-link" href="#atomicreference-in-java" title="Direct link to heading">â€‹</a></h2><p>For Java programmers, we can think of <code>Ref</code> as an <code>AtomicReference</code>. Java has a <code>java.util.concurrent.atomic</code> package which contains <code>AtomicReference</code>, <code>AtomicLong</code>, <code>AtomicBoolean</code> and so forth. <code>Ref</code> has roughly the same power, guarantees, and limitations as <code>AtomicReference</code>, but is higher-level and ZIO-friendly. </p><h2 class="anchor anchorWithStickyNavbar_mojV" id="ref-vs-state-monad">Ref vs. State Monad<a class="hash-link" href="#ref-vs-state-monad" title="Direct link to heading">â€‹</a></h2><p>Basically <code>Ref</code> allows us to have all the power of State Monad inside ZIO. State Monad lacks two important features that we use in real-life application development:</p><ol><li>Concurrency Support</li><li>Error Handling</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="concurrency">Concurrency<a class="hash-link" href="#concurrency" title="Direct link to heading">â€‹</a></h3><p>State Monad is an effect system that only includes state. It allows us to do pure stateful computations. We can only get, set, and update (and related computations) state. State Monad updates its state with series of stateful computations sequentially, but <strong>it can&#x27;t be used to do async or concurrent computations</strong>. <code>Ref</code>, in contrast, has great support for concurrent and async programming.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="error-handling">Error Handling<a class="hash-link" href="#error-handling" title="Direct link to heading">â€‹</a></h3><p>In most real-life,stateful applications, we will involve some database IO and API calls and/or some concurrent and sync operations which can fail in different ways along the path of execution. So besides state management, we need a way to handle errors. The State Monad doesn&#x27;t have the ability to model error management. We can combine State Monad and Either Monad with StateT monad transformer, but it imposes massive performance overhead. It doesn&#x27;t buy us anything that we can&#x27;t do with <code>Ref</code>. So it is an anti-pattern. In the ZIO model, errors are encoded in effects and <code>Ref</code> utilizes that. So, in addition to state management, we have the ability to handle errors without additional work.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="state-transformers">State Transformers<a class="hash-link" href="#state-transformers" title="Direct link to heading">â€‹</a></h2><p>Those who live on the dark side of mutation sometimes have it easy; they can add state everywhere like it&#x27;s Christmas. Behold:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">var idCounter = 0</span><br></span><span class="token-line"><span class="token plain">def freshVar: String = {</span><br></span><span class="token-line"><span class="token plain">  idCounter += 1</span><br></span><span class="token-line"><span class="token plain">  s&quot;var${idCounter}&quot;</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain">val v1 = freshVar</span><br></span><span class="token-line"><span class="token plain">val v2 = freshVar</span><br></span><span class="token-line"><span class="token plain">val v3 = freshVar</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As functional programmers, we know better and have captured state mutation in the form of functions of type <code>S =&gt; (A, S)</code>. <code>Ref</code> provides such an encoding, with <code>S</code> being the type of the value, and <code>modify</code> embodying the state mutation function.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">Ref.make(0).flatMap { idCounter =&gt;</span><br></span><span class="token-line"><span class="token plain">  def freshVar: UIO[String] =</span><br></span><span class="token-line"><span class="token plain">    idCounter.modify(cpt =&gt; (s&quot;var${cpt + 1}&quot;, cpt + 1))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    v1 &lt;- freshVar</span><br></span><span class="token-line"><span class="token plain">    v2 &lt;- freshVar</span><br></span><span class="token-line"><span class="token plain">    v3 &lt;- freshVar</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="building-more-sophisticated-concurrency-primitives">Building more sophisticated concurrency primitives<a class="hash-link" href="#building-more-sophisticated-concurrency-primitives" title="Direct link to heading">â€‹</a></h2><p><code>Ref</code> is low-level enough that it can serve as the foundation for other concurrency data types.</p><p>For example, semaphores are a classic abstract data type for controlling access to shared resources. They are defined as a triplet <code>S = (v, P, V)</code> where <code>v</code> is the number of units of the resource that are currently available, and <code>P</code> and <code>V</code> are operations that decrement and increment <code>v</code>, respectively. <code>P</code> will only complete when <code>v</code> is non-negative and must wait if it isn&#x27;t.</p><p>With <code>Ref</code>, it&#x27;s easy to implement such a semaphore! The only difficulty is in <code>P</code>, where we must fail and retry when either <code>v</code> is negative, or its value has changed between the moment we read it and the moment we try to update it. A naive implementation could look like:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">sealed trait S {</span><br></span><span class="token-line"><span class="token plain">  def P: UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">  def V: UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object S {</span><br></span><span class="token-line"><span class="token plain">  def apply(v: Long): UIO[S] =</span><br></span><span class="token-line"><span class="token plain">    Ref.make(v).map { vref =&gt;</span><br></span><span class="token-line"><span class="token plain">      new S {</span><br></span><span class="token-line"><span class="token plain">        def V = vref.update(_ + 1).unit</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">        def P = (vref.get.flatMap { v =&gt;</span><br></span><span class="token-line"><span class="token plain">          if (v &lt; 0)</span><br></span><span class="token-line"><span class="token plain">            IO.fail(())</span><br></span><span class="token-line"><span class="token plain">          else</span><br></span><span class="token-line"><span class="token plain">            vref.modify(v0 =&gt; if (v0 == v) (true, v - 1) else (false, v)).flatMap {</span><br></span><span class="token-line"><span class="token plain">              case false =&gt; IO.fail(())</span><br></span><span class="token-line"><span class="token plain">              case true  =&gt; IO.unit</span><br></span><span class="token-line"><span class="token plain">            }</span><br></span><span class="token-line"><span class="token plain">        } &lt;&gt; P).unit</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Let&#x27;s rock these crocodile boots we found the other day at the market and test our semaphore at the night club, yee-haw:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio.Console._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val party = for {</span><br></span><span class="token-line"><span class="token plain">  dancefloor &lt;- S(10)</span><br></span><span class="token-line"><span class="token plain">  dancers &lt;- ZIO.foreachPar(1 to 100) { i =&gt;</span><br></span><span class="token-line"><span class="token plain">    dancefloor.P *&gt; Random.nextDouble.map(d =&gt; Duration.fromNanos((d * 1000000).round)).flatMap { d =&gt;</span><br></span><span class="token-line"><span class="token plain">      printLine(s&quot;${i} checking my boots&quot;) *&gt; ZIO.sleep(d) *&gt; printLine(s&quot;${i} dancing like it&#x27;s 99&quot;)</span><br></span><span class="token-line"><span class="token plain">    } *&gt; dancefloor.V</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>It goes without saying you should take a look at ZIO&#x27;s own <code>Semaphore</code>, it does all this and more without wasting all those CPU cycles while waiting.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zio/zio/edit/series/2.x/docs/datatypes/concurrency/ref.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/next/datatypes/concurrency/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Introduction</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/next/datatypes/concurrency/refsynchronized"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Ref.Synchronized</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#concurrent-stateful-application" class="table-of-contents__link toc-highlight">Concurrent Stateful Application</a></li><li><a href="#operations" class="table-of-contents__link toc-highlight">Operations</a><ul><li><a href="#make" class="table-of-contents__link toc-highlight">make</a></li><li><a href="#get" class="table-of-contents__link toc-highlight">get</a></li><li><a href="#set" class="table-of-contents__link toc-highlight">set</a></li><li><a href="#update" class="table-of-contents__link toc-highlight">update</a></li><li><a href="#modify" class="table-of-contents__link toc-highlight">modify</a></li></ul></li><li><a href="#atomicreference-in-java" class="table-of-contents__link toc-highlight">AtomicReference in Java</a></li><li><a href="#ref-vs-state-monad" class="table-of-contents__link toc-highlight">Ref vs. State Monad</a><ul><li><a href="#concurrency" class="table-of-contents__link toc-highlight">Concurrency</a></li><li><a href="#error-handling" class="table-of-contents__link toc-highlight">Error Handling</a></li></ul></li><li><a href="#state-transformers" class="table-of-contents__link toc-highlight">State Transformers</a></li><li><a href="#building-more-sophisticated-concurrency-primitives" class="table-of-contents__link toc-highlight">Building more sophisticated concurrency primitives</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items"><li class="footer__item">
                <img src="/img/navbar_brand.png" alt="zio">
            </li></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items"><li class="footer__item">
              <a href="https://github.com/zio/zio">
                <img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github">
              </a>
            </li></ul></div><div class="col footer__col"><div class="footer__title">Chat with us on Discord</div><ul class="footer__items"><li class="footer__item">
                <a href="https://discord.gg/2ccFBr4">
                  <img src="https://img.shields.io/discord/629491597070827530?logo=discord&style=social" alt="discord">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Follow us on Twitter</div><ul class="footer__items"><li class="footer__item">
                <a href="https://twitter.com/zioscala">
                  <img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&style=social" alt="twitter">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Additional resources</div><ul class="footer__items"><li class="footer__item"><a href="https://javadoc.io/doc/dev.zio/zio_2.12/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scaladoc of ZIO<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 ZIO Maintainers - Built with <a href="https://v2.docusaurus.io/">Docusaurus v2</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.183b2960.js"></script>
<script src="/assets/js/main.eb82bc51.js"></script>
</body>
</html>