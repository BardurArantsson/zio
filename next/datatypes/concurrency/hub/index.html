<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="search" type="application/opensearchdescription+xml" title="ZIO" href="/opensearch.xml">
<link rel="stylesheet" href="/css/prism/prism-material-dark.css"><title data-react-helmet="true">Hub | ZIO</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://zio.dev/next/datatypes/concurrency/hub"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Hub | ZIO"><meta data-react-helmet="true" name="description" content="A Hub is an asynchronous message hub. Publishers can publish messages to the hub and subscribers can subscribe to receive messagesfrom the hub."><meta data-react-helmet="true" property="og:description" content="A Hub is an asynchronous message hub. Publishers can publish messages to the hub and subscribers can subscribe to receive messagesfrom the hub."><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://zio.dev/next/datatypes/concurrency/hub"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/next/datatypes/concurrency/hub" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/next/datatypes/concurrency/hub" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.6feee118.css">
<link rel="preload" href="/assets/js/runtime~main.183b2960.js" as="script">
<link rel="preload" href="/assets/js/main.eb82bc51.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_W2Cr themedImage--dark_oUvU"></div></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/version-1.x/overview/">Overview</a><a class="navbar__item navbar__link" href="/version-1.x/datatypes/">Data Types</a><a class="navbar__item navbar__link" href="/version-1.x/usecases/">Use Cases</a><a class="navbar__item navbar__link" href="/version-1.x/howto/">How to</a><a class="navbar__item navbar__link" href="/version-1.x/resources/">Resources</a><a class="navbar__item navbar__link" href="/version-1.x/about/">About</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/next/overview/">ZIO 2.x (WIP)</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/next/datatypes/concurrency/hub">ZIO 2.x (WIP)</a></li><li><a class="dropdown__link" href="/version-1.x/datatypes/concurrency/hub">ZIO 1.x</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/">Overview</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/core/zio/">Core Data Types</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/contextual/">Contextual Types</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/next/datatypes/fiber/">Concurrency</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/next/datatypes/fiber/">ZIO Fibers</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/next/datatypes/concurrency/">Concurrency Primitives</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/next/datatypes/concurrency/ref">Mutable References</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/promise">Promise</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/queue">Queue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/next/datatypes/concurrency/hub">Hub</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/concurrency/semaphore">Semaphore</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/next/datatypes/stm/">STM</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/resource/">Resource Management</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/stream/">Streaming</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/metrics/">Metrics</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/test/">ZIO Test</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/misc/chunk">Miscellaneous</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for <!-- -->ZIO<!-- --> <b>ZIO 2.x (WIP)</b> version.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/version-1.x/datatypes/concurrency/hub">latest version</a></b> (<!-- -->ZIO 1.x<!-- -->).</div></div><div class="docItemContainer_vinB"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->ZIO 2.x (WIP)</span><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Hub</h1></header><p>A <code>Hub</code> is an asynchronous message hub. Publishers can publish messages to the hub and subscribers can subscribe to receive messagesfrom the hub.</p><p>Unlike a <code>Queue</code>, where each value offered to the queue can be taken by <em>one</em> taker, each value published to a hub can be received by <em>all</em> subscribers. Whereas a <code>Queue</code> represents the optimal solution to the problem of how to <em>distribute</em> values, a <code>Hub</code> represents the optimal solution to the problem of how to <em>broadcast</em> them.</p><p>The fundamental operators on a <code>Hub</code> are <code>publish</code> and <code>subscribe</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Hub[A] {</span><br></span><span class="token-line"><span class="token plain">  def publish(a: A): UIO[Boolean]</span><br></span><span class="token-line"><span class="token plain">  def subscribe: ZIO[Scope, Nothing, Dequeue[A]]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The <code>publish</code> operator returns a <code>ZIO</code> effect that publishes a message of type <code>A</code> to the hub and succeeds with a value describing whether the message was successfully published to the hub.</p><p>The <code>subscribe</code> operator returns a scoped <code>ZIO</code> effect that subscribes to the hub and unsubscribes from the hub when the scope is closed. Within the scope we have access to a <code>Dequeue</code>, which is a <code>Queue</code> that can only be dequeued from, that allows us to take messages published to the hub.</p><p>For example, we can use a hub to broadcast a message to multiple subscribers like this:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">Hub.bounded[String](2).flatMap { hub =&gt;</span><br></span><span class="token-line"><span class="token plain">  ZIO.scoped {</span><br></span><span class="token-line"><span class="token plain">    hub.subscribe.zip(hub.subscribe).flatMap { case (left, right) =&gt;</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        _ &lt;- hub.publish(&quot;Hello from a hub!&quot;)</span><br></span><span class="token-line"><span class="token plain">        _ &lt;- left.take.flatMap(Console.printLine(_))</span><br></span><span class="token-line"><span class="token plain">        _ &lt;- right.take.flatMap(Console.printLine(_))</span><br></span><span class="token-line"><span class="token plain">      } yield ()</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>A subscriber will only receive messages that are published to the hub while it is subscribed. So if we want to make sure that a particular message is received by a subscriber we must take care that the subscription has completed before publishing the message to the hub.</p><p>We can do this by publishing a message to the hub within the scope of the subscription as in the example above or by using other coordination mechanisms such as completing a <code>Promise</code>  when scope has been opened.</p><p>Of course, in many cases such as subscribing to receive real time data we may not care about this because we are happy to just pick up with the most recent messages after we have subscribed. But for testing and simple applications this can be an important point to keep in mind.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="constructing-hubs">Constructing Hubs<a class="hash-link" href="#constructing-hubs" title="Direct link to heading">â€‹</a></h2><p>The most common way to create a hub is with the <code>bounded</code> constructor, which returns an effect that creates a new hub with the specified requested capacity.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def bounded[A](requestedCapacity: Int): UIO[Hub[A]] =</span><br></span><span class="token-line"><span class="token plain">  ???</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>For maximum efficiency you should create hubs with capacities that are powers of two.</p><p>Just like a bounded queue, a bounded hub applies back pressure to publishers when it is at capacity, so publishers will semantically block on calls to <code>publish</code> if the hub is full.</p><p>The advantage of the back pressure strategy is that it guarantees that all subscribers will receive all messages published to the hub while they are subscribed. However, it does create the risk that a slow subscriber will slow down the rate at which messages are published and received by other subscribers.</p><p>If you do not want this you can create a hub with the <code>dropping</code> constructor.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def dropping[A](requestedCapacity: Int): UIO[Hub[A]] =</span><br></span><span class="token-line"><span class="token plain">  ???</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>A dropping hub will simply drop values published to it if the hub is at capacity, returning <code>false</code> on calls to <code>publish</code> if the hub is full to signal that the value was not successfully published.</p><p>The advantage of the dropping strategy is that publishers can continue to publish new values so when there is space in the hub the newest values can be published to the hub. However, subscribers are no longer guaranteed to receive all values published to the hub and a slow subscriber can still prevent messages from being published to the hub and received by other subscribers.</p><p>You can also create a hub with the <code>sliding</code> constructor.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def sliding[A](requestedCapacity: Int): UIO[Hub[A]] =</span><br></span><span class="token-line"><span class="token plain">  ???</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>A sliding hub will drop the oldest value if a new value is published to it and the hub is at capacity, so publishing will always succeed immediately.</p><p>The advantage of the sliding strategy is that a slow subscriber cannot slow down that rate at which messages are published to the hub or received by other subscribers. However, it creates the risk that slow subscribers may not receive all messages published to the hub.</p><p>Finally, you can create a hub with the <code>unbounded</code> constructor.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def unbounded[A]: UIO[Hub[A]] =</span><br></span><span class="token-line"><span class="token plain">  ???</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>An unbounded hub is never at capacity so publishing to an unbounded hub always immediately succeeds.</p><p>The advantage of an unbounded hub is that it combines the guarantees that all subscribers will receive all messages published to the hub and that a slow subscriber will not slow down the rate at which messages are published and received by other subscribers. However, it does this at the cost of potentially growing without bound if messages are published to the hub more quickly than they are taken by the slowest subscriber.</p><p>In general you should prefer bounded, dropping, or sliding hubs for this reason. However, unbounded hubs can be useful in certain situations where you do not know exactly how many values will be published to the hub but are confident that it will not exceed a reasonable size or want to handle that concern at a higher level of your application.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="operators-on-hubs">Operators On Hubs<a class="hash-link" href="#operators-on-hubs" title="Direct link to heading">â€‹</a></h2><p>In addition to <code>publish</code> and <code>subscribe</code>, many of the same operators that are available on queues are available on hubs.</p><p>We can publish multiple values to the hub using the <code>publishAll</code> operator.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait Hub[A] {</span><br></span><span class="token-line"><span class="token plain">  def publishAll(as: Iterable[A]): UIO[Boolean]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We can check the capacity of the hub as well as the number of messages currently in the hub using the <code>size</code> and <code>capacity</code> operators.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait Hub[A] {</span><br></span><span class="token-line"><span class="token plain">  def capacity: Int</span><br></span><span class="token-line"><span class="token plain">  def size: UIO[Int]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Note that <code>capacity</code> returns an <code>Int</code> because the capacity is set at hub creation and never changes. In contrast, <code>size</code> returns a <code>ZIO</code> effect that determines the current size of the hub since the number of messages in the hub can change over time.</p><p>We can also shut down the hub, check whether it has been shut down, or await its shut down. Shutting down a hub will shut down all the queues associated with subscriptions to the hub, properly propagating the shut down signal.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait Hub[A] {</span><br></span><span class="token-line"><span class="token plain">  def awaitShutdown: UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">  def isShutdown: UIO[Boolean]</span><br></span><span class="token-line"><span class="token plain">  def shutdown: UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As you can see, the operators on <code>Hub</code> are identical to the ones on <code>Queue</code> with the exception of <code>publish</code> and <code>subscribe</code> replacing <code>offer</code> and <code>take</code>. So if you know how to use a <code>Queue</code> you already know how to use a <code>Hub</code>.</p><p>In fact, a <code>Hub</code> can be viewed as a <code>Queue</code> that can only be written to.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait Hub[A] extends Enqueue[A]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here the <code>Enqueue</code> type represents a queue that can only be enqueued. Enqueing to the queue publishes a value to the hub, shutting down the queue shuts down the hub, and so on.</p><p>This can be extremely useful because it allows us to use a <code>Hub</code> anywhere we are currently using a <code>Queue</code> that we only write to.</p><p>For example, say we are using the <code>into</code> operator on <code>ZStream</code> to send all elements of a stream of financial transactions to a <code>Queue</code> for processing by a downstream consumer.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio.stream._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait ZStream[-R, +E, +O] {</span><br></span><span class="token-line"><span class="token plain">  def into(</span><br></span><span class="token-line"><span class="token plain">    queue: Enqueue[Take[E, O]]</span><br></span><span class="token-line"><span class="token plain">  ): ZIO[R, E, Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We would now like to have multiple downstream consumers process each of these transactions, for example to persist them and log them in addition to applying our business logic to them. With <code>Hub</code> this is easy because we can just use the <code>toQueue</code> operator to view any <code>Hub</code> as a <code>Queue</code> that can only be written to.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">type Transaction = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val transactionStream: ZStream[Any, Nothing, Transaction] =</span><br></span><span class="token-line"><span class="token plain">  ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val hub: Hub[Take[Nothing, Transaction]] =</span><br></span><span class="token-line"><span class="token plain">  ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">transactionStream.into(hub)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>All of the elements from the transaction stream will now be published to the hub. We can now have multiple downstream consumers process elements from the financial transactions stream with the guarantee that all downstream consumers will see all transactions in the stream, changing the topology of our data flow from one-to-one to one-to-many with a single line change.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="hubs-and-streams">Hubs And Streams<a class="hash-link" href="#hubs-and-streams" title="Direct link to heading">â€‹</a></h2><p>Hubs play extremely well with streams.</p><p>We can create a <code>ZStream</code> from a subscription to a hub using the <code>fromHub</code> operator.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio.stream._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object ZStream {</span><br></span><span class="token-line"><span class="token plain">  def fromHub[O](hub: Hub[O]): ZStream[Any, Nothing, O] =</span><br></span><span class="token-line"><span class="token plain">    ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This will return a stream that subscribes to receive values from a hub and then emits every value published to the hub while the subscription is active. When the stream ends the subscriber will automatically be unsubscribed from the hub.</p><p>There is also a <code>fromHubScoped</code> operator that returns the stream in the context of a scoped effect.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object ZStream {</span><br></span><span class="token-line"><span class="token plain">  def fromHubScoped[O](</span><br></span><span class="token-line"><span class="token plain">    hub: Hub[O]</span><br></span><span class="token-line"><span class="token plain">  ): ZIO[Scope, Nothing, ZStream[Any, Nothing, O]] =</span><br></span><span class="token-line"><span class="token plain">    ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The scoped effect here describes subscribing to receive messages from the hub while the stream describes taking messages from the hub. This can be useful when we need to ensure that a consumer has subscribed before a producer begins publishing values.</p><p>Here is an example of using it:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">for {</span><br></span><span class="token-line"><span class="token plain">  promise &lt;- Promise.make[Nothing, Unit]</span><br></span><span class="token-line"><span class="token plain">  hub     &lt;- Hub.bounded[String](2)</span><br></span><span class="token-line"><span class="token plain">  scoped  = ZStream.fromHubScoped(hub).tap(_ =&gt; promise.succeed(()))</span><br></span><span class="token-line"><span class="token plain">  stream   = ZStream.unwrapScoped(scoped)</span><br></span><span class="token-line"><span class="token plain">  fiber   &lt;- stream.take(2).runCollect.fork</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- promise.await</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- hub.publish(&quot;Hello&quot;)</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- hub.publish(&quot;World&quot;)</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- fiber.join</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Notice that in this case we used a <code>Promise</code> to ensure that the subscription had completed before publishing to the hub. The scoped <code>ZIO</code> in the return type of <code>fromHubScoped</code> made it easy for us to signal when the subscription had occurred by using <code>tap</code> and completing the <code>Promise</code>.</p><p>Of course in many real applications we don&#x27;t need this kind of sequencing and just want to subscribe to receive new messages. In this case we can use the <code>fromHub</code> operator to return a <code>ZStream</code> that will automatically handle subscribing and unsubscribing for us.</p><p>There is also a <code>fromHubWithShutdown</code> variant that shuts down the hub itself when the stream ends. This is useful when the stream represents your main application logic and you want to shut down other subscriptions to the hub when the stream ends.</p><p>Each of these constructors also has <code>Chunk</code> variants, <code>fromChunkHub</code> and <code>fromChunkHubWithShutdown</code>, that allow you to preserve the chunked structure of data when working with hubs and streams.</p><p>In addition to being able to create streams from subscriptions to hubs, there are a variety of ways to send values emitted by streams to hubs to build more complex data flow graphs.</p><p>The simplest of these is the <code>toHub</code> operator, which constructs a new hub and publishes each element emitted by the stream to that hub.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait ZStream[-R, +E, +O] {</span><br></span><span class="token-line"><span class="token plain">  def toHub[E1 &gt;: E, O1 &gt;: O](</span><br></span><span class="token-line"><span class="token plain">    capacity: Int</span><br></span><span class="token-line"><span class="token plain">  ): ZIO[R with Scope, Nothing, Hub[Take[E1, O1]]]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The hub will be constructed with the <code>bounded</code> constructor using the specified capacity.</p><p>If you want to send values emitted by a stream to an existing hub or a hub created using one of the other hub constructors you can use the <code>intoHub</code> operator.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait ZStream[-R, +E, +O] {</span><br></span><span class="token-line"><span class="token plain">  def intoHub[E1 &gt;: E, O1 &gt;: O](</span><br></span><span class="token-line"><span class="token plain">    hub: Hub[Take[E1, O1]]</span><br></span><span class="token-line"><span class="token plain">  ): ZIO[R, E1, Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>There is an <code>intoHubScoped</code> variant of this if you want to send values to the hub in the context of a <code>Scope</code>.</p><p>Here is the example above adapted to publish values from a stream to the hub:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">for {</span><br></span><span class="token-line"><span class="token plain">  promise &lt;- Promise.make[Nothing, Unit]</span><br></span><span class="token-line"><span class="token plain">  hub     &lt;- Hub.bounded[Take[Nothing, String]](2)</span><br></span><span class="token-line"><span class="token plain">  scoped  = ZStream.fromHubScoped(hub).tap(_ =&gt; promise.succeed(()))</span><br></span><span class="token-line"><span class="token plain">  stream   = ZStream.unwrapScoped(scoped).flattenTake</span><br></span><span class="token-line"><span class="token plain">  fiber   &lt;- stream.take(2).runCollect.fork</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- promise.await</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- ZStream(&quot;Hello&quot;, &quot;World&quot;).runIntoHub(hub)</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- fiber.join</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Notice that we created a <code>Hub</code> of <code>Take</code> values this time. <code>Take</code> is an algebraic data type that represents the different potential results of pulling from a stream, including the stream emitting a chunk of values, failing with an error, or being done.</p><p>Here we automatically unwrapped the <code>Take</code> values using the <code>flattenTake</code> operator on <code>ZStream</code>. In other cases where the subscriber was not a <code>ZStream</code> the <code>Take</code> value would allow the subscriber to observe whether the stream had emitted a value, failed with an error, or ended, and handle it appropriately.</p><p>You can also create a sink that sends values to a hub.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object ZSink {</span><br></span><span class="token-line"><span class="token plain">  def fromHub[I](</span><br></span><span class="token-line"><span class="token plain">    hub: Hub[I]</span><br></span><span class="token-line"><span class="token plain">  ): ZSink[Any, Nothing, I, Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The sink will publish each value sent to the sink to the specified hub. Again there is a <code>fromHubWithShutdown</code> variant that will shut down the hub when the stream ends.</p><p>Finally, <code>Hub</code> is used internally to provide a highly efficient implementation of the <code>broadcast</code> family of operators, including <code>broadcast</code> and <code>broadcastDynamic</code>.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait ZStream[-R, +E, +O] {</span><br></span><span class="token-line"><span class="token plain">  def broadcast(</span><br></span><span class="token-line"><span class="token plain">    n: Int,</span><br></span><span class="token-line"><span class="token plain">    maximumLag: Int</span><br></span><span class="token-line"><span class="token plain">  ): ZIO[R with Scope, Nothing, List[ZStream[Any, E, O]]]</span><br></span><span class="token-line"><span class="token plain">  def broadcastDynamic(</span><br></span><span class="token-line"><span class="token plain">    maximumLag: Int</span><br></span><span class="token-line"><span class="token plain">  ): ZIO[R with Scope, Nothing, ZIO[Scope, Nothing, ZStream[Any, E, O]]]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The <code>broadcast</code> operator generates the specified number of new streams and broadcasts each value from the original stream to each of the new streams. The <code>broadcastDynamic</code> operator returns a new <code>ZIO</code> value that you can use to dynamically subscribe and unsubscribe to receive values broadcast from the original stream.</p><p>You don&#x27;t have to do anything with <code>Hub</code> to take advantage of these operators other than enjoy their optimized implementation in terms of <code>Hub</code>.</p><p>With <code>broadcast</code> and other <code>ZStream</code> operators that model distributing values to different streams and combining values from different streams it is straightforward to build complex data flow graphs, all while being as performant as possible.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zio/zio/edit/series/2.x/docs/datatypes/concurrency/hub.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/next/datatypes/concurrency/queue"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Queue</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/next/datatypes/concurrency/semaphore"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Semaphore</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#constructing-hubs" class="table-of-contents__link toc-highlight">Constructing Hubs</a></li><li><a href="#operators-on-hubs" class="table-of-contents__link toc-highlight">Operators On Hubs</a></li><li><a href="#hubs-and-streams" class="table-of-contents__link toc-highlight">Hubs And Streams</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items"><li class="footer__item">
                <img src="/img/navbar_brand.png" alt="zio">
            </li></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items"><li class="footer__item">
              <a href="https://github.com/zio/zio">
                <img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github">
              </a>
            </li></ul></div><div class="col footer__col"><div class="footer__title">Chat with us on Discord</div><ul class="footer__items"><li class="footer__item">
                <a href="https://discord.gg/2ccFBr4">
                  <img src="https://img.shields.io/discord/629491597070827530?logo=discord&style=social" alt="discord">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Follow us on Twitter</div><ul class="footer__items"><li class="footer__item">
                <a href="https://twitter.com/zioscala">
                  <img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&style=social" alt="twitter">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Additional resources</div><ul class="footer__items"><li class="footer__item"><a href="https://javadoc.io/doc/dev.zio/zio_2.12/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scaladoc of ZIO<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 ZIO Maintainers - Built with <a href="https://v2.docusaurus.io/">Docusaurus v2</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.183b2960.js"></script>
<script src="/assets/js/main.eb82bc51.js"></script>
</body>
</html>