<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="search" type="application/opensearchdescription+xml" title="ZIO" href="/opensearch.xml">
<link rel="stylesheet" href="/css/prism/prism-material-dark.css"><title data-react-helmet="true">Introduction to the ZIO&#x27;s Contextual Data Types | ZIO</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://zio.dev/next/datatypes/contextual/"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Introduction to the ZIO&#x27;s Contextual Data Types | ZIO"><meta data-react-helmet="true" name="description" content="ZIO provides a contextual abstraction that encodes the environment of the running effect. This means, every effect can work within a specific context, called an environment."><meta data-react-helmet="true" property="og:description" content="ZIO provides a contextual abstraction that encodes the environment of the running effect. This means, every effect can work within a specific context, called an environment."><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://zio.dev/next/datatypes/contextual/"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/next/datatypes/contextual/" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/next/datatypes/contextual/" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.eb47feb5.css">
<link rel="preload" href="/assets/js/runtime~main.e0bb0b29.js" as="script">
<link rel="preload" href="/assets/js/main.3950424f.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_W2Cr themedImage--dark_oUvU"></div></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/version-1.x/overview/">Overview</a><a class="navbar__item navbar__link" href="/version-1.x/datatypes/">Data Types</a><a class="navbar__item navbar__link" href="/version-1.x/usecases/">Use Cases</a><a class="navbar__item navbar__link" href="/version-1.x/howto/">How to</a><a class="navbar__item navbar__link" href="/version-1.x/resources/">Resources</a><a class="navbar__item navbar__link" href="/version-1.x/about/">About</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/next/overview/">ZIO 2.x (WIP)</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/next/datatypes/contextual/">ZIO 2.x (WIP)</a></li><li><a class="dropdown__link" href="/version-1.x/datatypes/contextual/">ZIO 1.x</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/">Overview</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/core/zio/">Core Data Types</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/next/datatypes/contextual/">Contextual Types</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/next/datatypes/contextual/">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/contextual/zenvironment">ZEnvironment</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/next/datatypes/contextual/zlayer">ZIO Layers</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/next/datatypes/contextual/services/">Built-in Services</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/fiber/">Concurrency</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/resource/">Resource Management</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/stream/">Streaming</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/metrics/">Metrics</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/test/">ZIO Test</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/misc/chunk">Miscellaneous</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for <!-- -->ZIO<!-- --> <b>ZIO 2.x (WIP)</b> version.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/version-1.x/datatypes/contextual/">latest version</a></b> (<!-- -->ZIO 1.x<!-- -->).</div></div><div class="docItemContainer_vinB"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->ZIO 2.x (WIP)</span><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Introduction to the ZIO&#x27;s Contextual Data Types</h1></header><p>ZIO provides a contextual abstraction that encodes the environment of the running effect. This means, every effect can work within a specific context, called an environment.</p><p>So when we have a <code>ZIO[R, E, A]</code> effect, we can say &quot;given <code>R</code> as the environment of the effect, the effect may fail with an error type of <code>E</code>, or may succeed with a value of type <code>A</code>&quot;.</p><p>For example, when we have an effect of type <code>ZIO[DatabaseConnection, IOException, String]</code>, we can say that our effect works within the context of <code>DatabaseConnection</code>. In other words, we can say that our effect requires the <code>DatabaseConnection</code> service as a context to run.</p><p>We will see how layers can be used to eliminate the environment of an effect:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">import java.io.IOException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait DatabaseConnection</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// An effect which requires DatabaseConnection to run</span><br></span><span class="token-line"><span class="token plain">val effect: ZIO[DatabaseConnection, IOException, String] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// A layer that produces DatabaseConnection service</span><br></span><span class="token-line"><span class="token plain">val dbConnection: ZLayer[Any, IOException, DatabaseConnection] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// After applying dbConnection to our environmental effect the reurned</span><br></span><span class="token-line"><span class="token plain">// effect has no dependency on the DatabaseConnection</span><br></span><span class="token-line"><span class="token plain">val eliminated: ZIO[Any, IOException, String] = </span><br></span><span class="token-line"><span class="token plain">  dbConnection { // Provides DatabaseConnection context</span><br></span><span class="token-line"><span class="token plain">    effect       // An effect running within `DatabaseConnection` context</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>ZIO provides this facility through the following concepts and data types:</p><ol><li><a href="#1-zio-environment">ZIO Environment</a> — The <code>R</code> type parameter of <code>ZIO[R, E, A]</code> data type.</li><li><a href="/next/datatypes/contextual/zenvironment">ZEnvironment</a> — Built-in type-level map for maintaining the environment of a <code>ZIO</code> data type. </li><li><a href="/next/datatypes/contextual/zlayer">ZLayer</a> — Describes how to build one or more services in our application.</li></ol><p>Next, we will discuss <em>ZIO Environment</em> and <em>ZLayer</em> and finally how to write ZIO services using the <em>Service Pattern</em>.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="1-zio-environment">1. ZIO Environment<a class="hash-link" href="#1-zio-environment" title="Direct link to heading">​</a></h2><p>The <code>ZIO[-R, +E, +A]</code> data type describes an effect that requires an input of type <code>R</code>, as an environment, may fail with an error of type <code>E</code>, or succeed with a value of type <code>A</code>.</p><p>The input type is also known as <em>environment type</em>. This type-parameter indicates that to run an effect we need one or some services as an environment of that effect. In other word, <code>R</code> represents the <em>requirement</em> for the effect to run, meaning we need to fulfill the requirement in order to make the effect <em>runnable</em>.</p><p>So we can think of <code>ZIO[R, E, A]</code> as a mental model of a function from a value of type <code>R</code> to the <code>Either[E, A]</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">type ZIO[R, E, A] = R =&gt; Either[E, A]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>R</code> represents dependencies; whatever services, config, or wiring a part of a ZIO program depends upon to work. We will explore what we can do with <code>R</code>, as it plays a crucial role in <code>ZIO</code>.</p><p>We don&#x27;t need to provide live layers for built-in services (Layers will be discussed later on this page). ZIO has a <code>ZEnv</code> type alias for the composition of all ZIO built-in services (<code>Clock</code>, <code>Console</code>, <code>System</code>, <code>Random</code>, and <code>Blocking</code>). So we can run the above <code>effect</code> as follows:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  def run = effect</span><br></span><span class="token-line"><span class="token plain">  </span><br></span><span class="token-line"><span class="token plain">  val effect: ZIO[Any, Nothing, Unit] = for {</span><br></span><span class="token-line"><span class="token plain">    r &lt;- Random.nextInt</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- Console.printLine(s&quot;random number: $r&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="motivation">Motivation<a class="hash-link" href="#motivation" title="Direct link to heading">​</a></h3><p>One might ask &quot;What is the motivation behind encoding the dependency in the type parameter of <code>ZIO</code> data type&quot;? What is the benefit of doing so?</p><p>Let&#x27;s see how writing an application which requires reading from or writing to the console. As part of making the application <em>modular</em> and <em>testable</em> we define a separate service called <code>Console</code> which is responsible for reading from and writing to the console. We do that simply by writing an interface:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Console {</span><br></span><span class="token-line"><span class="token plain">  def print(line: Any): Task[Unit]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def printLine(line: Any): Task[Unit]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def readLine: Task[String]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Now we can write our application that accepts the <code>Console</code> interface as a parameter:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">def myApp(c: Console): Task[Unit] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    _    &lt;- c.print(&quot;Please enter your name: &quot;)</span><br></span><span class="token-line"><span class="token plain">    name &lt;- c.readLine</span><br></span><span class="token-line"><span class="token plain">    _    &lt;- c.printLine(s&quot;Hello, $name!&quot;)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Similar to the object-oriented paradigm we code to interface not implementation. In order to run the application, we need to implement a production version of the <code>Console</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object ConsoleLive extends Console {</span><br></span><span class="token-line"><span class="token plain">  override def print(line: Any): Task[Unit] =</span><br></span><span class="token-line"><span class="token plain">    Task.attemptBlocking(scala.Predef.print(line))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def printLine(line: Any): Task[Unit] =</span><br></span><span class="token-line"><span class="token plain">    Task.attemptBlocking(scala.Predef.println(line))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def readLine: Task[String] =</span><br></span><span class="token-line"><span class="token plain">    Task.attemptBlocking(scala.io.StdIn.readLine())</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Finally, we can provide the <code>ConsoleLive</code> to our application and run the whole:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  def myApp(c: Console): Task[Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- c.print(&quot;Please enter your name: &quot;)</span><br></span><span class="token-line"><span class="token plain">      name &lt;- c.readLine</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- c.printLine(s&quot;Hello, $name!&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp(ConsoleLive)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In the above example, we discard the fact that we could use the ZIO environment and utilize the <code>R</code> parameter of the <code>ZIO</code> data type. So instead we tried to write the application with the <code>Task</code> data type, which ignores the ZIO environment. To create our application testable, we gathered all console functionalities into the same interface called <code>Console</code>, and implemented that in another object called <code>ConsoleLive</code>. Finally, at the end of the day, we provide the implementation of the <code>Console</code> service, i.e. <code>ConsoleLive</code>, to our application.</p><p><strong>While this technique works for small programs, it doesn&#x27;t scale.</strong> Assume we have multiple services, and we use them in our application logic like below:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def foo(</span><br></span><span class="token-line"><span class="token plain">   s1: Service1,</span><br></span><span class="token-line"><span class="token plain">   s2: Service2,</span><br></span><span class="token-line"><span class="token plain">   s3: Service3</span><br></span><span class="token-line"><span class="token plain">)(arg1: String, arg2: String, arg3: Int): Task[Int] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">def bar(</span><br></span><span class="token-line"><span class="token plain">  s1: Service1,</span><br></span><span class="token-line"><span class="token plain">  s12: Service12,</span><br></span><span class="token-line"><span class="token plain">  s18: Service18, </span><br></span><span class="token-line"><span class="token plain">  sn: ServiceN</span><br></span><span class="token-line"><span class="token plain">)(arg1: Int, arg2: String, arg3: Double, arg4: Int): Task[Unit]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">def myApp(s1: Service1, s2: Service2, ..., sn: ServiceN): Task[Unit] = </span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    a &lt;- foo(s1, s2, s3)(&quot;arg1&quot;, &quot;arg2&quot;, 4) </span><br></span><span class="token-line"><span class="token plain">    _ &lt;- bar(s1, s12, s18, sn)(7, &quot;arg2&quot;, 1.2, a)</span><br></span><span class="token-line"><span class="token plain">      ...</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Writing real applications using this technique is tedious and cumbersome because all dependencies have to be passed across all methods. We can simplify the process of writing our application by using the ZIO environment and <a href="#service-pattern">Service Pattern</a>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def foo(arg1: String, arg2: String, arg3: Int): ZIO[Service1 &amp; Service2 &amp; Service3, Throwable, Int] = </span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    s1 &lt;- ZIO.service[Service1]</span><br></span><span class="token-line"><span class="token plain">    s2 &lt;- ZIO.service[Service2] </span><br></span><span class="token-line"><span class="token plain">      ...</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">def bar(arg1: Int, arg2: String, arg3: Double, arg4: Int): ZIO[Service1 &amp; Service12 &amp; Service18 &amp; ServiceN, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    s1  &lt;- ZIO.service[Service1] </span><br></span><span class="token-line"><span class="token plain">    s12 &lt;- ZIO.service[Service12]</span><br></span><span class="token-line"><span class="token plain">      ...</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="advantage-of-using-zio-environment">Advantage of Using ZIO Environment<a class="hash-link" href="#advantage-of-using-zio-environment" title="Direct link to heading">​</a></h3><p>ZIO environment facility enables us to:</p><ol><li><p><strong>Code to Interface</strong> — Like object-oriented paradigm, in ZIO we are encouraged to code to interface and defer the implementation. It is the best practice, but ZIO does not enforce us to do that.</p></li><li><p><strong>Write a Testable Code</strong> — By coding to an interface, whenever we want to test our effects, we can easily mock any external services, by providing a <em>test</em> version of those instead of the <em>live</em> version.</p></li><li><p><strong>Compose Services with Strong Type Inference Facility</strong> — We can compose multiple effects that require various services, so the final effect requires the intersection of all those services:</p></li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait ServiceA</span><br></span><span class="token-line"><span class="token plain">trait ServiceB</span><br></span><span class="token-line"><span class="token plain">trait ServiceC</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// Requires ServiceA and produces a value of type Int</span><br></span><span class="token-line"><span class="token plain">def foo: ZIO[ServiceA, Nothing, Int] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// Requires ServiceB and ServiceC and produces a value of type String</span><br></span><span class="token-line"><span class="token plain">def bar: ZIO[ServiceB &amp; ServiceC, Throwable, String] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// Requires ServicB and produces a value of type Double</span><br></span><span class="token-line"><span class="token plain">def baz(a: Int, b: String): ZIO[ServiceB, Nothing, Double] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// Requires ServiceB and ServiceB and ServiceC and produces a value of type Double</span><br></span><span class="token-line"><span class="token plain">val myApp: ZIO[ServiceA &amp; ServiceB &amp; ServiceC, Throwable, Double] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    a &lt;- foo</span><br></span><span class="token-line"><span class="token plain">    b &lt;- bar</span><br></span><span class="token-line"><span class="token plain">    c &lt;- baz(a, b)</span><br></span><span class="token-line"><span class="token plain">  } yield c</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Another important note about the ZIO environment is that the type inference works well on effect composition. After we composed all the application logic together, the compiler and also IDE can infer the proper type for the environment of the final effect.</p><p>In the example above, the compiler can infer the environment type of the <code>myApp</code> effect which is <code>ServiceA &amp; ServiceB &amp; ServiceC</code>.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="accessing-zio-environment">Accessing ZIO Environment<a class="hash-link" href="#accessing-zio-environment" title="Direct link to heading">​</a></h3><p>We have two types of accessors for the ZIO environment:</p><ol><li><strong>Service Accessor (<code>ZIO.service</code>)</strong> is used to access a specific service from the environment.</li><li><strong>Service Member Accessors (<code>ZIO.serviceWith</code> and <code>ZIO.serviceWithZIO</code>)</strong> are used to access capabilities of a specific service from the environment.</li></ol><blockquote><p><strong>Note</strong>:</p><p>To access the entire ZIO environment we can use <code>ZIO.environment*</code>, but we do not use these methods regularly to access ZIO services. Instead, we use service accessors and service member accessors.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_mojV" id="service-accessor">Service Accessor<a class="hash-link" href="#service-accessor" title="Direct link to heading">​</a></h4><p>To access a service from the ZIO environment, we can use the <code>ZIO.service</code> constructor. For example, in the following program we are going to access the <code>AppConfig</code> from the environment:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class AppConfig(host: String, port: Int)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val myApp: ZIO[AppConfig, Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    config &lt;- ZIO.service[AppConfig]</span><br></span><span class="token-line"><span class="token plain">    _      &lt;- ZIO.logInfo(s&quot;Application started with config: $config&quot;)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To run the <code>myApp</code> effect, we should provide the <code>AppConfig</code> layer (we will talk about <code>ZLayer</code> on the next section):</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(ZLayer.succeed(AppConfig(&quot;localhost&quot;, 8080)))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To access multiple services from the ZIO environment, we can do the same:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Foo</span><br></span><span class="token-line"><span class="token plain">trait Bar</span><br></span><span class="token-line"><span class="token plain">trait Baz</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">for {</span><br></span><span class="token-line"><span class="token plain">  foo &lt;- ZIO.service[Foo]  </span><br></span><span class="token-line"><span class="token plain">  bar &lt;- ZIO.service[Bar]</span><br></span><span class="token-line"><span class="token plain">  bax &lt;- ZIO.service[Baz]</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>When creating ZIO layers that have multiple dependencies, this can be helpful. We will discuss this pattern in the <a href="#service-pattern">Service Pattern</a> section.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="service-member-accessors">Service Member Accessors<a class="hash-link" href="#service-member-accessors" title="Direct link to heading">​</a></h4><p>Sometimes instead of accessing a service, we need to access the capabilities (members) of a service. Based on the return type of each capability, we can use one of these accessors:</p><ul><li><strong>ZIO.serviceWith</strong></li><li><strong>ZIO.serviceWithZIO</strong></li></ul><p>In <a href="#service-pattern">Service Pattern</a>, we use these accessors to write &quot;accessor methods&quot; for ZIO services.</p><p>Let&#x27;s look at each one in more detail:</p><ol><li><strong>ZIO.serviceWith</strong> — When we are accessing service members whose return type is an ordinary value, we should use the <code>ZIO.serviceWith</code>.</li></ol><p>In the following example, we need to use the <code>ZIO.serviceWith</code> to write accessor methods for all of the <code>AppConfig</code> members:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class AppConfig(host: String, port: Int, poolSize: Int)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object AppConfig {</span><br></span><span class="token-line"><span class="token plain">  // Accessor Methods</span><br></span><span class="token-line"><span class="token plain">  def host: ZIO[AppConfig, Nothing, String]  = ZIO.serviceWith(_.host) </span><br></span><span class="token-line"><span class="token plain">  def port: ZIO[AppConfig, Nothing, Int]     = ZIO.serviceWith(_.port)</span><br></span><span class="token-line"><span class="token plain">  def poolSize: ZIO[AppConfig, Nothing, Int] = ZIO.serviceWith(_.poolSize)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val myApp: ZIO[AppConfig, Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    host     &lt;- AppConfig.host</span><br></span><span class="token-line"><span class="token plain">    port     &lt;- AppConfig.port</span><br></span><span class="token-line"><span class="token plain">    _        &lt;- ZIO.logInfo(s&quot;The service will be service at $host:$port&quot;)</span><br></span><span class="token-line"><span class="token plain">    poolSize &lt;- AppConfig.poolSize</span><br></span><span class="token-line"><span class="token plain">    _        &lt;- ZIO.logInfo(s&quot;Application started with $poolSize pool size&quot;)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="2"><li><strong>ZIO.serviceWithZIO</strong> — When we are accessing service members whose return type is a ZIO effect, we should use the <code>ZIO.serviceWithZIO</code>.</li></ol><p>For example, in order to write the accessor method for the <code>log</code> member of the <code>Logging</code> service, we need to use the <code>ZIO.serviceWithZIO</code> function:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(line: String): Task[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Logging {</span><br></span><span class="token-line"><span class="token plain">  // Accessor Methods:</span><br></span><span class="token-line"><span class="token plain">  def log(line: String): ZIO[Logging, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.log(line))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val myApp: ZIO[Logging &amp; Console, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    _    &lt;- Logging.log(&quot;Application Started!&quot;)</span><br></span><span class="token-line"><span class="token plain">    _    &lt;- Console.print(&quot;Please enter your name: &quot;)</span><br></span><span class="token-line"><span class="token plain">    name &lt;- Console.readLine</span><br></span><span class="token-line"><span class="token plain">    _    &lt;- Console.printLine(s&quot;Hello, $name!&quot;)</span><br></span><span class="token-line"><span class="token plain">    _    &lt;- Logging.log(&quot;Application exited!&quot;)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="2-zenvironment">2. ZEnvironment<a class="hash-link" href="#2-zenvironment" title="Direct link to heading">​</a></h2><p><code>ZEnvironment</code> is a built-in type-level map for maintaining the environment of a <code>ZIO</code> data type. We don&#x27;t typically use this data type directly. It&#x27;s okay to skip learning it at the moment. We have a <a href="/next/datatypes/contextual/zenvironment">separate article</a> about this data type.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="3-zlayer">3. ZLayer<a class="hash-link" href="#3-zlayer" title="Direct link to heading">​</a></h2><p><code>ZLayer[-RIn, +E, +ROut]</code> is a recipe to build an environment of type <code>ROut</code>, starting from a value <code>RIn</code>, and possibly producing an error <code>E</code> during creation.</p><p><code>ZLayer</code> combined with the <em>ZIO Environment</em>, allow us to use ZIO for <em>dependency injection</em>. There are two parts of dependency injection:</p><ol><li><strong>Building Dependency Graph</strong></li><li><strong>Dependency Propagation</strong></li></ol><p>ZIO has a full solution to the dependency injection problem. It solves the first problem by using <a href="/next/datatypes/contextual/zlayer#manual-layer-construction">compositional properties</a> of <code>ZLayer</code>. Assume we have several services with their dependencies, and we need a way to compose and wire up these dependencies to create the dependency graph of the application. <code>ZLayer</code> is a ZIO solution for this problem. It allows us to build up the whole application dependency graph by composing layers horizontally and vertically. </p><p>ZIO also solves the second problem by using <a href="/next/datatypes/contextual/zlayer#dependency-propagation">ZIO Environment facilities like <code>ZIO#provide</code></a>.</p><blockquote><p><strong>Note:</strong></p><p>By using ZLayer and ZIO Environment we can solve the propagation and wire-up problems in dependency injection. Note that we are not enforced to use this approach, as we can still use things like <a href="https://github.com/google/guice" target="_blank" rel="noopener noreferrer">Guice</a> with ZIO, or we might like to use <a href="https://izumi.7mind.io/distage/index.html" target="_blank" rel="noopener noreferrer">izumi distage</a> solution for dependency injection.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="defining-zio-services">Defining ZIO Services<a class="hash-link" href="#defining-zio-services" title="Direct link to heading">​</a></h2><p>Defining services in ZIO is not very different from object-oriented style, it has the same principle: coding to an interface, not an implementation. Therefore, ZIO encourages us to implement this principle by using <em>Service Pattern</em>, which is quite similar to the object-oriented style.</p><p>Before diving into writing services in ZIO style, let&#x27;s review how we define them in an object-oriented fashion in the next section.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="defining-services-in-oop">Defining Services in OOP<a class="hash-link" href="#defining-services-in-oop" title="Direct link to heading">​</a></h3><p>Here are the steps we take to implement a service in object-oriented programming:</p><ol><li><strong>Service Definition</strong> — In object-oriented programming, we define services with traits. A service is a bundle of related functionality that is defined in a trait:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait FooService {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="2"><li><strong>Service Implementation</strong> — We implement these services by using classes:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">class FooServiceImpl extends FooService {</span><br></span><span class="token-line"><span class="token plain">    </span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="3"><li><strong>Defining Dependencies</strong> — If the creation of a service depends on other services, we can define these dependencies by using constructors:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait ServiceA {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait ServiceB {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">class FooServiceImpl(a: ServiceA, b: ServiceB) {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In object-oriented programming, the best practice is to <em>program to an interface, not an implementation</em>. So in the previous example, <code>ServiceA</code> and <code>ServiceB</code> are interfaces, not concrete classes.</p><ol start="4"><li><strong>Injecting Dependencies</strong> — Now, the client of <code>FooServiceImpl</code> service can provide its own implementation of <code>ServiceA</code> and <code>ServiceB</code>, and inject them to the <code>FooServiceImpl</code> constructor:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">class ServiceAImpl extends ServiceA</span><br></span><span class="token-line"><span class="token plain">class ServiceBImpl extends ServiceB</span><br></span><span class="token-line"><span class="token plain">val fooService = new FooServiceImpl(new ServiceAImpl, new ServiceBImpl)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Sometimes, as the number of dependent services grows and the dependency graph of our application becomes complicated, we need an automatic way of wiring and providing dependencies into the services of our application. In these situations, we might use a dependency injection framework to do all its magic machinery for us.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="defining-services-in-zio">Defining Services in ZIO<a class="hash-link" href="#defining-services-in-zio" title="Direct link to heading">​</a></h3><p>A service is a group of functions that deals with only one concern. Keeping the scope of each service limited to a single responsibility improves our ability to understand code, in that we need to focus only on one topic at a time without juggling too many concepts together in our head.</p><p><code>ZIO</code> itself provides the basic capabilities through modules, e.g. see how <code>ZEnv</code> is defined.</p><p>In functional Scala as well as in object-oriented programming the best practice is to <em>Program to an Interface, Not an Implementation</em>. This is the most important design principle in software development and helps us to write maintainable code by:</p><ul><li><p>Allowing the client to hold an interface as a contract and don&#x27;t worry about the implementation. The interface signature determines all operations that should be done.</p></li><li><p>Enabling a developer to write more testable programs. When we write a test for our business logic we don&#x27;t have to run and interact with real services like databases which makes our test run very slow. If our code is correct our test code should always pass, there should be no hidden variables or depend on outside sources. We can&#x27;t know that the database is always running correctly. We don&#x27;t want to fail our tests because of the failure of external service.</p></li><li><p>Providing the ability to write more modular applications. So we can plug in different implementations for different purposes without a major modification.</p></li></ul><p>It is not mandatory, but ZIO encourages us to follow this principle by bundling related functionality as an interface by using the <em>Service Pattern</em>.</p><p>The core idea is that a layer depends upon the interfaces exposed by the layers immediately below itself, but is completely unaware of its dependencies&#x27; internal implementations.</p><p>In object-oriented programming:</p><ul><li><strong>Service Definition</strong> is done by using <em>interfaces</em> (Scala trait or Java Interface).</li><li><strong>Service Implementation</strong> is done by implementing interfaces using <em>classes</em> or creating <em>new object</em> of the interface.</li><li><strong>Defining Dependencies</strong> is done by using <em>constructors</em>. They allow us to build classes, given their dependencies. This is called constructor-based dependency injection.</li></ul><p>We have a similar analogy in the Service Pattern, except instead of using <em>constructors</em> we use <strong><code>ZLayer</code></strong> to define dependencies. So in ZIO fashion, we can think of <code>ZLayer</code> as a service constructor.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="service-pattern">Service Pattern<a class="hash-link" href="#service-pattern" title="Direct link to heading">​</a></h3><p>Writing services in ZIO using the <em>Service Pattern</em> is very similar to the object-oriented way of defining services. We use scala traits to define services, classes to implement services, and constructors to define service dependencies. Finally, we lift the class constructor into the <code>ZLayer</code>.</p><p>Let&#x27;s start learning this service pattern by writing a <code>Logging</code> service:</p><ol><li><strong>Service Definition</strong> — Traits are how we define services. A service could be all the stuff that is related to one concept with singular responsibility. We define the service definition with a trait named <code>Logging</code>:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(line: String): UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="2"><li><strong>Service Implementation</strong> — It is the same as what we did in an object-oriented fashion. We implement the service with the Scala class. By convention, we name the live version of its implementation as <code>LoggingLive</code>:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">case class LoggingLive() extends Logging {</span><br></span><span class="token-line"><span class="token plain">  override def log(line: String): UIO[Unit] = </span><br></span><span class="token-line"><span class="token plain">    ZIO.succeed(print(line))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="3"><li><strong>Define Service Dependencies</strong> — We might need <code>Console</code> and <code>Clock</code> services to implement the <code>Logging</code> service. Here, we put its dependencies into its constructor. All the dependencies are just interfaces, not implementation. Just like what we did in object-oriented style:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">case class LoggingLive(console: Console, clock: Clock) extends Logging {</span><br></span><span class="token-line"><span class="token plain">  override def log(line: String): UIO[Unit] = </span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      current &lt;- clock.currentDateTime</span><br></span><span class="token-line"><span class="token plain">      _       &lt;- console.printLine(s&quot;$current--$line&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="4"><li><strong>Defining ZLayer</strong> — Now, we create a companion object for <code>LoggingLive</code> data type and lift the service implementation into the <code>ZLayer</code>:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object LoggingLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: URLayer[Any, Logging] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        console &lt;- ZIO.console</span><br></span><span class="token-line"><span class="token plain">        clock   &lt;- ZIO.clock</span><br></span><span class="token-line"><span class="token plain">      } yield LoggingLive(console, clock)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Note that the previous step is syntactic sugar of writing the layer directly in combination with for-comprehension style of accessing the ZIO environment:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object LoggingLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[Any, Nothing, Logging] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        console &lt;- ZIO.service[Console]</span><br></span><span class="token-line"><span class="token plain">        clock   &lt;- ZIO.service[Clock]</span><br></span><span class="token-line"><span class="token plain">      } yield LoggingLive(console, clock)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="5"><li><strong>Accessor Methods</strong> — Finally, to create the API more ergonomic, it&#x27;s better to write accessor methods for all of our service methods using <code>ZIO.serviceWithZIO</code> constructor inside the companion object:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(line: String): URIO[Logging, Unit] = ZIO.serviceWithZIO[Logging](_.log(line))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Accessor methods allow us to utilize all the features inside the service through the ZIO Environment. That means, if we call <code>Logging.log</code>, we don&#x27;t need to pull out the <code>log</code> function from the ZIO Environment. The <code>ZIO.serviceWithZIO</code> constructor helps us to access the environment and reduce the redundant operations, every time.</p><p>This is how ZIO services are created. Let&#x27;s use the <code>Logging</code> service in our application. We should provide the live layer of the <code>Logging</code> service to be able to run the application:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import java.io.IOException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  val app: ZIO[Logging, IOException, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- Logging.log(&quot;Application Started!&quot;)</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- Console.print(&quot;Enter your name:&quot;)</span><br></span><span class="token-line"><span class="token plain">      name &lt;- Console.readLine</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- Console.printLine(s&quot;Hello, $name!&quot;)</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- Logging.log(&quot;Application Exited!&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = app.provide(LoggingLive.layer)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>During writing the application, we don&#x27;t care which implementation version of the <code>Logging</code> service will be injected into our <code>app</code>, later at the end of the day, it will be provided by one of <code>ZIO#provide*</code> methods.</p><p>That&#x27;s it! Very simple! ZIO encourages us to follow some of the best practices in object-oriented programming. So it doesn&#x27;t require us to throw away all our object-oriented knowledge.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="defining-polymorphic-services-in-zio">Defining Polymorphic Services in ZIO<a class="hash-link" href="#defining-polymorphic-services-in-zio" title="Direct link to heading">​</a></h3><p>As we discussed <a href="/next/datatypes/contextual/zenvironment">here</a>, the <code>ZEnvironment</code>, which is the underlying data type used by <code>ZLayer</code>, is backed by a type-level mapping from types of services to implementations of those services. This functionality is backed by <code>izumi.reflect.Tag</code>, which captures a type as a value. </p><p>We just need to know what is the type of service when we put it in the <code>ZEnvironment</code> because <code>ZEnvironment</code> is essentially a map from <em>service types (interfaces)</em> to <em>implementation of those interfaces</em>. To implement the map, the <code>ZEnvironment</code> needs a type tag for the new service, and also needs a way to remove the old service from the type level map. So we should have service type information at the runtime. </p><p>We can think of <code>Tag[A]</code> as like a <code>TypeTag[A]</code> or <code>ClassTag[A]</code> from the Scala standard library but available on a cross-version and cross-platform basis. Basically, it carries information about a certain type into runtime that was available at compile time. Methods that construct <code>ZEnvironment</code> values generally require a tag for the value being included in the “bundle of services”. </p><p>As a user, we should not normally interact with <code>Tag</code> except where we define polymorphic services. In general, a <code>Tag</code> should always be available whenever we have a concrete type. The only time we should have to use it is when we have a <em>polymorphic service</em>. If we are using polymorphic code, we need to provide implicit evidence that a tag exists for that type (<code>implicit tag: Tag[A]</code>) or as a context-bound for that type parameter: (<code>A: Tag</code>).</p><p>Let&#x27;s try to write a polymorphic service. Assume we have the following service interface:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait KeyValueStore[K, V, E, F[_, _]] {</span><br></span><span class="token-line"><span class="token plain">  def get(key: K): F[E, V]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def set(key: K, value: V): F[E, V]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def remove(key: K): F[E, Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In the next step, we are going to write its accessors. We might end up with the following snippet code:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object KeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  def get[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def set[K, V, E](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def remove[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.remove(key))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// &lt;trace&gt;: </span><br></span><span class="token-line"><span class="token plain">//   deriving Tag for K, dealiased: K:</span><br></span><span class="token-line"><span class="token plain">//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!</span><br></span><span class="token-line"><span class="token plain">//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))</span><br></span><span class="token-line"><span class="token plain">//                                                   ^</span><br></span><span class="token-line"><span class="token plain">// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// &lt;trace&gt;: </span><br></span><span class="token-line"><span class="token plain">//   deriving Tag for K, dealiased: K:</span><br></span><span class="token-line"><span class="token plain">//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!</span><br></span><span class="token-line"><span class="token plain">//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))</span><br></span><span class="token-line"><span class="token plain">//                                                   ^</span><br></span><span class="token-line"><span class="token plain">// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// &lt;trace&gt;: </span><br></span><span class="token-line"><span class="token plain">//   deriving Tag for K, dealiased: K:</span><br></span><span class="token-line"><span class="token plain">//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!</span><br></span><span class="token-line"><span class="token plain">//     ZIO.serviceWithZIO(_.remove(key))</span><br></span><span class="token-line"><span class="token plain">//                       ^</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The compiler generates the following errors:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">&lt;trace&gt;: </span><br></span><span class="token-line"><span class="token plain">  deriving Tag for K, dealiased: K:</span><br></span><span class="token-line"><span class="token plain">  could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As the compiler says, we should put <code>Tag</code> as a context-bound for <code>K</code>, <code>V</code>, and <code>E</code> type parameters:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object KeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  def get[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def set[K: Tag, V: Tag, E: Tag](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def remove[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.remove(key))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Now, we can continue and implement the in-memory version of this key-value store:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])</span><br></span><span class="token-line"><span class="token plain">  extends KeyValueStore[String, Int, String, IO] {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(key: String): IO[String, Int] =</span><br></span><span class="token-line"><span class="token plain">    map.get.map(_.get(key)).someOrFail(s&quot;$key not found&quot;)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def set(key: String, value: Int): IO[String, Int] =</span><br></span><span class="token-line"><span class="token plain">    map.update(_.updated(key, value)).map(_ =&gt; value)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def remove(key: String): IO[String, Unit] =</span><br></span><span class="token-line"><span class="token plain">    map.update(_.removed(key))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object InmemoryKeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  def layer: ULayer[KeyValueStore[String, Int, String, IO]] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      Ref.make(Map[String, Int]()).map(InmemoryKeyValueStore.apply)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The last step is to use the service in a ZIO application:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[KeyValueStore[String, Int, String, IO], String, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- KeyValueStore.set[String, Int, String](&quot;key1&quot;, 3).debug</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- KeyValueStore.get[String, Int, String](&quot;key1&quot;).debug</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- KeyValueStore.remove[String, Int, String](&quot;key1&quot;)</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- KeyValueStore.get[String, Int, String](&quot;key1&quot;).either.debug</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(InmemoryKeyValueStore.layer)</span><br></span><span class="token-line"><span class="token plain">  </span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Note that in the above example, one might want to write accessors more polymorphic. So in this case we should add <code>TagKK</code> as a context-bound of the <code>F</code> type parameter:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object KeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  def get[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.get(key))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def set[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K, value: V): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.set(key, value))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def remove[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], E, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWith(_.remove(key))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="generating-accessor-methods-using-macros">Generating Accessor Methods Using Macros<a class="hash-link" href="#generating-accessor-methods-using-macros" title="Direct link to heading">​</a></h3><p>Writing accessor methods is a repetitive task and would be cumbersome in services with many methods. We can automate the generation of accessor methods using <code>zio-macro</code> module. </p><p>To install the <code>zio-macro</code> we should add the following line in our <code>build.sbt</code> file:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">libraryDependencies += &quot;dev.zio&quot; %% &quot;zio-macros&quot; % &quot;&lt;zio-version&gt;&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Also, to enable macro expansion we need to setup our project:</p><ul><li><p>for Scala <code>&gt;= 2.13</code> add compiler option:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">scalacOptions += &quot;-Ymacro-annotations&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></li><li><p>for Scala <code>&lt; 2.13</code> add macro paradise compiler plugin:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">compilerPlugin((&quot;org.scalamacros&quot; % &quot;paradise&quot;  % &quot;2.1.1&quot;) cross CrossVersion.full)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></li></ul><blockquote><p><strong>Note:</strong></p><p>At the moment these are only available for Scala versions <code>2.x</code>, however their equivalents for Scala 3 are on our roadmap.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_mojV" id="monomorphic-services">Monomorphic Services<a class="hash-link" href="#monomorphic-services" title="Direct link to heading">​</a></h4><p>We can use the <code>@accessible</code> macro to generate <em>service member accessors</em>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.macros.accessible</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">@accessible</span><br></span><span class="token-line"><span class="token plain">trait ServiceA {</span><br></span><span class="token-line"><span class="token plain">  def method(input: Something): UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// below will be autogenerated</span><br></span><span class="token-line"><span class="token plain">object ServiceA {</span><br></span><span class="token-line"><span class="token plain">  def method(input: Something) =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO[ServiceA](_.method(event))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>For normal values, a <code>ZIO</code> with <code>Nothing</code> on error channel is generated:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.macros.accessible</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">@accessible</span><br></span><span class="token-line"><span class="token plain">trait ServiceB {</span><br></span><span class="token-line"><span class="token plain">  def pureMethod(input: Something): SomethingElse</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// below will be autogenerated</span><br></span><span class="token-line"><span class="token plain">object ServiceB {</span><br></span><span class="token-line"><span class="token plain">  def pureMethod(input: Something): ZIO[ServiceB, Nothing, SomethingElse] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWith[ServiceB](_.pureMethod(input))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The <code>@throwing</code> annotation will mark impure methods. Using this annotation will request ZIO to push the error on the error channel:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.macros.accessible</span><br></span><span class="token-line"><span class="token plain">import zio.macros.throwing</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">@accessible</span><br></span><span class="token-line"><span class="token plain">trait ServiceC {</span><br></span><span class="token-line"><span class="token plain">  @throwing</span><br></span><span class="token-line"><span class="token plain">  def impureMethod(input: Something): SomethingElse</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// below will be autogenerated</span><br></span><span class="token-line"><span class="token plain">object ServiceC {</span><br></span><span class="token-line"><span class="token plain">  def impureMethod(input: Something): ZIO[ServiceC, Throwable, SomethingElse] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO[ServiceC](s =&gt; ZIO(s.impureMethod(input)))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Below is a fully working example:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.macros.accessible</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">@accessible</span><br></span><span class="token-line"><span class="token plain">trait KeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  def set(key: String, value: Int): Task[Int]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(key: String): Task[Int]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])</span><br></span><span class="token-line"><span class="token plain">  extends KeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  override def set(key: String, value: Int): Task[Int] =</span><br></span><span class="token-line"><span class="token plain">    map.update(_.updated(key, value)).map(_ =&gt; value)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(key: String): Task[Int] =</span><br></span><span class="token-line"><span class="token plain">    map.get.map(_.get(key)).someOrFailException</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object InmemoryKeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  val layer: ULayer[KeyValueStore] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        map &lt;- Ref.make(Map[String, Int]())</span><br></span><span class="token-line"><span class="token plain">      } yield InmemoryKeyValueStore(map)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  val myApp =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _   &lt;- KeyValueStore.set(&quot;key&quot;, 5)</span><br></span><span class="token-line"><span class="token plain">      key &lt;- KeyValueStore.get(&quot;key&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield key</span><br></span><span class="token-line"><span class="token plain">    </span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(InmemoryKeyValueStore.layer).debug</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="writing-polymorphic-services">Writing Polymorphic Services<a class="hash-link" href="#writing-polymorphic-services" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_mojV" id="with-proper-type-parameters">With Proper Type Parameters<a class="hash-link" href="#with-proper-type-parameters" title="Direct link to heading">​</a></h5><p>If the service is polymorphic for some proper types, we can use the <code>@accessible</code> macro like previous examples.</p><p>Assume we have a <code>KeyValueStore</code> like below, as we will see using <code>@accessible</code> will generate us the accessor methods:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.macros.accessible</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">@accessible</span><br></span><span class="token-line"><span class="token plain">trait KeyValueStore[K, V] {</span><br></span><span class="token-line"><span class="token plain">  def set(key: K, value: V): Task[V]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(key: K): Task[V]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])</span><br></span><span class="token-line"><span class="token plain">  extends KeyValueStore[String, Int] {</span><br></span><span class="token-line"><span class="token plain">  override def set(key: String, value: Int): Task[Int] =</span><br></span><span class="token-line"><span class="token plain">    map.update(_.updated(key, value)).map(_ =&gt; value)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(key: String): Task[Int] =</span><br></span><span class="token-line"><span class="token plain">    map.get.map(_.get(key)).someOrFailException</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object InmemoryKeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  val layer: ULayer[KeyValueStore[String, Int]] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        map &lt;- Ref.make(Map[String, Int]())</span><br></span><span class="token-line"><span class="token plain">      } yield InmemoryKeyValueStore(map)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  val myApp =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- KeyValueStore.set(&quot;key&quot;, 5)</span><br></span><span class="token-line"><span class="token plain">      key &lt;- KeyValueStore.get[String, Int](&quot;key&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield key</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(InmemoryKeyValueStore.layer).debug</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="with-higher-kinded-type-parameters-f_">With Higher-Kinded Type Parameters (<code>F[_]</code>)<a class="hash-link" href="#with-higher-kinded-type-parameters-f_" title="Direct link to heading">​</a></h5><p>If a service has a higher-kinded type parameter like <code>F[_]</code> we should use the <code>accessibleM</code> macro. Here is an example of such a service:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.macros.accessibleM</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">@accessibleM[Task]</span><br></span><span class="token-line"><span class="token plain">trait KeyValueStore[K, V, F[_]] {</span><br></span><span class="token-line"><span class="token plain">  def set(key: K, value: V): F[V]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(key: K): F[V]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])</span><br></span><span class="token-line"><span class="token plain">  extends KeyValueStore[String, Int, Task] {</span><br></span><span class="token-line"><span class="token plain">  override def set(key: String, value: Int): Task[Int] =</span><br></span><span class="token-line"><span class="token plain">    map.update(_.updated(key, value)).map(_ =&gt; value)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(key: String): Task[Int] =</span><br></span><span class="token-line"><span class="token plain">    map.get.map(_.get(key)).someOrFailException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object InmemoryKeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  val layer: ULayer[KeyValueStore[String, Int, Task]] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        map &lt;- Ref.make(Map[String, Int]())</span><br></span><span class="token-line"><span class="token plain">      } yield InmemoryKeyValueStore(map)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  val myApp =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      key &lt;- KeyValueStore.set[String, Int](&quot;key&quot;, 5)</span><br></span><span class="token-line"><span class="token plain">      _   &lt;- KeyValueStore.get[String, Int](&quot;key&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield key</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(InmemoryKeyValueStore.layer).debug</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="with-higher-kinded-type-parameters-f_-_">With Higher-Kinded Type Parameters (<code>F[_, _]</code>)<a class="hash-link" href="#with-higher-kinded-type-parameters-f_-_" title="Direct link to heading">​</a></h5><p>If the service has a higher-kinded type parameter like <code>F[_, _]</code> we should use the <code>accessibleMM</code> macro. Let&#x27;s see an example:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.macros.accessibleMM</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">@accessibleMM[IO]</span><br></span><span class="token-line"><span class="token plain">trait KeyValueStore[K, V, E, F[_, _]] {</span><br></span><span class="token-line"><span class="token plain">  def set(key: K, value: V): F[E, V]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(key: K): F[E, V]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])</span><br></span><span class="token-line"><span class="token plain">  extends KeyValueStore[String, Int, String, IO] {</span><br></span><span class="token-line"><span class="token plain">  override def set(key: String, value: Int): IO[String, Int] =</span><br></span><span class="token-line"><span class="token plain">    map.update(_.updated(key, value)).map(_ =&gt; value)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(key: String): IO[String, Int] =</span><br></span><span class="token-line"><span class="token plain">    map.get.map(_.get(key)).someOrFail(s&quot;key not found: $key&quot;)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object InmemoryKeyValueStore {</span><br></span><span class="token-line"><span class="token plain">  val layer: ULayer[KeyValueStore[String, Int, String, IO]] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        map &lt;- Ref.make(Map[String, Int]())</span><br></span><span class="token-line"><span class="token plain">      } yield InmemoryKeyValueStore(map)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  val myApp =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _   &lt;- KeyValueStore.set[String, Int, String](&quot;key&quot;, 5)</span><br></span><span class="token-line"><span class="token plain">      key &lt;- KeyValueStore.get[String, Int, String](&quot;key&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield key</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(InmemoryKeyValueStore.layer).debug</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="support-for-scala-3">Support for Scala 3<a class="hash-link" href="#support-for-scala-3" title="Direct link to heading">​</a></h4><p>As we’ve already mentioned, currently we have no macro support for Scala 3, instead we provide the <code>Accessible</code> trait that is a macro-less means of creating accessors from services. We can simply extend the companion object with <code>Accessible[ServiceName]</code> and then call <code>Companion(_.someMethod)</code> to return a ZIO effect that requires the service in its environment:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait ServiceD {</span><br></span><span class="token-line"><span class="token plain">  def method(input: Int): Task[String]</span><br></span><span class="token-line"><span class="token plain">  def anotherMethod: UIO[Int]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object ServiceD extends Accessible[ServiceD]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val myApp: ZIO[ServiceD, Throwable, (String, Int)] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    s &lt;- ServiceD(_.method(3))</span><br></span><span class="token-line"><span class="token plain">    i &lt;- ServiceD(_.anotherMethod)</span><br></span><span class="token-line"><span class="token plain">  } yield (s, i)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="the-three-laws-of-zio-environment">The Three Laws of ZIO Environment<a class="hash-link" href="#the-three-laws-of-zio-environment" title="Direct link to heading">​</a></h3><p>When we are working with the ZIO environment, one question might arise: &quot;When should we use environment and when do we need to use constructors?&quot;.</p><p>Using ZIO environment follows three laws:</p><ol><li><strong>Service Interface (Trait)</strong> — When we are defining service interfaces we should <em>never</em> use the environment for dependencies of the service itself.</li></ol><p>For example, if the implementation of service <code>X</code> depends on service <code>Y</code> and <code>Z</code> then these should never be reflected in the trait that defines service <code>X</code>. It&#x27;s leaking implementation details.</p><p>So the following service definition is wrong because the <code>Console</code> and <code>Clock</code> service are dependencies of the  <code>Logging</code> service&#x27;s implementation, not the <code>Logging</code> interface itself:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">trait Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(line: String): ZIO[Any, Nothing, Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="2"><li><strong>Service Implementation (Class)</strong> — When implementing service interfaces, we should accept all dependencies in the class constructor.</li></ol><p>Again, let&#x27;s see how <code>LoggingLive</code> accepts <code>Console</code> and <code>Clock</code> dependencies from the class constructor:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">case class LoggingLive(console: Console, clock: Clock) extends Logging {</span><br></span><span class="token-line"><span class="token plain">  override def log(line: String): UIO[Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      current &lt;- clock.currentDateTime</span><br></span><span class="token-line"><span class="token plain">      _       &lt;- console.printLine(s&quot;$current--$line&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>So keep in mind, we can&#x27;t do something like this:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">case class LoggingLive() extends Logging {</span><br></span><span class="token-line"><span class="token plain">  override def log(line: String) =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      clock   &lt;- ZIO.service[Clock]</span><br></span><span class="token-line"><span class="token plain">      console &lt;- ZIO.service[Console]</span><br></span><span class="token-line"><span class="token plain">      current &lt;- clock.currentDateTime</span><br></span><span class="token-line"><span class="token plain">      _       &lt;- console.printLine(s&quot;$current--$line&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// error: type mismatch;</span><br></span><span class="token-line"><span class="token plain">//  found   : zio.ZIO[zio.Console &amp; zio.Clock,Nothing,Unit]</span><br></span><span class="token-line"><span class="token plain">//     (which expands to)  zio.ZIO[zio.Console with zio.Clock,Nothing,Unit]</span><br></span><span class="token-line"><span class="token plain">//  required: zio.ZIO[Logging,Nothing,Unit]</span><br></span><span class="token-line"><span class="token plain">//   def log(line: String): URIO[Logging, Unit] = ZIO.serviceWithZIO[Logging](_.log(line))</span><br></span><span class="token-line"><span class="token plain">//                                                                            ^^^^^^^^^^^</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="3"><li><strong>Business Logic</strong> — Finally, in the business logic we should use the ZIO environment to consume services.</li></ol><p>Therefore, in the last example, if we inline all accessor methods whenever we are using services, we are using the ZIO environment:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import java.io.IOException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  val app: ZIO[Logging, IOException, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- ZIO.serviceWithZIO[Logging](_.log(&quot;Application Started!&quot;))</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- Console.print(&quot;Enter your name: &quot;)</span><br></span><span class="token-line"><span class="token plain">      name &lt;- Console.readLine</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- Console.printLine(s&quot;Hello, $name!&quot;)</span><br></span><span class="token-line"><span class="token plain">      _    &lt;- ZIO.serviceWithZIO[Logging](_.log(&quot;Application Exited!&quot;))</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = app.provide(LoggingLive.layer)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>That&#x27;s it! These are the most important rules we need to know about the ZIO environment.</p><blockquote><p><strong>Note</strong>:</p><p>The remaining part of this section can be skipped if you are not an advanced ZIO user.</p></blockquote><p>Now let&#x27;s elaborate more on the first rule. On rare occasions, all of which involve local context that is independent of implementation, it&#x27;s <em>acceptable</em> to use the environment in the definition of a service.</p><p>Here are two examples:</p><ol><li>In a web application, a service may be defined only to operate in the context of an HTTP request. In such a case, the request itself could be stored in the environment: <code>ZIO[HttpRequest, ...]</code>. This is acceptable because this use of the environment is part of the semantics of the trait itself, rather than leaking an implementation detail of some particular class that implements the service trait:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.stream._</span><br></span><span class="token-line"><span class="token plain">import java.net.URI</span><br></span><span class="token-line"><span class="token plain">import java.nio.charset.StandardCharsets</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">type HttpApp = ZIO[HttpRequest, Throwable, HttpResponse]</span><br></span><span class="token-line"><span class="token plain">type HttpRoute = Map[String, HttpApp]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class HttpRequest(method: Int,</span><br></span><span class="token-line"><span class="token plain">                       uri: URI,</span><br></span><span class="token-line"><span class="token plain">                       headers: Map[String, String],</span><br></span><span class="token-line"><span class="token plain">                       body: UStream[Byte])</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class HttpResponse(status: Int,</span><br></span><span class="token-line"><span class="token plain">                        headers: Map[String, String],</span><br></span><span class="token-line"><span class="token plain">                        body: UStream[Byte])</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object HttpResponse {</span><br></span><span class="token-line"><span class="token plain">  def apply(status: Int, message: String): HttpResponse =</span><br></span><span class="token-line"><span class="token plain">    HttpResponse(</span><br></span><span class="token-line"><span class="token plain">      status = status,</span><br></span><span class="token-line"><span class="token plain">      headers = Map.empty,</span><br></span><span class="token-line"><span class="token plain">      body = ZStream.fromChunk(</span><br></span><span class="token-line"><span class="token plain">        Chunk.fromArray(message.getBytes(StandardCharsets.UTF_8))</span><br></span><span class="token-line"><span class="token plain">      )</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def ok(msg: String): HttpResponse = HttpResponse(200, msg)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def error(msg: String): HttpResponse = HttpResponse(800, msg)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait HttpServer {</span><br></span><span class="token-line"><span class="token plain">  def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object HttpServer {</span><br></span><span class="token-line"><span class="token plain">  def serve(map: HttpRoute, host: String, port: Int): ZIO[HttpServer, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.serve(map, host, port))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class HttpServerLive() extends HttpServer {</span><br></span><span class="token-line"><span class="token plain">  override def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit] = ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object HttpServerLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: URLayer[Any, HttpServer] = ZLayer.succeed(HttpServerLive())</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainWebApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[HttpServer, Throwable, Unit] = for {</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- ZIO.unit</span><br></span><span class="token-line"><span class="token plain">    healthcheck: HttpApp = ZIO.service[HttpRequest].map { _ =&gt;</span><br></span><span class="token-line"><span class="token plain">      HttpResponse.ok(&quot;up&quot;)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    pingpong = ZIO.service[HttpRequest].flatMap { req =&gt;</span><br></span><span class="token-line"><span class="token plain">      ZIO.ifZIO(</span><br></span><span class="token-line"><span class="token plain">        req.body.via(ZPipeline.utf8Decode).runHead.map(_.contains(&quot;ping&quot;))</span><br></span><span class="token-line"><span class="token plain">      )(</span><br></span><span class="token-line"><span class="token plain">        onTrue = ZIO.attempt(HttpResponse.ok(&quot;pong&quot;)),</span><br></span><span class="token-line"><span class="token plain">        onFalse = ZIO.attempt(HttpResponse.error(&quot;bad request&quot;))</span><br></span><span class="token-line"><span class="token plain">      )</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    map = Map(</span><br></span><span class="token-line"><span class="token plain">      &quot;/healthcheck&quot; -&gt; healthcheck,</span><br></span><span class="token-line"><span class="token plain">      &quot;/pingpong&quot; -&gt; pingpong</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- HttpServer.serve(map, &quot;localhost&quot;, 8080)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provideLayer(HttpServerLive.layer)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="2"><li>In a database application, a service may be defined only to operate in the context of a larger database transaction. In such a case, the transaction could be stored in the environment: <code>ZIO[DatabaseTransaction, ...]</code>. As in the previous example, because this is part of the semantics of the trait itself (whose functionality all operates within a transaction), this is not leaking implementation details, and therefore it is valid:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait DatabaseTransaction {</span><br></span><span class="token-line"><span class="token plain">  def get(key: String): Task[Int]</span><br></span><span class="token-line"><span class="token plain">  def put(key: String, value: Int): Task[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object DatabaseTransaction {</span><br></span><span class="token-line"><span class="token plain">  def get(key: String): ZIO[DatabaseTransaction, Throwable, Int] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.get(key))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def put(key: String, value: Int): ZIO[DatabaseTransaction, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.put(key, value))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Database {</span><br></span><span class="token-line"><span class="token plain">  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Database {</span><br></span><span class="token-line"><span class="token plain">  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Database, E, A] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.atomically(zio))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class DatabaseLive() extends Database {</span><br></span><span class="token-line"><span class="token plain">  override def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A] = ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object DatabaseLive {</span><br></span><span class="token-line"><span class="token plain">  val layer = ZLayer.succeed(DatabaseLive())</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainDatabaseApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[Database, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- Database.atomically(DatabaseTransaction.put(&quot;counter&quot;, 0))</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.foreachPar(List(1 to 10)) { _ =&gt;</span><br></span><span class="token-line"><span class="token plain">        Database.atomically(</span><br></span><span class="token-line"><span class="token plain">          for {</span><br></span><span class="token-line"><span class="token plain">            value &lt;- DatabaseTransaction.get(&quot;counter&quot;)</span><br></span><span class="token-line"><span class="token plain">            _ &lt;- DatabaseTransaction.put(&quot;counter&quot;, value + 1)</span><br></span><span class="token-line"><span class="token plain">          } yield ()</span><br></span><span class="token-line"><span class="token plain">        )</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provideLayer(DatabaseLive.layer)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>So while it&#x27;s better to err on the side of &quot;don&#x27;t put things into the environment of service interface&quot;, there are cases where it&#x27;s acceptable.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zio/zio/edit/series/2.x/docs/datatypes/contextual/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/next/datatypes/core/cause"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Cause</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/next/datatypes/contextual/zenvironment"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ZEnvironment</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-zio-environment" class="table-of-contents__link toc-highlight">1. ZIO Environment</a><ul><li><a href="#motivation" class="table-of-contents__link toc-highlight">Motivation</a></li><li><a href="#advantage-of-using-zio-environment" class="table-of-contents__link toc-highlight">Advantage of Using ZIO Environment</a></li><li><a href="#accessing-zio-environment" class="table-of-contents__link toc-highlight">Accessing ZIO Environment</a></li></ul></li><li><a href="#2-zenvironment" class="table-of-contents__link toc-highlight">2. ZEnvironment</a></li><li><a href="#3-zlayer" class="table-of-contents__link toc-highlight">3. ZLayer</a></li><li><a href="#defining-zio-services" class="table-of-contents__link toc-highlight">Defining ZIO Services</a><ul><li><a href="#defining-services-in-oop" class="table-of-contents__link toc-highlight">Defining Services in OOP</a></li><li><a href="#defining-services-in-zio" class="table-of-contents__link toc-highlight">Defining Services in ZIO</a></li><li><a href="#service-pattern" class="table-of-contents__link toc-highlight">Service Pattern</a></li><li><a href="#defining-polymorphic-services-in-zio" class="table-of-contents__link toc-highlight">Defining Polymorphic Services in ZIO</a></li><li><a href="#generating-accessor-methods-using-macros" class="table-of-contents__link toc-highlight">Generating Accessor Methods Using Macros</a></li><li><a href="#the-three-laws-of-zio-environment" class="table-of-contents__link toc-highlight">The Three Laws of ZIO Environment</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items"><li class="footer__item">
                <img src="/img/navbar_brand.png" alt="zio">
            </li></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items"><li class="footer__item">
              <a href="https://github.com/zio/zio">
                <img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github">
              </a>
            </li></ul></div><div class="col footer__col"><div class="footer__title">Chat with us on Discord</div><ul class="footer__items"><li class="footer__item">
                <a href="https://discord.gg/2ccFBr4">
                  <img src="https://img.shields.io/discord/629491597070827530?logo=discord&style=social" alt="discord">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Follow us on Twitter</div><ul class="footer__items"><li class="footer__item">
                <a href="https://twitter.com/zioscala">
                  <img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&style=social" alt="twitter">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Additional resources</div><ul class="footer__items"><li class="footer__item"><a href="https://javadoc.io/doc/dev.zio/zio_2.12/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scaladoc of ZIO<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 ZIO Maintainers - Built with <a href="https://v2.docusaurus.io/">Docusaurus v2</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.e0bb0b29.js"></script>
<script src="/assets/js/main.3950424f.js"></script>
</body>
</html>