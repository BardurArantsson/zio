<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="search" type="application/opensearchdescription+xml" title="ZIO" href="/opensearch.xml">
<link rel="stylesheet" href="/css/prism/prism-material-dark.css"><title data-react-helmet="true">ZLayer | ZIO</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://zio.dev/next/datatypes/contextual/zlayer"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="ZLayer | ZIO"><meta data-react-helmet="true" name="description" content="A ZLayer[-RIn, +E, +ROut] describes a layer of an application: every layer in an application requires some services as input RIn and produces some services as the output ROut."><meta data-react-helmet="true" property="og:description" content="A ZLayer[-RIn, +E, +ROut] describes a layer of an application: every layer in an application requires some services as input RIn and produces some services as the output ROut."><link data-react-helmet="true" rel="icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://zio.dev/next/datatypes/contextual/zlayer"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/next/datatypes/contextual/zlayer" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/next/datatypes/contextual/zlayer" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.eb47feb5.css">
<link rel="preload" href="/assets/js/runtime~main.576d5781.js" as="script">
<link rel="preload" href="/assets/js/main.3950424f.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_W2Cr themedImage--dark_oUvU"></div></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/version-1.x/overview/">Overview</a><a class="navbar__item navbar__link" href="/version-1.x/datatypes/">Data Types</a><a class="navbar__item navbar__link" href="/version-1.x/usecases/">Use Cases</a><a class="navbar__item navbar__link" href="/version-1.x/howto/">How to</a><a class="navbar__item navbar__link" href="/version-1.x/resources/">Resources</a><a class="navbar__item navbar__link" href="/version-1.x/about/">About</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/next/overview/">ZIO 2.x (WIP)</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/next/datatypes/contextual/zlayer">ZIO 2.x (WIP)</a></li><li><a class="dropdown__link" href="/version-1.x/datatypes/contextual/zlayer">ZIO 1.x</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/">Overview</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/core/zio/">Core Data Types</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/next/datatypes/contextual/">Contextual Types</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/contextual/">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/contextual/zenvironment">ZEnvironment</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/next/datatypes/contextual/zlayer">ZIO Layers</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/next/datatypes/contextual/zlayer">ZLayer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/contextual/rlayer">RLayer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/contextual/ulayer">ULayer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/contextual/layer">Layer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/contextual/urlayer">URLayer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/next/datatypes/contextual/tasklayer">TaskLayer</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/next/datatypes/contextual/services/">Built-in Services</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/fiber/">Concurrency</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/resource/">Resource Management</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/stream/">Streaming</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/metrics/">Metrics</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/test/">ZIO Test</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/next/datatypes/misc/chunk">Miscellaneous</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for <!-- -->ZIO<!-- --> <b>ZIO 2.x (WIP)</b> version.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/version-1.x/datatypes/contextual/zlayer">latest version</a></b> (<!-- -->ZIO 1.x<!-- -->).</div></div><div class="docItemContainer_vinB"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->ZIO 2.x (WIP)</span><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>ZLayer</h1></header><p>A <code>ZLayer[-RIn, +E, +ROut]</code> describes a layer of an application: every layer in an application requires some services as input <code>RIn</code> and produces some services as the output <code>ROut</code>.</p><p>We can think of a layer as mental model of an asynchronous function from <code>RIn</code> to the <code>Either[E, ROut]</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">type ZLayer[-RIn, +E, +ROut] = RIn =&gt; async Either[E, ROut]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>For example, a <code>ZLayer[Clock &amp; Logging, Throwable, Database]</code> can be thought of as a function that map <code>Clock</code> and <code>Logging</code> services into <code>Database</code> service:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">(Clock, Logging) =&gt; Database</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>So we can say that the <code>Database</code> service has two dependencies: <code>Clock</code> and <code>Logging</code> services.</p><p>In some cases, a <code>ZLayer</code> may not have any dependencies or requirements from the environment. In this case, we can specify <code>Any</code> for the <code>RIn</code> type parameter. The <a href="/next/datatypes/contextual/layer"><code>Layer</code></a> type alias provided by ZIO is a convenient way to define a layer without requirements.</p><p>ZLayers are:</p><ol><li><p><strong>Recipes for Creating Services</strong> — They describe how to create services from given dependencies. For example, the <code>ZLayer[Logging &amp; Database, Throwable, UserRepo]</code> is a recipe for building a service that requires <code>Logging</code> and <code>Database</code> service, and it produces a <code>UserRepo</code> service.</p></li><li><p><strong>An Alternative to Constructors</strong> — We can think of <code>ZLayer</code> as a more powerful version of a constructor, it is an alternative way to represent a constructor. Like a constructor, it allows us to build the <code>ROut</code> service in terms of its dependencies (<code>RIn</code>).</p></li><li><p><strong>Composable</strong> — Because of their excellent <strong>composition properties</strong>, layers are the idiomatic way in ZIO to create services that depend on other services. We can define layers that are relying on each other.</p></li><li><p><strong>Effectful and Resourceful</strong> — The construction of ZIO layers can be effectful and resourceful. They can be acquired effectfully and safely released when the services are done being utilized or even in case of failure, interruption, or defects in the application. </p><p>For example, to create a recipe for a <code>Database</code> service, we should describe how the <code>Database</code> will be initialized using an acquisition action. In addition, it may contain information about how the <code>Database</code> releases its connection pools.</p></li><li><p><strong>Asynchronous</strong> — Unlike class constructors which are blocking, <code>ZLayer</code> is fully asynchronous and non-blocking. Note that in non-blocking applications we typically want to avoid creating something that is blocking inside its constructor.</p><p>For example, when we are constructing some sort of Kafka streaming service, we might want to connect to the Kafka cluster in the constructor of our service, which takes some time. So it wouldn&#x27;t be a good idea to block inside the constructor. There are some workarounds for fixing this issue, but they are not as perfect as the ZIO solution which allows for asynchronous, non-blocking constructors.</p></li><li><p><strong>Parallelism</strong> — ZIO layers can be acquired in parallel, unlike class constructors, which do not support parallelism. When we compose multiple layers and then acquire them, the construction of each layer will occur in parallel. This will reduce the initialization time of ZIO applications with a large number of dependencies.</p><p>With ZIO ZLayer, our constructor could be asynchronous, but it could also block. We can acquire resources asynchronously or in a blocking fashion, and spend some time doing that, and we don&#x27;t need to worry about it. That is not an anti-pattern. This is the best practice with ZIO. And that is because <code>ZLayer</code> has the full power of the <code>ZIO</code> data type, and as a result, we have strictly more power on our constructors with <code>ZLayer</code>.</p></li><li><p><strong>Resilient</strong> — Layer construction can be resilient. So if the acquiring phase fails, we can have a schedule to retry the acquiring stage. This helps us write apps that are error-proof and respond appropriately to failures.</p></li></ol><p>Let&#x27;s see how we can create a layer:</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="creation">Creation<a class="hash-link" href="#creation" title="Direct link to heading">​</a></h2><p>There are four main ways to create a ZLayer:</p><ol><li><code>ZLayer.succeed</code> for creating layers from simple values.</li><li><code>ZLayer.scoped</code> for creating layers with <em>for comprehension</em> style from resourceful effects.</li><li><code>ZLayer.apply</code>/<code>ZLayer.fromZIO</code> for creating layers with <em>for comprehension</em> style from effectual but not resourceful effects.</li><li><code>ZLayer.fromFunction</code> for creating layers that are neither effectual nor resourceful.</li></ol><p>Now let&#x27;s look at each of these methods.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="from-a-simple-value-or-an-existing-service">From a Simple Value or an Existing Service<a class="hash-link" href="#from-a-simple-value-or-an-existing-service" title="Direct link to heading">​</a></h3><p>With <code>ZLayer.succeed</code> we can construct a <code>ZLayer</code> from a value. It returns a <code>ULayer[A]</code> value, which represents a layer of an application that has a service of type <code>A</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def succeed[A: Tag](a: A): ULayer[A]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Using <code>ZLayer.succeed</code> we can create a layer containing <em>simple value</em> or a <em>service</em>:</p><ol><li>To create a layer from a <em>simple value</em>:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class AppConfig(host: String, port: Int)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val configLayer: ULayer[AppConfig] = ZLayer.succeed(AppConfig(&quot;localhost&quot;, 8080))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In the example above, we created a <code>configLayer</code> that provides us an instance of <code>AppConfig</code>.</p><ol start="2"><li>To create a layer from an <em>existing service</em>:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(line: String): UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Logging {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[Any, Nothing, Logging] = </span><br></span><span class="token-line"><span class="token plain">    ZLayer.succeed( </span><br></span><span class="token-line"><span class="token plain">      new Logging {</span><br></span><span class="token-line"><span class="token plain">        override def log(line: String): UIO[Unit] =</span><br></span><span class="token-line"><span class="token plain">          ZIO.succeed(println(line))</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="from-resourceful-effects-scoped-resources">From Resourceful Effects (Scoped Resources)<a class="hash-link" href="#from-resourceful-effects-scoped-resources" title="Direct link to heading">​</a></h3><p>Some components of our applications need to be scoped, meaning they undergo a resource acquisition phase before usage, and a resource release phase after usage (e.g. when the application shuts down). As we stated before, the construction of ZIO layers can be effectful and resourceful, this means they can be acquired and safely released when the services are done being utilized.</p><p>The <code>ZLayer</code> relies on the powerful <code>Scope</code> data type and this makes this process extremely simple. We can lift any scoped <code>ZIO</code> to <code>ZLayer</code> by providing a scoped resource to the <code>ZLayer.apply</code> constructor:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import scala.io.BufferedSource</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fileLayer: ZLayer[Any, Throwable, BufferedSource] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer.scoped {</span><br></span><span class="token-line"><span class="token plain">    ZIO.fromAutoCloseable(</span><br></span><span class="token-line"><span class="token plain">      ZIO.attempt(scala.io.Source.fromFile(&quot;file.txt&quot;))</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Let&#x27;s see a real-world example of creating a layer from scoped resources. Assume we have the following <code>UserRepository</code> service:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import scala.io.Source._</span><br></span><span class="token-line"><span class="token plain">import java.io.{FileInputStream, FileOutputStream, Closeable}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait DBConfig</span><br></span><span class="token-line"><span class="token plain">trait Transactor</span><br></span><span class="token-line"><span class="token plain">trait User</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">def dbConfig: Task[DBConfig] = Task.attempt(???)</span><br></span><span class="token-line"><span class="token plain">def initializeDb(config: DBConfig): Task[Unit] = Task.attempt(???)</span><br></span><span class="token-line"><span class="token plain">def makeTransactor(config: DBConfig): ZIO[Scope, Throwable, Transactor] = ZIO.attempt(???)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait UserRepository {</span><br></span><span class="token-line"><span class="token plain">  def save(user: User): Task[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class UserRepositoryLive(xa: Transactor) extends UserRepository {</span><br></span><span class="token-line"><span class="token plain">  override def save(user: User): Task[Unit] = ZIO.attempt(???)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Assume we have written a scoped <code>UserRepository</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">def scoped: ZIO[Scope, Throwable, UserRepository] = </span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    cfg &lt;- dbConfig</span><br></span><span class="token-line"><span class="token plain">    _   &lt;- initializeDb(cfg)</span><br></span><span class="token-line"><span class="token plain">    xa  &lt;- makeTransactor(cfg)</span><br></span><span class="token-line"><span class="token plain">  } yield new UserRepositoryLive(xa)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We can convert that to <code>ZLayer</code> with <code>ZLayer.apply</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val usersLayer : ZLayer[Any, Throwable, UserRepository] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer.scoped(scoped)</span><br></span><span class="token-line"><span class="token plain">// usersLayer: ZLayer[Any, Throwable, UserRepository] = Scoped(</span><br></span><span class="token-line"><span class="token plain">//   self = &lt;function1&gt;</span><br></span><span class="token-line"><span class="token plain">// )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="from-non-resourceful-effects">From Non-resourceful Effects<a class="hash-link" href="#from-non-resourceful-effects" title="Direct link to heading">​</a></h3><p>We can create <code>ZLayer</code> from any <code>ZIO</code> effect by using <code>ZLayer.fromZIO</code>/<code>ZLayer.apply</code> constructor.</p><p>For example, assume we have a <code>ZIO</code> effect that reads the application config from a file, we can create a layer from that:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class AppConfig(poolSize: Int)</span><br></span><span class="token-line"><span class="token plain">  </span><br></span><span class="token-line"><span class="token plain">def loadConfig : Task[AppConfig] = </span><br></span><span class="token-line"><span class="token plain">  Task.attempt(???)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object AppConfig {</span><br></span><span class="token-line"><span class="token plain">  val layer: TaskLayer[AppConfig] = </span><br></span><span class="token-line"><span class="token plain">    ZLayer(loadConfig)  // or ZLayer.fromZIO(loadConfig)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This is the for-comprehension way of creating a ZIO service using <code>ZLayer.apply</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait A</span><br></span><span class="token-line"><span class="token plain">trait B</span><br></span><span class="token-line"><span class="token plain">trait C</span><br></span><span class="token-line"><span class="token plain">case class CLive(a: A, b: B) extends C</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object CLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[A &amp; B, Nothing, C] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        a &lt;- ZIO.service[A]</span><br></span><span class="token-line"><span class="token plain">        b &lt;- ZIO.service[B]</span><br></span><span class="token-line"><span class="token plain">      } yield CLive(a, b)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="from-functions">From Functions<a class="hash-link" href="#from-functions" title="Direct link to heading">​</a></h3><p>A <code>ZLayer[R, E, A]</code> can be thought of as a function from <code>R</code> to <code>A</code>. So we can convert functions to the <code>ZLayer</code> using the <code>ZLayer.fromFunction</code> constructor.</p><p>In the following example, the <code>CLive</code> implementation requires two <code>A</code> and <code>B</code> services, and we can easily convert that case class to a <code>ZLayer</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait A</span><br></span><span class="token-line"><span class="token plain">trait B</span><br></span><span class="token-line"><span class="token plain">trait C</span><br></span><span class="token-line"><span class="token plain">case class CLive(a: A, b: B) extends C</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object CLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[A &amp; B, Nothing, C] = </span><br></span><span class="token-line"><span class="token plain">    ZLayer.fromFunction(CLive.apply _)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Below is a complete working example:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  final case class DatabaseConfig()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object DatabaseConfig {</span><br></span><span class="token-line"><span class="token plain">    val live = ZLayer.succeed(DatabaseConfig())</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  final case class Database(databaseConfig: DatabaseConfig)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object Database {</span><br></span><span class="token-line"><span class="token plain">    val live: ZLayer[DatabaseConfig, Nothing, Database] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.fromFunction(Database.apply _)</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  final case class Analytics()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object Analytics {</span><br></span><span class="token-line"><span class="token plain">    val live: ULayer[Analytics] = ZLayer.succeed(Analytics())</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  final case class Users(database: Database, analytics: Analytics)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object Users {</span><br></span><span class="token-line"><span class="token plain">    val live = ZLayer.fromFunction(Users.apply _)</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  final case class App(users: Users, analytics: Analytics) {</span><br></span><span class="token-line"><span class="token plain">    def execute: UIO[Unit] =</span><br></span><span class="token-line"><span class="token plain">      ZIO.debug(s&quot;This app is made from ${users} and ${analytics}&quot;)</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object App {</span><br></span><span class="token-line"><span class="token plain">    val live = ZLayer.fromFunction(App.apply _)</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run =</span><br></span><span class="token-line"><span class="token plain">    ZIO</span><br></span><span class="token-line"><span class="token plain">      .serviceWithZIO[App](_.execute)</span><br></span><span class="token-line"><span class="token plain">      // Cannot use `provide` due to this dotty bug: https://github.com/lampepfl/dotty/issues/12498</span><br></span><span class="token-line"><span class="token plain">      .provideLayer(</span><br></span><span class="token-line"><span class="token plain">        (((DatabaseConfig.live &gt;&gt;&gt; Database.live) ++ Analytics.live &gt;&gt;&gt; Users.live) ++ Analytics.live) &gt;&gt;&gt; App.live</span><br></span><span class="token-line"><span class="token plain">      )</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="building-dependency-graph">Building Dependency Graph<a class="hash-link" href="#building-dependency-graph" title="Direct link to heading">​</a></h2><p>We have two options to build a dependency graph:</p><ol><li>Manual layer construction</li><li>Automatic layer construction</li></ol><p>The first method uses ZIO&#x27;s composition operators such as horizontal (<code>++</code>) and vertical (<code>&gt;&gt;&gt;</code>) compositions. The second one uses macro and automatically creates the dependency graph at compile time.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="manual-layer-construction">Manual Layer Construction<a class="hash-link" href="#manual-layer-construction" title="Direct link to heading">​</a></h2><p>We said that we can think of the <code>ZLayer</code> as a more powerful <em>constructor</em>. Constructors are not composable, because they are not values. While a constructor is not composable, <code>ZLayer</code> has a nice facility to compose with other <code>ZLayer</code>s. So we can say that a <code>ZLayer</code> turns a constructor into values.</p><blockquote><p><strong>Note</strong>:</p><p>In a regular ZIO application we are not required to build the dependency graph through composing layers tougher. Instead, we can provide all dependencies to the ZIO application using <code>ZIO#provide</code>, and the ZIO will create the dependency graph manually under the hood. Therefore, use manual layer composition if you know what you&#x27;re doing.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_mojV" id="vertical-and-horizontal-composition">Vertical and Horizontal Composition<a class="hash-link" href="#vertical-and-horizontal-composition" title="Direct link to heading">​</a></h3><p>Assume we have several services with their dependencies, and we need a way to compose and wire up these dependencies to create the dependency graph of our application. <code>ZLayer</code> is a ZIO solution for this problem, it allows us to build up the whole application dependency graph by composing layers horizontally and vertically.</p><ol><li><strong>Horizontal Composition</strong> — Layers can be composed together horizontally with the <code>++</code> operator. When we compose layers horizontally, the new layer requires all the services that both of them require and produces all services that both of them produce. Horizontal composition is a way of composing two layers side-by-side. It is useful when we combine two layers that don&#x27;t have any relationship with each other.</li></ol><p>We can compose <code>fooLayer</code> and <code>barLayer</code> <em>horizontally</em> to build a layer that has the requirements of both, to provide the capabilities of both, through <code>fooLayer ++ barLayer</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fooLayer: ZLayer[A, Throwable, B] = ???        // A ==&gt; B        // A ==&gt; B</span><br></span><span class="token-line"><span class="token plain">val barLayer: ZLayer[C, Nothing  , D] = ???        // C ==&gt; D        // C ==&gt; D</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val horizontal: ZLayer[A &amp; C, Throwable, B &amp; D] =  // A &amp; C ==&gt; B &amp; D</span><br></span><span class="token-line"><span class="token plain">  fooLayer ++ barLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="2"><li><p><strong>Vertical Composition</strong> — We can also compose layers <em>vertically</em> using the <code>&gt;&gt;&gt;</code> operator, meaning the output of one layer is used as input for the subsequent layer, resulting in one layer with the requirement of the first, and the output of the second.  </p><p>For example if we have a layer that requires <code>A</code> and produces <code>B</code>, we can compose this with another layer that requires <code>B</code> and produces <code>C</code>; this composition produces a layer that requires <code>A</code> and produces <code>C</code>. The feed operator, <code>&gt;&gt;&gt;</code>, stack them on top of each other by using vertical composition. This sort of composition is like <em>function composition</em>, feeding an output of one layer to an input of another:</p></li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fooLayer: ZLayer[A, Throwable, B] = ???  // A ==&gt; B  // A ==&gt; B</span><br></span><span class="token-line"><span class="token plain">val barLayer: ZLayer[B, Nothing  , C] = ???  // B ==&gt; C  // B ==&gt; C</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val horizontal: ZLayer[A, Throwable, C] =    // A ==&gt; C</span><br></span><span class="token-line"><span class="token plain">  fooLayer &gt;&gt;&gt; barLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="hidden-versus-passed-through-dependencies">Hidden Versus Passed-through Dependencies<a class="hash-link" href="#hidden-versus-passed-through-dependencies" title="Direct link to heading">​</a></h3><p>ZLayer has a <code>passthrough</code> operator which returns a new layer that produces the outputs of this layer but also passes-through the inputs:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fooLayer: ZLayer[A, Nothing, B] = ???  // A ==&gt; B  // A ==&gt; B</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val result1 : ZLayer[A, Nothing, A &amp; B] =  // A ==&gt; A &amp; B</span><br></span><span class="token-line"><span class="token plain">  fooLayer.passthrough</span><br></span><span class="token-line"><span class="token plain">  </span><br></span><span class="token-line"><span class="token plain">val result2 : ZLayer[A, Nothing, A &amp; B] =  // A ==&gt; A &amp; B</span><br></span><span class="token-line"><span class="token plain">  ZLayer.service[A] ++ fooLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>By default, the <code>ZLayer</code> hides intermediate dependencies when composing vertically. For example, when we compose <code>fooLayer</code> with <code>barLayer</code> vertically, the output would be a <code>ZLayer[A, Throwable, C]</code>. This hides the dependency on the <code>B</code> layer. By using the above technique, we can pass through hidden dependencies.</p><p>Let&#x27;s include the <code>B</code> service into the upstream dependencies of the final layer using the <code>ZIO.service[B]</code>. We can think of <code>ZIO.service[B]</code> as an <em>identity function</em> (<code>B ==&gt; B</code>).</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fooLayer: ZLayer[A, Throwable, B] = ???  // A  ==&gt; B  // A  ==&gt; B</span><br></span><span class="token-line"><span class="token plain">val barLayer: ZLayer[B, Throwable, C] = ???  // B  ==&gt; C  // B  ==&gt; C</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val finalLayer: ZLayer[A &amp; B, Throwable, C] = // A &amp; B ==&gt; C</span><br></span><span class="token-line"><span class="token plain">  (fooLayer ++ ZLayer.service[B]) &gt;&gt;&gt; barLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Or we may want to include the middle services in the output channel of the final layer, resulting in a new layer with the inputs of the first layer and the outputs of both layers:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fooLayer: ZLayer[A, Throwable, B] = ??? // A  ==&gt; B // A  ==&gt; B</span><br></span><span class="token-line"><span class="token plain">val barLayer: ZLayer[B, Throwable, C] = ??? // B  ==&gt; C // B  ==&gt; C</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val finalLayer: ZLayer[A, Throwable, B &amp; C] = // A ==&gt; B &amp; C</span><br></span><span class="token-line"><span class="token plain">  fooLayer &gt;&gt;&gt; (ZLayer.service[B] ++ barLayer)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We can do the same with the <code>&gt;+&gt;</code> operator:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fooLayer: ZLayer[A, Throwable, B] = ??? // A  ==&gt; B // A  ==&gt; B</span><br></span><span class="token-line"><span class="token plain">val barLayer: ZLayer[B, Throwable, C] = ??? // B  ==&gt; C // B  ==&gt; C</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val finalLayer: ZLayer[A, Throwable, B &amp; C] = // A ==&gt; B &amp; C</span><br></span><span class="token-line"><span class="token plain">  fooLayer &gt;+&gt; barLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This technique is useful when we want to defer the creation of some intermediate services and require them as part of the input of the final layer. For example, assume we have these two layers:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fooLayer: ZLayer[A    , Throwable, B] = ???   // A     ==&gt; B   // A     ==&gt; B</span><br></span><span class="token-line"><span class="token plain">val barLayer: ZLayer[B &amp; C, Throwable, D] = ???   // B &amp; C ==&gt; D   // B &amp; C ==&gt; D</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val finalLayer: ZLayer[A &amp; B &amp; C, Throwable, D] = // A &amp; B &amp; C ==&gt; B &amp; D</span><br></span><span class="token-line"><span class="token plain">  fooLayer &gt;&gt;&gt; barLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>So we can defer the creation of the <code>C</code> layer using <code>ZLayer.service[C]</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val fooLayer: ZLayer[A    , Throwable, B] = ??? // A ==&gt; B  // A ==&gt; B </span><br></span><span class="token-line"><span class="token plain">val barLayer: ZLayer[B &amp; C, Throwable, D] = ??? // B &amp; C ==&gt; D // B &amp; C ==&gt; D</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val layer: ZLayer[A &amp; C, Throwable, D] =        // A &amp; C ==&gt; D</span><br></span><span class="token-line"><span class="token plain">  (fooLayer ++ ZLayer.service[C]) &gt;&gt;&gt; barLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here is an example in which we passthrough all requirements to bake a <code>Cake</code> so all the requirements are available to all the downstream services: </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Baker </span><br></span><span class="token-line"><span class="token plain">trait Ingredients</span><br></span><span class="token-line"><span class="token plain">trait Oven</span><br></span><span class="token-line"><span class="token plain">trait Dough</span><br></span><span class="token-line"><span class="token plain">trait Cake</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">lazy val baker      : ZLayer[Any, Nothing, Baker] = ???</span><br></span><span class="token-line"><span class="token plain">lazy val ingredients: ZLayer[Any, Nothing, Ingredients] = ???</span><br></span><span class="token-line"><span class="token plain">lazy val oven       : ZLayer[Any, Nothing, Oven] = ???</span><br></span><span class="token-line"><span class="token plain">lazy val dough      : ZLayer[Baker &amp; Ingredients, Nothing, Dough] = ???</span><br></span><span class="token-line"><span class="token plain">lazy val cake       : ZLayer[Baker &amp; Oven &amp; Dough, Nothing, Cake] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">lazy val all: ZLayer[Any, Nothing, Baker &amp; Ingredients &amp; Oven &amp; Dough &amp; Cake] =</span><br></span><span class="token-line"><span class="token plain">  baker &gt;+&gt;       // Baker</span><br></span><span class="token-line"><span class="token plain">  ingredients &gt;+&gt; // Baker &amp; Ingredients</span><br></span><span class="token-line"><span class="token plain">  oven &gt;+&gt;        // Baker &amp; Ingredients &amp; Oven</span><br></span><span class="token-line"><span class="token plain">  dough &gt;+&gt;       // Baker &amp; Ingredients &amp; Oven &amp; Dough</span><br></span><span class="token-line"><span class="token plain">  cake            // Baker &amp; Ingredients &amp; Oven &amp; Dough &amp; Cake</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This allows a style of composition where the <code>&gt;+&gt;</code> operator is used to build a progressively larger set of services, with each new service able to depend on all the services before it. If we passthrough dependencies and later want to hide them we can do so through a simple type ascription:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">lazy val hidden: ZLayer[Any, Nothing, Cake] = all</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The <code>ZLayer</code> makes it easy to mix and match these styles. If we build our dependency graph more explicitly, we can be confident that dependencies used in multiple parts of the dependency graph will only be created once due to memoization and sharing.</p><p>Using these simple operators we can build complex dependency graphs.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="updating-local-dependencies">Updating Local Dependencies<a class="hash-link" href="#updating-local-dependencies" title="Direct link to heading">​</a></h3><p>Given a layer, it is possible to update one or more components it provides. We update a dependency in two ways:</p><ol><li><strong>Using the <code>update</code> Method</strong> — This method allows us to replace one requirement with a different implementation:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val origin: ZLayer[Any, Nothing, String &amp; Int &amp; Double] = </span><br></span><span class="token-line"><span class="token plain">  ZLayer.succeedEnvironment(ZEnvironment[String, Int, Double](&quot;foo&quot;, 123, 1.3))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val updated1 = origin.update[String](_ + &quot;bar&quot;)</span><br></span><span class="token-line"><span class="token plain">val updated2 = origin.update[Int](_ + 5)</span><br></span><span class="token-line"><span class="token plain">val updated3 = origin.update[Double](_ - 0.3)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here is an example of updating a config layer:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">import java.io.IOException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class AppConfig(poolSize: Int)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[AppConfig, IOException, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      config &lt;- ZIO.service[AppConfig]</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- Console.printLine(s&quot;Application config after the update operation: $config&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val appLayers: ZLayer[Any, Nothing, AppConfig] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer(ZIO.succeed(AppConfig(5)).debug(&quot;Application config initialized&quot;)) ++</span><br></span><span class="token-line"><span class="token plain">      Console.live</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val updatedConfig: ZLayer[Any, Nothing, AppConfig] =</span><br></span><span class="token-line"><span class="token plain">    appLayers.update[AppConfig](c =&gt;</span><br></span><span class="token-line"><span class="token plain">      c.copy(poolSize = c.poolSize + 10)</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(updatedConfig)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="2"><li><strong>Using Horizontal Composition</strong> — Another way to update a requirement is to horizontally compose in a layer that provides the updated service. The resulting composition will replace the old layer with the new one:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val origin: ZLayer[Any, Nothing, String &amp; Int &amp; Double] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer.succeedEnvironment(ZEnvironment[String, Int, Double](&quot;foo&quot;, 123, 1.3))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val updated = origin ++ ZLayer.succeed(321)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Let&#x27;s see an example of updating a config layer:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">import java.io.IOException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class AppConfig(poolSize: Int)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[AppConfig, IOException, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      config &lt;- ZIO.service[AppConfig]</span><br></span><span class="token-line"><span class="token plain">      _      &lt;- Console.printLine(s&quot;Application config after the update operation: $config&quot;)</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val appLayers: ZLayer[Any, Nothing, AppConfig] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer(ZIO.succeed(AppConfig(5)).debug(&quot;Application config initialized&quot;)) ++</span><br></span><span class="token-line"><span class="token plain">      Console.live</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val updatedConfig: ZLayer[Any, Nothing, AppConfig] =</span><br></span><span class="token-line"><span class="token plain">    appLayers ++ ZLayer.succeed(AppConfig(8))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(updatedConfig)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="cyclic-dependencies">Cyclic Dependencies<a class="hash-link" href="#cyclic-dependencies" title="Direct link to heading">​</a></h3><p>The <code>ZLayer</code> mechanism makes it impossible to build cyclic dependencies, making the initialization process very linear, by construction.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="automatic-layer-construction">Automatic Layer Construction<a class="hash-link" href="#automatic-layer-construction" title="Direct link to heading">​</a></h2><p>ZIO also has an automatic layer construction facility, which takes care of building dependency graphs from the individual layers and building blocks. So instead of manually composing layers together to build the final layer, we can only provide individual layers to the ZIO application, and it will do the rest.</p><p>The automatic layer construction takes place at the <em>compile-time</em>, so if there is a problem in providing a layer, we will receive an error or warning message. So it helps us to diagnose the problem. Additionally, it has a way to print the dependency graph using built-in debug layers.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="providing-individual-layers-to-a-zio-application">Providing Individual Layers to a ZIO Application<a class="hash-link" href="#providing-individual-layers-to-a-zio-application" title="Direct link to heading">​</a></h3><p>When we provide individual layers using <code>ZIO#provide</code>, <code>ZIO#provideCustom</code>, or <code>ZIO#provideSome</code> to a ZIO application, the compiler will create the dependency graph automatically from the provided layers:</p><blockquote><p><strong>Note:</strong></p><p>We have a <a href="#dependency-propagation">separate section</a> that describes different methods for providing layers to the ZIO application.</p></blockquote><p>Assume we have written the following services (<code>Cake</code>, <code>Chocolate</code>, <code>Flour</code>, and <code>Spoon</code>):</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Cake</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Cake {</span><br></span><span class="token-line"><span class="token plain">  val live: ZLayer[Chocolate &amp; Flour, Nothing, Cake] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZLayer.environment[Chocolate &amp; Flour]</span><br></span><span class="token-line"><span class="token plain">      cake &lt;- ZLayer.succeed(new Cake {})</span><br></span><span class="token-line"><span class="token plain">    } yield cake</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Spoon</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Spoon {</span><br></span><span class="token-line"><span class="token plain">  val live: ULayer[Spoon] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer.succeed(new Spoon {})</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Chocolate</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Chocolate {</span><br></span><span class="token-line"><span class="token plain">  val live: ZLayer[Spoon, Nothing, Chocolate] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer.service[Spoon].project(_ =&gt; new Chocolate {})</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Flour</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Flour {</span><br></span><span class="token-line"><span class="token plain">  val live: ZLayer[Spoon, Nothing, Flour] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer.service[Spoon].project(_ =&gt; new Flour {})</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The <code>Cake</code> service has the following dependency graph:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">          Cake</span><br></span><span class="token-line"><span class="token plain">          /   \</span><br></span><span class="token-line"><span class="token plain">   Chocolate   Flour</span><br></span><span class="token-line"><span class="token plain">       |         |</span><br></span><span class="token-line"><span class="token plain">     Spoon     Spoon</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Now we can write an application that uses the <code>Cake</code> service as below:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">import java.io.IOException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val myApp: ZIO[Cake, IOException, Unit] = for {</span><br></span><span class="token-line"><span class="token plain">  cake &lt;- ZIO.service[Cake]</span><br></span><span class="token-line"><span class="token plain">  _    &lt;- Console.printLine(s&quot;Yay! I baked a cake with flour and chocolate: $cake&quot;)</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The type of <code>myApp</code> indicates we should provide <code>Console</code> and <code>Cake</code> to this ZIO application to run it. Let&#x27;s give it those and see what happens:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  def run =</span><br></span><span class="token-line"><span class="token plain">    myApp.provide(</span><br></span><span class="token-line"><span class="token plain">      Cake.live,</span><br></span><span class="token-line"><span class="token plain">      Console.live</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// error:</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// ──── ZLAYER ERROR ────────────────────────────────────────────────────</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">//  Please provide layers for the following 2 types:</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">//    Required by Cake.live</span><br></span><span class="token-line"><span class="token plain">//    1. Chocolate</span><br></span><span class="token-line"><span class="token plain">//    2. Flour</span><br></span><span class="token-line"><span class="token plain">//    </span><br></span><span class="token-line"><span class="token plain">// ──────────────────────────────────────────────────────────────────────</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here are the errors that will be printed:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">──── ZLAYER ERROR ────────────────────────────────────────────────────</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain"> Please provide layers for the following 2 types:</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">   Required by Cake.live</span><br></span><span class="token-line"><span class="token plain">   1. Chocolate</span><br></span><span class="token-line"><span class="token plain">   2. Flour</span><br></span><span class="token-line"><span class="token plain">   </span><br></span><span class="token-line"><span class="token plain">──────────────────────────────────────────────────────────────────────</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>It says that we missed providing <code>Chocolate</code> and <code>Flour</code> layers. Now let&#x27;s add these two missing layers:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  def run =</span><br></span><span class="token-line"><span class="token plain">    myApp.provide(</span><br></span><span class="token-line"><span class="token plain">      Cake.live,</span><br></span><span class="token-line"><span class="token plain">      Console.live,</span><br></span><span class="token-line"><span class="token plain">      Chocolate.live,</span><br></span><span class="token-line"><span class="token plain">      Flour.live</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// error:</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// ──── ZLAYER ERROR ────────────────────────────────────────────────────</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// Please provide a layer for the following type:</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// Required by Flour.live</span><br></span><span class="token-line"><span class="token plain">// 1. Spoon</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// Required by Chocolate.live</span><br></span><span class="token-line"><span class="token plain">// 1. Spoon</span><br></span><span class="token-line"><span class="token plain">// </span><br></span><span class="token-line"><span class="token plain">// ──────────────────────────────────────────────────────────────────────</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Again, the compiler asks us to provide another dependency called <code>Spoon</code>:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">──── ZLAYER ERROR ────────────────────────────────────────────────────</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">Please provide a layer for the following type:</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">Required by Flour.live</span><br></span><span class="token-line"><span class="token plain">1. Spoon</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">Required by Chocolate.live</span><br></span><span class="token-line"><span class="token plain">1. Spoon</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">──────────────────────────────────────────────────────────────────────</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Finally, our application compiles without any errors: </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  def run =</span><br></span><span class="token-line"><span class="token plain">    myApp.provide(</span><br></span><span class="token-line"><span class="token plain">      Cake.live,</span><br></span><span class="token-line"><span class="token plain">      Chocolate.live,</span><br></span><span class="token-line"><span class="token plain">      Flour.live,</span><br></span><span class="token-line"><span class="token plain">      Spoon.live  </span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Note that the order of dependencies doesn&#x27;t matter. We can provide them in any order.</p><p>Now, let&#x27;s compare the automatic layer construction with the manual one:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val layers: ULayer[Cake] =</span><br></span><span class="token-line"><span class="token plain">      (((Spoon.live &gt;&gt;&gt; Chocolate.live) ++ (Spoon.live &gt;&gt;&gt; Flour.live)) &gt;&gt;&gt; Cake.live)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provideLayer(layers)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="automatically-assembling-layers">Automatically Assembling Layers<a class="hash-link" href="#automatically-assembling-layers" title="Direct link to heading">​</a></h3><ol><li><strong>ZLayer.make<!-- -->[R]</strong> — Using <code>ZLayer.make[R]</code>, we can provide a type <code>R</code> and then provide individual layers as arguments, it will automatically assemble these layers to create a layer of type <code>R</code>.</li></ol><p>For example, we can create a <code>Cake</code> layer as below:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val cakeLayer: ZLayer[Any, Nothing, Cake] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer.make[Cake](</span><br></span><span class="token-line"><span class="token plain">    Cake.live,</span><br></span><span class="token-line"><span class="token plain">    Chocolate.live,</span><br></span><span class="token-line"><span class="token plain">    Flour.live,</span><br></span><span class="token-line"><span class="token plain">    Spoon.live</span><br></span><span class="token-line"><span class="token plain">  )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We can also create a layer for intersections of services:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val chocolateAndFlourLayer: ZLayer[Any, Nothing, Chocolate &amp; Flour] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer.make[Chocolate &amp; Flour](</span><br></span><span class="token-line"><span class="token plain">    Chocolate.live,</span><br></span><span class="token-line"><span class="token plain">    Flour.live,</span><br></span><span class="token-line"><span class="token plain">    Spoon.live</span><br></span><span class="token-line"><span class="token plain">  )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol start="2"><li><strong>ZLayer.makeSome<!-- -->[R0, R]</strong> — Automatically constructs a layer for the provided type <code>R</code>, leaving a remainder <code>R0</code>:</li></ol><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val cakeLayer: ZLayer[Spoon, Nothing, Cake] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer.makeSome[Spoon, Cake](</span><br></span><span class="token-line"><span class="token plain">    Cake.live,</span><br></span><span class="token-line"><span class="token plain">    Chocolate.live,</span><br></span><span class="token-line"><span class="token plain">    Flour.live</span><br></span><span class="token-line"><span class="token plain">  )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="zlayer-debugging">ZLayer Debugging<a class="hash-link" href="#zlayer-debugging" title="Direct link to heading">​</a></h3><p>To debug ZLayer construction, we have two built-in layers, i.e., <code>ZLayer.Debug.tree</code> and <code>ZLayer.Debug.mermaid</code>. </p><p>Let&#x27;s include the <code>ZLayer.Debug.tree</code> layer into the layer construction:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  def run =</span><br></span><span class="token-line"><span class="token plain">    myApp.provide(</span><br></span><span class="token-line"><span class="token plain">      Cake.live,</span><br></span><span class="token-line"><span class="token plain">      Chocolate.live,</span><br></span><span class="token-line"><span class="token plain">      Flour.live,</span><br></span><span class="token-line"><span class="token plain">      Spoon.live,</span><br></span><span class="token-line"><span class="token plain">      ZLayer.Debug.tree</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The following debug messages will be generated by the compiler:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">[info]   ZLayer Wiring Graph</span><br></span><span class="token-line"><span class="token plain">[info]</span><br></span><span class="token-line"><span class="token plain">[info] ◉ Cake.live</span><br></span><span class="token-line"><span class="token plain">[info] ├─◑ Chocolate.live</span><br></span><span class="token-line"><span class="token plain">[info] │ ╰─◑ Spoon.live</span><br></span><span class="token-line"><span class="token plain">[info] ╰─◑ Flour.live</span><br></span><span class="token-line"><span class="token plain">[info]   ╰─◑ Spoon.live</span><br></span><span class="token-line"><span class="token plain">[info] </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>If we use the <code>ZLayer.Debug.mermaid</code> layer, it will generate the following debug messages:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">[info]   ZLayer Wiring Graph  </span><br></span><span class="token-line"><span class="token plain">[info] </span><br></span><span class="token-line"><span class="token plain">[info] ◉ Cake.live</span><br></span><span class="token-line"><span class="token plain">[info] ├─◑ Chocolate.live</span><br></span><span class="token-line"><span class="token plain">[info] │ ╰─◑ Spoon.live</span><br></span><span class="token-line"><span class="token plain">[info] ╰─◑ Flour.live</span><br></span><span class="token-line"><span class="token plain">[info]   ╰─◑ Spoon.live</span><br></span><span class="token-line"><span class="token plain">[info] </span><br></span><span class="token-line"><span class="token plain">[info] Mermaid Live Editor Link</span><br></span><span class="token-line"><span class="token plain">[info] https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZ3JhcGhcbiAgICBDb25zb2xlLmxpdmVcbiAgICBDYWtlLmxpdmUgLS0+IENob2NvbGF0ZS5saXZlXG4gICAgQ2FrZS5saXZlIC0tPiBGbG91ci5saXZlXG4gICAgRmxvdXIubGl2ZSAtLT4gU3Bvb24ubGl2ZVxuICAgIFNwb29uLmxpdmVcbiAgICBDaG9jb2xhdGUubGl2ZSAtLT4gU3Bvb24ubGl2ZVxuICAgICIsIm1lcm1haWQiOiAie1xuICBcInRoZW1lXCI6IFwiZGVmYXVsdFwiXG59IiwgInVwZGF0ZUVkaXRvciI6IHRydWUsICJhdXRvU3luYyI6IHRydWUsICJ1cGRhdGVEaWFncmFtIjogdHJ1ZX0=</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="dependency-propagation">Dependency Propagation<a class="hash-link" href="#dependency-propagation" title="Direct link to heading">​</a></h2><p>When we write an application, our application has a lot of dependencies. We need a way to provide implementations and to feed and propagate all dependencies throughout the whole application. We can solve the propagation problem by using <em>ZIO environment</em>.</p><p>During the development of an application, we don&#x27;t care about implementations. Incrementally, when we use various effects with different requirements on their environment, all parts of our application compose together, and at the end of the day we have a ZIO effect which requires some services as an environment. Before running this effect by <code>unsafeRun</code> we should provide an implementation of these services into the ZIO Environment of that effect.</p><p>ZIO has some facilities for doing this. <code>ZIO#provide</code> is the core function that allows us to <em>feed</em> an <code>R</code> to an effect that requires an <code>R</code>.</p><p>Notice that the act of <code>provide</code>ing an effect with its environment, eliminates the environment dependency in the resulting effect type, represented by type <code>Any</code> of the resulting environment.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="using-zioprovideenvironment-method">Using <code>ZIO#provideEnvironment</code> Method<a class="hash-link" href="#using-zioprovideenvironment-method" title="Direct link to heading">​</a></h4><p>The <code>ZIO#provideEnvironment</code> takes an instance of <code>ZEnvironment[R]</code> and provides it to the <code>ZIO</code> effect which eliminates its dependency on <code>R</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait ZIO[-R, +E, +A] {</span><br></span><span class="token-line"><span class="token plain">  def provideEnvironment(r: =&gt; ZEnvironment[R]): IO[E, A]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This is similar to dependency injection, and the <code>provide*</code> function can be thought of as <em>inject</em>.</p><p>Assume we have the following services:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(str: String): UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(line: String) = ZIO.serviceWithZIO[Logging](_.log(line))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Let&#x27;s write a simple program using <code>Logging</code> service:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val app: ZIO[Logging, Nothing, Unit] = Logging.log(&quot;Application Started!&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We can <code>provide</code> implementation of <code>Logging</code> service into the <code>app</code> effect:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val loggingImpl = new Logging {</span><br></span><span class="token-line"><span class="token plain">  override def log(line: String): UIO[Unit] =</span><br></span><span class="token-line"><span class="token plain">    UIO.succeed(println(line))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val effect = app.provideEnvironment(ZEnvironment(loggingImpl))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Most of the time, we don&#x27;t use <code>ZIO#provideEnvironment</code> directly to provide our services; instead, we use <code>ZLayer</code> to construct the dependency graph of our application, then we use methods like <code>ZIO#provide</code>, <code>ZIO#provideSome</code> and <code>ZIO#provideCustom</code> to propagate dependencies into the environment of our ZIO effect.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="using-zioprovide-method">Using <code>ZIO#provide</code> Method<a class="hash-link" href="#using-zioprovide-method" title="Direct link to heading">​</a></h4><p>Unlike the <code>ZIO#provideEnvironment</code> which takes a <code>ZEnvironment[R]</code>, the <code>ZIO#provide</code> takes a <code>ZLayer</code> to the ZIO effect and translates it to another level.</p><p>Assume we have written this piece of program that requires <code>Clock</code> and <code>Console</code> services:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio.Clock._</span><br></span><span class="token-line"><span class="token plain">import zio.Console._</span><br></span><span class="token-line"><span class="token plain">import zio.Random._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val myApp: ZIO[Any, Nothing, Unit] = for {</span><br></span><span class="token-line"><span class="token plain">  random  &lt;- nextInt </span><br></span><span class="token-line"><span class="token plain">  _       &lt;- printLine(s&quot;A random number: $random&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">  current &lt;- currentDateTime</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- printLine(s&quot;Current Data Time: $current&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We provide implementations of <code>Random</code>, <code>Console</code> and <code>Clock</code> services to the <code>myApp</code> effect by using <code>ZIO#provide</code> method:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val mainEffect: ZIO[Any, Nothing, Unit] = </span><br></span><span class="token-line"><span class="token plain">  myApp</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As we see, the type of our effect converted from <code>ZIO[Random &amp; Console &amp; Clock, Nothing, Unit]</code> which requires three services to <code>ZIO[Any, Nothing, Unit]</code> effect which doesn&#x27;t require any services.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="using-zioprovidesome-method">Using <code>ZIO#provideSome</code> Method<a class="hash-link" href="#using-zioprovidesome-method" title="Direct link to heading">​</a></h4><p>Sometimes we have written a program, and we don&#x27;t want to provide all its requirements. In these cases, we can use <code>ZIO#provideSome</code> to partially apply some layers to the <code>ZIO</code> effect.</p><p>In the previous example, if we just want to provide the <code>Console</code>, we should use <code>ZIO#provideSome</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val mainEffectSome: ZIO[Any, Nothing, Unit] = </span><br></span><span class="token-line"><span class="token plain">  myApp</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p><strong>Note:</strong></p><p>When using <code>ZIO#provideSome[R0]</code>, we should provide the remaining type as <code>R0</code> type parameter. This workaround helps the compiler to infer the proper types.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_mojV" id="using-zioprovidecustom-method">Using <code>ZIO#provideCustom</code> Method<a class="hash-link" href="#using-zioprovidecustom-method" title="Direct link to heading">​</a></h4><p><code>ZEnv</code> is a convenient type alias that provides several built-in ZIO services that are useful in most applications. Sometimes we have written a program that contains ZIO built-in services and some other services that are not part of <code>ZEnv</code>.</p><p>As <code>ZEnv</code> provides us the implementation of built-in services, we just need to provide layers for those services that are not part of the <code>ZEnv</code>. The <code>ZIO#provideCustom</code> method helps us to do so. It returns an effect that only depends on <code>ZEnv</code>.</p><p>Let&#x27;s write an effect that has some built-in services and also has a <code>Logging</code> service:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">trait Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(str: String): UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Logging {</span><br></span><span class="token-line"><span class="token plain">  def log(line: String) = ZIO.serviceWithZIO[Logging](_.log(line))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object LoggingLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: ULayer[Logging] = ZLayer.succeed {</span><br></span><span class="token-line"><span class="token plain">    new Logging {</span><br></span><span class="token-line"><span class="token plain">      override def log(str: String): UIO[Unit] = ???</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val myApp: ZIO[Logging, Nothing, Unit] = for {</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- Logging.log(&quot;Application Started!&quot;)</span><br></span><span class="token-line"><span class="token plain">  current &lt;- Clock.currentDateTime</span><br></span><span class="token-line"><span class="token plain">  _       &lt;- Console.printLine(s&quot;Current Data Time: $current&quot;).orDie</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This program uses two ZIO built-in services, <code>Console</code> and <code>Clock</code>. We don&#x27;t need to provide <code>Console</code> and <code>Clock</code> manually, to reduce some boilerplate, we use <code>ZEnv</code> to satisfy some common base requirements.</p><p>By using <code>ZIO#provideCustom</code> we only provide the <code>Logging</code> layer, and it returns a <code>ZIO</code> effect which only requires <code>ZEnv</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">val mainEffect: ZIO[ZEnv, Nothing, Unit] = myApp.provide(LoggingLive.layer)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="environment-scope">Environment Scope<a class="hash-link" href="#environment-scope" title="Direct link to heading">​</a></h2><p>We can create a ZIO application by providing a local or a global environment, or a combination:</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="global-environment">Global Environment<a class="hash-link" href="#global-environment" title="Direct link to heading">​</a></h3><p>It is usual when writing ZIO applications to provide layers at the end of the world. Then we provide layers to the whole ZIO application all at once. This pattern uses a single global environment for all ZIO applications:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[ServiceA &amp; ServiceB &amp; ServiceC &amp; ServiceD, Throwable, Unit] = ???</span><br></span><span class="token-line"><span class="token plain">    </span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(a, b, c, d)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="local-environment">Local Environment<a class="hash-link" href="#local-environment" title="Direct link to heading">​</a></h3><p>Occasionally, we may need to provide different environments for different parts of our application, or it may be necessary to provide a single global environment for the entire application except for some inner layers. </p><p>Providing a layer locally is analogous to overriding a method in an object-oriented paradigm. So we can think of that as overriding the global environment:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain">  def myApp: ZIO[A &amp; B &amp; C, Throwable, Unit] = {</span><br></span><span class="token-line"><span class="token plain">    def innerApp1: ZIO[A &amp; B &amp; C, Throwable, Unit] = ???</span><br></span><span class="token-line"><span class="token plain">    def innerApp2: ZIO[A &amp; C,     Throwable, Unit] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    innerApp1.provideSomeLayer[A &amp; B](localC) *&gt; innerApp2</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(globalA, globalB, globalC)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>ZIO Test&#x27;s <a href="/next/datatypes/test/environment/live">Live service</a> uses this pattern to provide real environment to a single part of an effect.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="layer-memoization">Layer Memoization<a class="hash-link" href="#layer-memoization" title="Direct link to heading">​</a></h2><p>Layer memoization allows a layer to be created once and used multiple times in the dependency graph. So if we use the same layer twice, e.g. <code>(a &gt;&gt;&gt; b) ++ (a &gt;&gt;&gt; c)</code>, then the <code>a</code> layer will be allocated only once.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="layers-are-memoized-by-default-when-providing-globally">Layers are Memoized by Default when Providing Globally<a class="hash-link" href="#layers-are-memoized-by-default-when-providing-globally" title="Direct link to heading">​</a></h3><p>One important feature of a ZIO application is that layers are shared by default, meaning that if the same layer is used twice, and if we provide the layer <a href="#global-environment">globally</a> the layer will only be allocated a single time. For every layer in our dependency graph, there is only one instance of it that is shared between all the layers that depend on it.</p><p>For example, assume we have the three <code>A</code>, <code>B</code>, and <code>C</code> services. The implementation of both <code>B</code> and <code>C</code> are dependent on the <code>A</code> service:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait A</span><br></span><span class="token-line"><span class="token plain">trait B</span><br></span><span class="token-line"><span class="token plain">trait C</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class BLive(a: A) extends B</span><br></span><span class="token-line"><span class="token plain">case class CLive(a: A) extends C</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val a: ZLayer[Any, Nothing, A] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer(ZIO.succeed(new A {}).debug(&quot;initialized&quot;))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val b: ZLayer[A, Nothing, B] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer {</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      a &lt;- ZIO.service[A]</span><br></span><span class="token-line"><span class="token plain">    } yield BLive(a)</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val c: ZLayer[A, Nothing, C] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer {</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      a &lt;- ZIO.service[A]</span><br></span><span class="token-line"><span class="token plain">    } yield CLive(a)</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Although both <code>b</code> and <code>c</code> layers require the <code>a</code> layer, the <code>a</code> layer is instantiated only once. It is shared with both <code>b</code> and <code>c</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[B &amp; C, Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.service[B]</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.service[C]</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain">    </span><br></span><span class="token-line"><span class="token plain">  // alternative: myApp.provideLayer((a &gt;&gt;&gt; b) ++ (a &gt;&gt;&gt; c))</span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provide(a, b, c) </span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="acquiring-a-fresh-version">Acquiring a Fresh Version<a class="hash-link" href="#acquiring-a-fresh-version" title="Direct link to heading">​</a></h4><p>If we don&#x27;t want to share a module, we should create a fresh, non-shared version of it through <code>ZLayer#fresh</code>.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[B &amp; C, Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.service[B]</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.service[C]</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provideLayer((a.fresh &gt;&gt;&gt; b) ++ (a.fresh &gt;&gt;&gt; c))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="layers-are-not-memoized-when-providing-locally">Layers are not Memoized When Providing Locally<a class="hash-link" href="#layers-are-not-memoized-when-providing-locally" title="Direct link to heading">​</a></h3><p>If we don&#x27;t provide a layer globally but instead provide them <a href="#local-environment">locally</a>, that layer doesn&#x27;t support memoization by default.</p><p>In the following example, we provided the <code>A</code> layer two times locally and the ZIO doesn&#x27;t memoize the construction of the <code>A</code> layer. So, it will be initialized two times:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[Any, Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.service[A].provide(a) // providing locally</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.service[A].provide(a) // providing locally</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="manual-memoization">Manual Memoization<a class="hash-link" href="#manual-memoization" title="Direct link to heading">​</a></h4><p>We can memoize the <code>A</code> layer manually using the <code>ZLayer#memoize</code> operator. It will return a scoped effect that, if evaluated, will return the lazily computed result of this layer:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val myApp: ZIO[Any, Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.scoped {</span><br></span><span class="token-line"><span class="token plain">      a.memoize.flatMap { aLayer =&gt;</span><br></span><span class="token-line"><span class="token plain">        for {</span><br></span><span class="token-line"><span class="token plain">          _ &lt;- ZIO.service[A].provide(aLayer)</span><br></span><span class="token-line"><span class="token plain">          _ &lt;- ZIO.service[A].provide(aLayer)</span><br></span><span class="token-line"><span class="token plain">        } yield ()</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">    </span><br></span><span class="token-line"><span class="token plain">  def run = myApp</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="other-operators">Other Operators<a class="hash-link" href="#other-operators" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="converting-a-layer-to-a-scoped-value">Converting a Layer to a Scoped Value<a class="hash-link" href="#converting-a-layer-to-a-scoped-value" title="Direct link to heading">​</a></h3><p>Every <code>ZLayer</code> can be converted to a scoped <code>ZIO</code> by using <code>ZLayer.build</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Database {</span><br></span><span class="token-line"><span class="token plain">  def close: UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Database {</span><br></span><span class="token-line"><span class="token plain">  def connect: ZIO[Any, Throwable, Database] = ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val database: ZLayer[Any, Throwable, Database] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer.scoped {</span><br></span><span class="token-line"><span class="token plain">    ZIO.acquireRelease {</span><br></span><span class="token-line"><span class="token plain">      Database.connect.debug(&quot;connecting to the database&quot;)</span><br></span><span class="token-line"><span class="token plain">    } { database =&gt;</span><br></span><span class="token-line"><span class="token plain">      database.close</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val scopedDatabase: ZIO[Scope, Throwable, ZEnvironment[Database]] =</span><br></span><span class="token-line"><span class="token plain">  database.build</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="falling-back-to-an-alternate-layer">Falling Back to an Alternate Layer<a class="hash-link" href="#falling-back-to-an-alternate-layer" title="Direct link to heading">​</a></h3><p>If a layer fails, we can provide an alternative layer by using <code>ZLayer#orElse</code> so it will fall back to the second layer:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Database</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val postgresDatabaseLayer: ZLayer[Any, Throwable, Database] = ???</span><br></span><span class="token-line"><span class="token plain">val inmemoryDatabaseLayer: ZLayer[Any, Throwable, Database] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val databaseLayer: ZLayer[Any, Throwable, Database] =</span><br></span><span class="token-line"><span class="token plain">  postgresDatabaseLayer.orElse(inmemoryDatabaseLayer)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="converting-a-layer-to-a-zio-application">Converting a Layer to a ZIO Application<a class="hash-link" href="#converting-a-layer-to-a-zio-application" title="Direct link to heading">​</a></h3><p>Sometimes our entire application is a ZIO Layer, e.g. an HTTP Server, so by calling the <code>ZLayer#launch</code> we can convert that to a ZIO application. This will build the layer and use it until it is interrupted.</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val httpServer: ZLayer[Any, Nothing, HttpServer] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer.make[HttpServer](</span><br></span><span class="token-line"><span class="token plain">      JsonParserLive.layer,</span><br></span><span class="token-line"><span class="token plain">      TemplateEngineLive.layer </span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = httpServer.launch</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="retrying">Retrying<a class="hash-link" href="#retrying" title="Direct link to heading">​</a></h3><p>We can retry constructing a layer in case of failure:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val databaseLayer: ZLayer[Any, Throwable, DatabaseConnection]   = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val retriedLayer : ZLayer[Clock, Throwable, DatabaseConnection] = databaseLayer.retry(Schedule.fibonacci(1.second))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="layer-projection">Layer Projection<a class="hash-link" href="#layer-projection" title="Direct link to heading">​</a></h3><p>We can project out a part of <code>ZLayer</code> by providing a projection function to the <code>ZLayer#project</code> method:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class Connection(host: String, port: Int)  </span><br></span><span class="token-line"><span class="token plain">case class Login(user: String, password: String)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class DBConfig(</span><br></span><span class="token-line"><span class="token plain">  connection: Connection, </span><br></span><span class="token-line"><span class="token plain">  login: Login</span><br></span><span class="token-line"><span class="token plain">)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val connection: ZLayer[DBConfig, Nothing, Connection] = </span><br></span><span class="token-line"><span class="token plain">  ZLayer.service[DBConfig].project(_.connection)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="tapping">Tapping<a class="hash-link" href="#tapping" title="Direct link to heading">​</a></h3><p>We can perform a specified effect based on the success or failure result of the layer using <code>ZLayer#tap</code>/<code>ZLayer#tapError</code>. This would not change the layer&#x27;s signature:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class AppConfig(host: String, port: Int)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val config: ZLayer[Any, Throwable, AppConfig] =</span><br></span><span class="token-line"><span class="token plain">  ZLayer.fromZIO(</span><br></span><span class="token-line"><span class="token plain">    ZIO.attempt(???) // reading config from a file</span><br></span><span class="token-line"><span class="token plain">  )</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val res: ZLayer[Any, Throwable, AppConfig] =</span><br></span><span class="token-line"><span class="token plain">  config</span><br></span><span class="token-line"><span class="token plain">    .tap(cnf =&gt; ZIO.debug(s&quot;layer acquisition succeeded with $cnf&quot;))</span><br></span><span class="token-line"><span class="token plain">    .tapError(err =&gt; ZIO.debug(s&quot;error occurred during reading the config $err&quot;))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="examples">Examples<a class="hash-link" href="#examples" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="an-example-of-a-zio-application-with-a-simple-dependency">An Example of a ZIO Application with a Simple Dependency<a class="hash-link" href="#an-example-of-a-zio-application-with-a-simple-dependency" title="Direct link to heading">​</a></h3><p>This application demonstrates a ZIO program with a single dependency on a simple <code>AppConfig</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class AppConfig(poolSize: Int)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  // Define our simple ZIO program</span><br></span><span class="token-line"><span class="token plain">  val zio: ZIO[AppConfig, Nothing, Unit] = </span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      config &lt;- ZIO.service[AppConfig]</span><br></span><span class="token-line"><span class="token plain">      _      &lt;- ZIO.succeed(println(s&quot;Application started with config: $config&quot;))</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  // Create a ZLayer that produces an AppConfig and can be used to satisfy the AppConfig </span><br></span><span class="token-line"><span class="token plain">  // dependency that the program has</span><br></span><span class="token-line"><span class="token plain">  val defaultConfig: ULayer[AppConfig] = ZLayer.succeed(AppConfig(10))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  // Run the program, providing the `defaultConfig`</span><br></span><span class="token-line"><span class="token plain">  def run = zio.provide(defaultConfig)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="an-example-of-a-zio-application-with-multiple-dependencies">An Example of a ZIO Application with Multiple Dependencies<a class="hash-link" href="#an-example-of-a-zio-application-with-multiple-dependencies" title="Direct link to heading">​</a></h3><p>In the following example, our ZIO application has several dependencies:</p><ul><li><code>zio.Clock</code></li><li><code>zio.Console</code></li><li><code>B</code></li></ul><p>And also the <code>B</code> service depends upon the <code>A</code> service:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">import java.io.IOException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait A {</span><br></span><span class="token-line"><span class="token plain">  def letsGoA(v: Int): UIO[String]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object A {</span><br></span><span class="token-line"><span class="token plain">  def letsGoA(v: Int): URIO[A, String] = ZIO.serviceWithZIO(_.letsGoA(v))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class ALive() extends A {</span><br></span><span class="token-line"><span class="token plain">  override def letsGoA(v: Int): UIO[String] = ZIO.succeed(s&quot;done: v = $v &quot;)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object ALive {</span><br></span><span class="token-line"><span class="token plain">  val layer: ULayer[A] = ZLayer.succeed(ALive())</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait B {</span><br></span><span class="token-line"><span class="token plain">  def letsGoB(v: Int): UIO[String]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object B {</span><br></span><span class="token-line"><span class="token plain">  def letsGoB(v: Int): URIO[B, String] = ZIO.serviceWithZIO(_.letsGoB(v))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class BLive(serviceA: A) extends B {</span><br></span><span class="token-line"><span class="token plain">  def letsGoB(v: Int): UIO[String] = serviceA.letsGoA(v)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object BLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[A, Nothing, BLive] = ZLayer(ZIO.service[A].map(BLive(_)))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val program: ZIO[B, IOException, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- Console.printLine(s&quot;Welcome to ZIO!&quot;)</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- Clock.sleep(1.second)</span><br></span><span class="token-line"><span class="token plain">      r &lt;- B.letsGoB(10)</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- Console.printLine(r)</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = program.provide(ALive.layer, BLive.layer)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="an-example-of-manually-generating-a-dependency-graph">An Example of Manually Generating a Dependency Graph<a class="hash-link" href="#an-example-of-manually-generating-a-dependency-graph" title="Direct link to heading">​</a></h3><p>Suppose we have defined the ‍‍<code>UserRepo</code>, <code>DocumentRepo</code>, <code>Database</code>, <code>BlobStorage</code>, and <code>Cache</code> services and their respective implementations as follows:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class User(email: String, name: String)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait UserRepo {</span><br></span><span class="token-line"><span class="token plain">  def save(user: User): Task[Unit]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(email: String): Task[User]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object UserRepo {</span><br></span><span class="token-line"><span class="token plain">  def save(user: User): ZIO[UserRepo, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.save(user))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(email: String): ZIO[UserRepo, Throwable, User] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.get(email))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class UserRepoLive(cache: Cache, database: Database) extends UserRepo {</span><br></span><span class="token-line"><span class="token plain">  override def save(user: User): Task[Unit] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(email: String): Task[User] = ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object UserRepoLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: URLayer[Cache &amp; Database, UserRepo] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        cache    &lt;- ZIO.service[Cache]</span><br></span><span class="token-line"><span class="token plain">        database &lt;- ZIO.service[Database]</span><br></span><span class="token-line"><span class="token plain">      } yield UserRepoLive(cache, database)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Database</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class DatabaseLive() extends Database</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object DatabaseLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[Any, Nothing, Database] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer.succeed(DatabaseLive())</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait Cache {</span><br></span><span class="token-line"><span class="token plain">  def save(key: String, value: Array[Byte]): Task[Unit]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(key: String): Task[Array[Byte]]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def remove(key: String): Task[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">class InmemeoryCache() extends Cache {</span><br></span><span class="token-line"><span class="token plain">  override def save(key: String, value: Array[Byte]): Task[Unit] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(key: String): Task[Array[Byte]] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def remove(key: String): Task[Unit] = ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object InmemoryCache {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[Any, Throwable, Cache] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer(ZIO.attempt(new InmemeoryCache).debug(&quot;initialized&quot;))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">class PersistentCache() extends Cache {</span><br></span><span class="token-line"><span class="token plain">  override def save(key: String, value: Array[Byte]): Task[Unit] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(key: String): Task[Array[Byte]] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def remove(key: String): Task[Unit] = ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object PersistentCache {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[Any, Throwable, Cache] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer(ZIO.attempt(new PersistentCache).debug(&quot;initialized&quot;))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class Document(title: String, author: String, body: String)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait DocumentRepo {</span><br></span><span class="token-line"><span class="token plain">  def save(document: Document): Task[Unit]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(id: String): Task[Document]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object DocumentRepo {</span><br></span><span class="token-line"><span class="token plain">  def save(document: Document): ZIO[DocumentRepo, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.save(document))</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def get(id: String): ZIO[DocumentRepo, Throwable, Document] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.serviceWithZIO(_.get(id))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class DocumentRepoLive(cache: Cache, blobStorage: BlobStorage) extends DocumentRepo {</span><br></span><span class="token-line"><span class="token plain">  override def save(document: Document): Task[Unit] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  override def get(id: String): Task[Document] = ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object DocumentRepoLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: ZLayer[Cache &amp; BlobStorage, Nothing, DocumentRepo] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer {</span><br></span><span class="token-line"><span class="token plain">      for {</span><br></span><span class="token-line"><span class="token plain">        cache       &lt;- ZIO.service[Cache]</span><br></span><span class="token-line"><span class="token plain">        blobStorage &lt;- ZIO.service[BlobStorage]</span><br></span><span class="token-line"><span class="token plain">      } yield DocumentRepoLive(cache, blobStorage)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">trait BlobStorage {</span><br></span><span class="token-line"><span class="token plain">  def store(key: String, value: Array[Byte]): Task[Unit]</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class BlobStorageLive() extends BlobStorage {</span><br></span><span class="token-line"><span class="token plain">  override def store(key: String, value: Array[Byte]): Task[Unit] = ???</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object BlobStorageLive {</span><br></span><span class="token-line"><span class="token plain">  val layer: URLayer[Any, BlobStorage] =</span><br></span><span class="token-line"><span class="token plain">    ZLayer.succeed(BlobStorageLive())</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>And then assume we have the following ZIO application:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">def myApp: ZIO[DocumentRepo &amp; UserRepo, Throwable, Unit] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- UserRepo.save(User(&quot;john@doe&quot;, &quot;john&quot;))</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- DocumentRepo.save(Document(&quot;introduction to zio&quot;, &quot;john&quot;, &quot;&quot;))</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- UserRepo.get(&quot;john@doe&quot;).debug(&quot;retrieved john@doe user&quot;)</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- DocumentRepo.get(&quot;introduction to zio&quot;).debug(&quot;retrieved article about zio&quot;)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The <code>myApp</code> requires <code>DocumentRepo</code> and <code>UserRepo</code> services to run. So we need to create a <code>ZLayer</code> which requires no services and produces <code>DocumentRepo</code> and <code>UserRepo</code>. We can manually create this layer using <a href="#vertical-and-horizontal-composition">vertical and horizontal layer composition</a>: </p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val layers: ZLayer[Any, Any, DocumentRepo with UserRepo] =</span><br></span><span class="token-line"><span class="token plain">    (BlobStorageLive.layer ++ InmemoryCache.layer ++ DatabaseLive.layer) &gt;&gt;&gt;</span><br></span><span class="token-line"><span class="token plain">      (DocumentRepoLive.layer &gt;+&gt; UserRepoLive.layer)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provideLayer(layers)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="an-example-of-automatically-generating-a-dependency-graph">An Example of Automatically Generating a Dependency Graph<a class="hash-link" href="#an-example-of-automatically-generating-a-dependency-graph" title="Direct link to heading">​</a></h3><p>Instead of creating the required layer manually, we can use the <code>ZIO#provide</code>. ZIO internally creates the dependency graph automatically based on all dependencies provided:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run =</span><br></span><span class="token-line"><span class="token plain">    myApp.provide(</span><br></span><span class="token-line"><span class="token plain">      InmemoryCache.layer,</span><br></span><span class="token-line"><span class="token plain">      DatabaseLive.layer,</span><br></span><span class="token-line"><span class="token plain">      UserRepoLive.layer,</span><br></span><span class="token-line"><span class="token plain">      BlobStorageLive.layer,</span><br></span><span class="token-line"><span class="token plain">      DocumentRepoLive.layer</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">    </span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="an-example-of-providing-different-implementations-of-the-same-service">An Example of Providing Different Implementations of the Same Service<a class="hash-link" href="#an-example-of-providing-different-implementations-of-the-same-service" title="Direct link to heading">​</a></h3><p>Let&#x27;s say we want to provide different versions of the same service to different services. In this example, both <code>UserRepo</code> and <code>DocumentRepo</code> services require the <code>Cache</code> service. However, we want to provide different cache implementations for these two services. Our goal is to provide an <code>InmemoryCache</code> layer for <code>UserRepo</code> and a <code>PersistentCache</code> layer for the <code>DocumentRepo</code> service:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val layers: ZLayer[Any, Throwable, UserRepo with DocumentRepo] =</span><br></span><span class="token-line"><span class="token plain">    ((InmemoryCache.layer ++ DatabaseLive.layer) &gt;&gt;&gt; UserRepoLive.layer) ++</span><br></span><span class="token-line"><span class="token plain">      ((PersistentCache.layer ++ BlobStorageLive.layer) &gt;&gt;&gt; DocumentRepoLive.layer)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provideLayer(layers)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="an-example-of-how-to-get-fresh-layers">An Example of How to Get Fresh Layers<a class="hash-link" href="#an-example-of-how-to-get-fresh-layers" title="Direct link to heading">​</a></h3><p>Having covered the topic of <a href="#acquiring-a-fresh-version">acquiring fresh layers</a>, let&#x27;s see an example of using the <code>ZLayer#fresh</code> operator.</p><p><code>DocumentRepo</code> and <code>UserRepo</code> services are dependent on an in-memory cache service. On the other hand, let&#x27;s assume the cache service is quite simple, and we might be prone to cache conflicts between services. While sharing the cache service may cause some problems for our business logic, we should separate the cache service for both <code>DocumentRepo</code> and <code>UserRepo</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val layers: ZLayer[Any, Throwable, UserRepo &amp; DocumentRepo] =</span><br></span><span class="token-line"><span class="token plain">    ((InmemoryCache.layer.fresh ++ DatabaseLive.layer) &gt;&gt;&gt; UserRepoLive.layer) ++</span><br></span><span class="token-line"><span class="token plain">      ((InmemoryCache.layer.fresh ++ BlobStorageLive.layer) &gt;&gt;&gt; DocumentRepoLive.layer)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provideLayer(layers)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="an-example-of-pass-through-dependencies">An Example of Pass-through Dependencies<a class="hash-link" href="#an-example-of-pass-through-dependencies" title="Direct link to heading">​</a></h3><p>Notice that in the previous examples, both <code>UserRepo</code> and <code>DocuemntRepo</code> have some <a href="#hidden-versus-passed-through-dependencies">hidden dependencies</a>, such as <code>Cache</code>, <code>Database</code>, and <code>BlobStorage</code>.  So these hidden dependencies are no longer expressed in the type signature of the <code>layers</code>. From the perspective of a caller, <code>layers</code> just outputs a <code>UserRepo</code> and <code>DocuemntRepo</code> and requires no inputs. The caller does not need to be concerned with the internal implementation details of how the <code>UserRepo</code> and <code>DocumentRepo</code> are constructed.</p><p>An upstream dependency that is used by many other services can be &quot;passed-through&quot; and included in a layer&#x27;s output. This can be done with the <code>&gt;+&gt;</code> operator, which provides the output of one layer to another layer, returning a new layer that outputs the services of <em>both</em>.</p><p>The following example shows how to passthrough all dependencies to the final layer:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  // passthrough all dependencies</span><br></span><span class="token-line"><span class="token plain">  val layers: ZLayer[Any, Throwable, Database &amp; BlobStorage &amp; Cache &amp; DocumentRepo &amp; UserRepo] =</span><br></span><span class="token-line"><span class="token plain">    DatabaseLive.layer &gt;+&gt;</span><br></span><span class="token-line"><span class="token plain">      BlobStorageLive.layer &gt;+&gt;</span><br></span><span class="token-line"><span class="token plain">      InmemoryCache.layer &gt;+&gt;</span><br></span><span class="token-line"><span class="token plain">      DocumentRepoLive.layer &gt;+&gt;</span><br></span><span class="token-line"><span class="token plain">      UserRepoLive.layer</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  // providing all passthrough dependencies to the ZIO application</span><br></span><span class="token-line"><span class="token plain">  def run = myApp.provideLayer(layers)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="an-example-of-updating-hidden-dependencies">An Example of Updating Hidden Dependencies<a class="hash-link" href="#an-example-of-updating-hidden-dependencies" title="Direct link to heading">​</a></h3><p>One of the use cases of having explicit all dependencies in the final layer is that we can <a href="#updating-local-dependencies">update</a> those hidden layers using <code>ZLayer#update</code>. In the following example, we are replacing the <code>InmemoryCache</code> with another implementation called <code>PersistentCache</code>:</p><div class="codeBlockContainer_I0IT language-scala theme-code-block"><div class="codeBlockContent_wNvx scala"><pre tabindex="0" class="prism-code language-scala codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object MainApp extends ZIOAppDefault {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def myApp: ZIO[DocumentRepo &amp; UserRepo, Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.service[UserRepo]</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- ZIO.service[DocumentRepo]</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val layers: ZLayer[Any, Throwable, Database &amp; BlobStorage &amp; Cache &amp; DocumentRepo &amp; UserRepo] =</span><br></span><span class="token-line"><span class="token plain">    DatabaseLive.layer &gt;+&gt;</span><br></span><span class="token-line"><span class="token plain">      BlobStorageLive.layer &gt;+&gt;</span><br></span><span class="token-line"><span class="token plain">      InmemoryCache.layer &gt;+&gt;</span><br></span><span class="token-line"><span class="token plain">      DocumentRepoLive.layer &gt;+&gt;</span><br></span><span class="token-line"><span class="token plain">      UserRepoLive.layer</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run =</span><br></span><span class="token-line"><span class="token plain">    myApp.provideLayer(</span><br></span><span class="token-line"><span class="token plain">      layers.update[Cache](_ =&gt; new PersistentCache)</span><br></span><span class="token-line"><span class="token plain">    )</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zio/zio/edit/series/2.x/docs/datatypes/contextual/zlayer.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/next/datatypes/contextual/zenvironment"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">ZEnvironment</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/next/datatypes/contextual/rlayer"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">RLayer</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#creation" class="table-of-contents__link toc-highlight">Creation</a><ul><li><a href="#from-a-simple-value-or-an-existing-service" class="table-of-contents__link toc-highlight">From a Simple Value or an Existing Service</a></li><li><a href="#from-resourceful-effects-scoped-resources" class="table-of-contents__link toc-highlight">From Resourceful Effects (Scoped Resources)</a></li><li><a href="#from-non-resourceful-effects" class="table-of-contents__link toc-highlight">From Non-resourceful Effects</a></li><li><a href="#from-functions" class="table-of-contents__link toc-highlight">From Functions</a></li></ul></li><li><a href="#building-dependency-graph" class="table-of-contents__link toc-highlight">Building Dependency Graph</a></li><li><a href="#manual-layer-construction" class="table-of-contents__link toc-highlight">Manual Layer Construction</a><ul><li><a href="#vertical-and-horizontal-composition" class="table-of-contents__link toc-highlight">Vertical and Horizontal Composition</a></li><li><a href="#hidden-versus-passed-through-dependencies" class="table-of-contents__link toc-highlight">Hidden Versus Passed-through Dependencies</a></li><li><a href="#updating-local-dependencies" class="table-of-contents__link toc-highlight">Updating Local Dependencies</a></li><li><a href="#cyclic-dependencies" class="table-of-contents__link toc-highlight">Cyclic Dependencies</a></li></ul></li><li><a href="#automatic-layer-construction" class="table-of-contents__link toc-highlight">Automatic Layer Construction</a><ul><li><a href="#providing-individual-layers-to-a-zio-application" class="table-of-contents__link toc-highlight">Providing Individual Layers to a ZIO Application</a></li><li><a href="#automatically-assembling-layers" class="table-of-contents__link toc-highlight">Automatically Assembling Layers</a></li><li><a href="#zlayer-debugging" class="table-of-contents__link toc-highlight">ZLayer Debugging</a></li></ul></li><li><a href="#dependency-propagation" class="table-of-contents__link toc-highlight">Dependency Propagation</a></li><li><a href="#environment-scope" class="table-of-contents__link toc-highlight">Environment Scope</a><ul><li><a href="#global-environment" class="table-of-contents__link toc-highlight">Global Environment</a></li><li><a href="#local-environment" class="table-of-contents__link toc-highlight">Local Environment</a></li></ul></li><li><a href="#layer-memoization" class="table-of-contents__link toc-highlight">Layer Memoization</a><ul><li><a href="#layers-are-memoized-by-default-when-providing-globally" class="table-of-contents__link toc-highlight">Layers are Memoized by Default when Providing Globally</a></li><li><a href="#layers-are-not-memoized-when-providing-locally" class="table-of-contents__link toc-highlight">Layers are not Memoized When Providing Locally</a></li></ul></li><li><a href="#other-operators" class="table-of-contents__link toc-highlight">Other Operators</a><ul><li><a href="#converting-a-layer-to-a-scoped-value" class="table-of-contents__link toc-highlight">Converting a Layer to a Scoped Value</a></li><li><a href="#falling-back-to-an-alternate-layer" class="table-of-contents__link toc-highlight">Falling Back to an Alternate Layer</a></li><li><a href="#converting-a-layer-to-a-zio-application" class="table-of-contents__link toc-highlight">Converting a Layer to a ZIO Application</a></li><li><a href="#retrying" class="table-of-contents__link toc-highlight">Retrying</a></li><li><a href="#layer-projection" class="table-of-contents__link toc-highlight">Layer Projection</a></li><li><a href="#tapping" class="table-of-contents__link toc-highlight">Tapping</a></li></ul></li><li><a href="#examples" class="table-of-contents__link toc-highlight">Examples</a><ul><li><a href="#an-example-of-a-zio-application-with-a-simple-dependency" class="table-of-contents__link toc-highlight">An Example of a ZIO Application with a Simple Dependency</a></li><li><a href="#an-example-of-a-zio-application-with-multiple-dependencies" class="table-of-contents__link toc-highlight">An Example of a ZIO Application with Multiple Dependencies</a></li><li><a href="#an-example-of-manually-generating-a-dependency-graph" class="table-of-contents__link toc-highlight">An Example of Manually Generating a Dependency Graph</a></li><li><a href="#an-example-of-automatically-generating-a-dependency-graph" class="table-of-contents__link toc-highlight">An Example of Automatically Generating a Dependency Graph</a></li><li><a href="#an-example-of-providing-different-implementations-of-the-same-service" class="table-of-contents__link toc-highlight">An Example of Providing Different Implementations of the Same Service</a></li><li><a href="#an-example-of-how-to-get-fresh-layers" class="table-of-contents__link toc-highlight">An Example of How to Get Fresh Layers</a></li><li><a href="#an-example-of-pass-through-dependencies" class="table-of-contents__link toc-highlight">An Example of Pass-through Dependencies</a></li><li><a href="#an-example-of-updating-hidden-dependencies" class="table-of-contents__link toc-highlight">An Example of Updating Hidden Dependencies</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items"><li class="footer__item">
                <img src="/img/navbar_brand.png" alt="zio">
            </li></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items"><li class="footer__item">
              <a href="https://github.com/zio/zio">
                <img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github">
              </a>
            </li></ul></div><div class="col footer__col"><div class="footer__title">Chat with us on Discord</div><ul class="footer__items"><li class="footer__item">
                <a href="https://discord.gg/2ccFBr4">
                  <img src="https://img.shields.io/discord/629491597070827530?logo=discord&style=social" alt="discord">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Follow us on Twitter</div><ul class="footer__items"><li class="footer__item">
                <a href="https://twitter.com/zioscala">
                  <img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&style=social" alt="twitter">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Additional resources</div><ul class="footer__items"><li class="footer__item"><a href="https://javadoc.io/doc/dev.zio/zio_2.12/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scaladoc of ZIO<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 ZIO Maintainers - Built with <a href="https://v2.docusaurus.io/">Docusaurus v2</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.576d5781.js"></script>
<script src="/assets/js/main.3950424f.js"></script>
</body>
</html>