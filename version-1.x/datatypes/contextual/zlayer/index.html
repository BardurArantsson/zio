<!doctype html>
<html class="docs-version-1.x" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.9">
<link rel="search" type="application/opensearchdescription+xml" title="ZIO" href="/opensearch.xml">
<link rel="stylesheet" href="/css/prism/prism-material-dark.css"><title data-react-helmet="true">ZLayer | ZIO</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://zio.dev/version-1.x/datatypes/contextual/zlayer"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="1.x"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-1.x"><meta data-react-helmet="true" property="og:title" content="ZLayer | ZIO"><meta data-react-helmet="true" name="description" content="A ZLayer[-RIn, +E, +ROut] describes a layer of an application: every layer in an application requires some services as input RIn and produces some services as the output ROut."><meta data-react-helmet="true" property="og:description" content="A ZLayer[-RIn, +E, +ROut] describes a layer of an application: every layer in an application requires some services as input RIn and produces some services as the output ROut."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://zio.dev/version-1.x/datatypes/contextual/zlayer"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/version-1.x/datatypes/contextual/zlayer" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/version-1.x/datatypes/contextual/zlayer" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.f4d50625.css">
<link rel="preload" href="/assets/js/runtime~main.a9287c7c.js" as="script">
<link rel="preload" href="/assets/js/main.d278da23.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_TMUO themedImage--dark_uzRr"></div></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/version-1.x/overview/overview_index">Overview</a><a class="navbar__item navbar__link" href="/version-1.x/datatypes/index">Data Types</a><a class="navbar__item navbar__link" href="/version-1.x/usecases/usecases_index">Use Cases</a><a class="navbar__item navbar__link" href="/version-1.x/howto/index">How to</a><a class="navbar__item navbar__link" href="/version-1.x/resources/index">Resources</a><a class="navbar__item navbar__link" href="/version-1.x/about/about_index">About</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/version-1.x/overview/overview_index">ZIO 1.x</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/next/overview/overview_index">ZIO 2.x (WIP)</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/version-1.x/datatypes/contextual/zlayer">ZIO 1.x</a></li></ul></div><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">ðŸŒœ</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">ðŸŒž</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div><div class="searchBox_NKBi"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Overview</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Core Data Types</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Contextual Types</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/contextual/index">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/contextual/has">Has</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/version-1.x/datatypes/contextual/zlayer">ZLayer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/contextual/rlayer">RLayer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/contextual/ulayer">ULayer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/contextual/layer">Layer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/contextual/urlayer">URLayer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/contextual/tasklayer">TaskLayer</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Fiber Primitives</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Concurrency Primitives</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">STM</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Resource Safety</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Streaming</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Miscellaneous</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->ZIO 1.x</span><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>ZLayer</h1></header><p>A <code>ZLayer[-RIn, +E, +ROut]</code> describes a layer of an application: every layer in an application requires some services as input <code>RIn</code> and produces some services as the output <code>ROut</code>. </p><p>ZLayers are:</p><ol><li><p><strong>Recipes for Creating Services</strong> â€” They describe how a given dependencies produces another services. For example, the <code>ZLayer[Logging with Database, Throwable, UserRepo]</code> is a recipe for building a service that requires <code>Logging</code> and <code>Database</code> service, and it produces a <code>UserRepo</code> service.</p></li><li><p><strong>An Alternative to Constructors</strong> â€” We can think of <code>ZLayer</code> as a more powerful version of a constructor, it is an alternative way to represent a constructor. Like a constructor, it allows us to build the <code>ROut</code> service in terms of its dependencies (<code>RIn</code>).</p></li><li><p><strong>Composable</strong> â€” Because of their excellent <strong>composition properties</strong>, layers are the idiomatic way in ZIO to create services that depend on other services. We can define layers that are relying on each other. </p></li><li><p><strong>Effectful and Resourceful</strong> â€” The construction of ZIO layers can be effectful and resourceful, they can be acquired and safely released when the services are done being utilized.</p></li><li><p><strong>Asynchronous</strong> â€” Unlike class constructors which are blocking, ZLayer is fully asynchronous and non-blocking.</p></li></ol><p>For example, a <code>ZLayer[Blocking with Logging, Throwable, Database]</code> can be thought of as a function that map <code>Blocking</code> and <code>Logging</code> services into <code>Database</code> service: </p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">(Blocking, Logging) =&gt; Database</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>So we can say that the <code>Database</code> service has two dependencies: <code>Blocking</code> and <code>Logging</code> services.</p><p>Let&#x27;s see how we can create a layer:</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="creation">Creation<a aria-hidden="true" class="hash-link" href="#creation" title="Direct link to heading">â€‹</a></h2><p><code>ZLayer</code> is an <strong>alternative to a class constructor</strong>, a recipe to create a service. This recipe may contain the following information:</p><ol><li><p><strong>Dependencies</strong> â€” To create a service, we need to indicate what other service we are depending on. For example, a <code>Database</code> service might need <code>Socket</code> and <code>Blocking</code> services to perform its operations.</p></li><li><p><strong>Acquisition/Release Action</strong> â€” It may contain how to initialize a service. For example, if we are creating a recipe for a <code>Database</code> service, we should provide how the <code>Database</code> will be initialized, via acquisition action. Also, it may contain how to release a service. For example, how the <code>Database</code> releases its connection pools.</p></li></ol><p>In some cases, a <code>ZLayer</code> may not have any dependencies or requirements from the environment. In this case, we can specify <code>Any</code> for the <code>RIn</code> type parameter. The <code>Layer</code> type alias provided by ZIO is a convenient way to define a layer without requirements.</p><p>There are many ways to create a ZLayer. Here&#x27;s an incomplete list:</p><ul><li><code>ZLayer.succeed</code> to create a layer from an existing service</li><li><code>ZLayer.succeedMany</code> to create a layer from a value that&#x27;s one or more services</li><li><code>ZLayer.fromFunction</code> to create a layer from a function from the requirement to the service</li><li><code>ZLayer.fromEffect</code> to lift a <code>ZIO</code> effect to a layer requiring the effect environment</li><li><code>ZLayer.fromAcquireRelease</code> for a layer based on resource acquisition/release. The idea is the same as <code>ZManaged</code>.</li><li><code>ZLayer.fromService</code> to build a layer from a service</li><li><code>ZLayer.fromServices</code> to build a layer from a number of required services</li><li><code>ZLayer.identity</code> to express the requirement for a layer</li><li><code>ZIO#toLayer</code> or <code>ZManaged#toLayer</code> to construct a layer from an effect</li></ul><p>Where it makes sense, these methods have also variants to build a service effectfully (suffixed by <code>M</code>), resourcefully (suffixed by <code>Managed</code>), or to create a combination of services (suffixed by <code>Many</code>).</p><p>Let&#x27;s review some of the <code>ZLayer</code>&#x27;s most useful constructors:</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="from-simple-values">From Simple Values<a aria-hidden="true" class="hash-link" href="#from-simple-values" title="Direct link to heading">â€‹</a></h3><p>With <code>ZLayer.succeed</code> we can construct a <code>ZLayer</code> from a value. It returns a <code>ULayer[Has[A]]</code> value, which represents a layer of application that <em>has</em> a service of type <code>A</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def succeed[A: Tag](a: A): ULayer[Has[A]]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>In the following example, we are going to create a <code>nameLayer</code> that provides us the name of <code>Adam</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val nameLayer: ULayer[Has[String]] = ZLayer.succeed(&quot;Adam&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>In most cases, we use <code>ZLayer.succeed</code> to provide a layer of service of type <code>A</code>.</p><p>For example, assume we have written the following service:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">object terminal {</span><br></span><span class="token-line"><span class="token plain">  type Terminal = Has[Terminal.Service]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object Terminal {</span><br></span><span class="token-line"><span class="token plain">    trait Service {</span><br></span><span class="token-line"><span class="token plain">      def putStrLn(line: String): UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    object Service {</span><br></span><span class="token-line"><span class="token plain">      val live: Service = new Service {</span><br></span><span class="token-line"><span class="token plain">        override def putStrLn(line: String): UIO[Unit] =</span><br></span><span class="token-line"><span class="token plain">          ZIO.effectTotal(println(line))</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Now we can create a <code>ZLayer</code> from the <code>live</code> version of this service:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">import terminal._</span><br></span><span class="token-line"><span class="token plain">val live: ZLayer[Any, Nothing, Terminal] = ZLayer.succeed(Terminal.Service.live)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="from-managed-resources">From Managed Resources<a aria-hidden="true" class="hash-link" href="#from-managed-resources" title="Direct link to heading">â€‹</a></h3><p>Some components of our applications need to be managed, meaning they undergo a resource acquisition phase before usage, and a resource release phase after usage (e.g. when the application shuts down). </p><p>Fortunately, the construction of ZIO layers can be effectful and resourceful, this means they can be acquired and safely released when the services are done being utilized.</p><p><code>ZLayer</code> relies on the powerful <code>ZManaged</code> data type and this makes this process extremely simple.</p><p>We can lift any <code>ZManaged</code> to <code>ZLayer</code> by providing a managed resource to the <code>ZIO.fromManaged</code> constructor:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val managedFile = ZManaged.fromAutoCloseable(</span><br></span><span class="token-line"><span class="token plain">  ZIO.effect(scala.io.Source.fromFile(&quot;file.txt&quot;))</span><br></span><span class="token-line"><span class="token plain">)</span><br></span><span class="token-line"><span class="token plain">val fileLayer: ZLayer[Any, Throwable, Has[BufferedSource]] = </span><br></span><span class="token-line"><span class="token plain">  ZLayer.fromManaged(managedFile)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Also, every <code>ZManaged</code> can be converted to <code>ZLayer</code> by calling <code>ZLayer#toLayer</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val fileLayer: ZLayer[Any, Throwable, Has[BufferedSource]] = managedFile.toLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Let&#x27;s see another real-world example of creating a layer from managed resources. Assume we have written a managed <code>UserRepository</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def userRepository: ZManaged[Blocking with Console, Throwable, UserRepository] = for {</span><br></span><span class="token-line"><span class="token plain">  cfg &lt;- dbConfig.toManaged_</span><br></span><span class="token-line"><span class="token plain">  _ &lt;- initializeDb(cfg).toManaged_</span><br></span><span class="token-line"><span class="token plain">  xa &lt;- makeTransactor(cfg)</span><br></span><span class="token-line"><span class="token plain">} yield new UserRepository(xa)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We can convert that to <code>ZLayer</code> with <code>ZLayer.fromManaged</code> or <code>ZManaged#toLayer</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val usersLayer  = userRepository.toLayer</span><br></span><span class="token-line"><span class="token plain">// usersLayer: ZLayer[Blocking with Console, Throwable, Has[UserRepository]] = Managed(</span><br></span><span class="token-line"><span class="token plain">//   self = zio.ZManaged$$anon$2@58c2b964</span><br></span><span class="token-line"><span class="token plain">// )</span><br></span><span class="token-line"><span class="token plain">val usersLayer_ = ZLayer.fromManaged(userRepository)</span><br></span><span class="token-line"><span class="token plain">// usersLayer_: ZLayer[Blocking with Console, Throwable, Has[UserRepository]] = Managed(</span><br></span><span class="token-line"><span class="token plain">//   self = zio.ZManaged$$anon$2@58c45c99</span><br></span><span class="token-line"><span class="token plain">// )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Also, we can create a <code>ZLayer</code> directly from <code>acquire</code> and <code>release</code> actions of a managed resource:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def acquire = ZIO.effect(new FileInputStream(&quot;file.txt&quot;))</span><br></span><span class="token-line"><span class="token plain">def release(resource: Closeable) = ZIO.effectTotal(resource.close())</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val inputStreamLayer = ZLayer.fromAcquireRelease(acquire)(release)</span><br></span><span class="token-line"><span class="token plain">// inputStreamLayer: ZLayer[Any, Throwable, Has[FileInputStream]] = Managed(</span><br></span><span class="token-line"><span class="token plain">//   self = zio.ZManaged$$anon$2@43c0ebd1</span><br></span><span class="token-line"><span class="token plain">// )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="from-zio-effects">From ZIO Effects<a aria-hidden="true" class="hash-link" href="#from-zio-effects" title="Direct link to heading">â€‹</a></h3><p>We can create <code>ZLayer</code> from any <code>ZIO</code> effect by using <code>ZLayer.fromEffect</code> constructor, or calling <code>ZIO#toLayer</code> method:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val layer = ZLayer.fromEffect(ZIO.succeed(&quot;Hello, World!&quot;))</span><br></span><span class="token-line"><span class="token plain">// layer: ZLayer[Any, Nothing, Has[String]] = Managed(</span><br></span><span class="token-line"><span class="token plain">//   self = zio.ZManaged$$anon$2@c55461e</span><br></span><span class="token-line"><span class="token plain">// )</span><br></span><span class="token-line"><span class="token plain">val layer_ = ZIO.succeed(&quot;Hello, World!&quot;).toLayer</span><br></span><span class="token-line"><span class="token plain">// layer_: ZLayer[Any, Nothing, Has[String]] = Managed(</span><br></span><span class="token-line"><span class="token plain">//   self = zio.ZManaged$$anon$2@25d02a14</span><br></span><span class="token-line"><span class="token plain">// )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Assume we have a <code>ZIO</code> effect that read the application config from a file, we can create a layer from that:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def loadConfig: Task[AppConfig] = Task.effect(???)</span><br></span><span class="token-line"><span class="token plain">val configLayer = ZLayer.fromEffect(loadConfig)</span><br></span><span class="token-line"><span class="token plain">// configLayer: ZLayer[Any, Throwable, Has[AppConfig]] = Managed(</span><br></span><span class="token-line"><span class="token plain">//   self = zio.ZManaged$$anon$2@231f99e0</span><br></span><span class="token-line"><span class="token plain">// )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="from-another-service">From another Service<a aria-hidden="true" class="hash-link" href="#from-another-service" title="Direct link to heading">â€‹</a></h3><p>Every <code>ZLayer</code> describes an application that requires some services as input and produces some services as output. Sometimes when we are writing a new layer, we may need to access and depend on one or several services.</p><p>The <code>ZLayer.fromService</code> construct a layer that purely depends on the specified service:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def fromService[A: Tag, B: Tag](f: A =&gt; B): ZLayer[Has[A], Nothing, Has[B]]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Assume we want to write a <code>live</code> version of the following logging service:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">object logging {</span><br></span><span class="token-line"><span class="token plain">  type Logging = Has[Logging.Service]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object Logging {</span><br></span><span class="token-line"><span class="token plain">    trait Service {</span><br></span><span class="token-line"><span class="token plain">      def log(msg: String): UIO[Unit]</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We can create that by using <code>ZLayer.fromService</code> constructor, which depends on <code>Console</code> service:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val live: ZLayer[Console, Nothing, Logging] = ZLayer.fromService(console =&gt;</span><br></span><span class="token-line"><span class="token plain">  new Service {</span><br></span><span class="token-line"><span class="token plain">    override def log(msg: String): UIO[Unit] = console.putStrLn(msg).orDie</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="vertical-and-horizontal-composition">Vertical and Horizontal Composition<a aria-hidden="true" class="hash-link" href="#vertical-and-horizontal-composition" title="Direct link to heading">â€‹</a></h2><p>We said that we can think of the <code>ZLayer</code> as a more powerful <em>constructor</em>. Constructors are not composable, because they are not values. While a constructor is not composable, <code>ZLayer</code> has a nice facility to compose with other <code>ZLayer</code>s. So we can say that a <code>Zlayer</code> turns a constructor into values.</p><p><code>ZLayer</code>s can be composed together horizontally or vertically:</p><ol><li><p><strong>Horizontal Composition</strong> â€” They can be composed together horizontally with the <code>++</code> operator. When we compose two layers horizontally, the new layer that this layer requires all the services that both of them require, also this layer produces all services that both of them produces. Horizontal composition is a way of composing two layers side-by-side. It is useful when we combine two layers that they don&#x27;t have any relationship with each other. </p></li><li><p><strong>Vertical Composition</strong> â€” If we have a layer that requires <code>A</code> and produces <code>B</code>, we can compose this layer with another layer that requires <code>B</code> and produces <code>C</code>; this composition produces a layer that requires <code>A</code> and produces <code>C</code>. The feed operator, <code>&gt;&gt;&gt;</code>, stack them on top of each other by using vertical composition. This sort of composition is like <em>function composition</em>, feeding an output of one layer to an input of another.</p></li></ol><p>Let&#x27;s get into an example, assume we have these services with their implementations:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">trait Logging { }</span><br></span><span class="token-line"><span class="token plain">trait Database { }</span><br></span><span class="token-line"><span class="token plain">trait BlobStorage { }</span><br></span><span class="token-line"><span class="token plain">trait UserRepo { }</span><br></span><span class="token-line"><span class="token plain">trait DocRepo { }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">case class LoggerImpl(console: Console.Service) extends Logging { }</span><br></span><span class="token-line"><span class="token plain">case class DatabaseImp(blocking: Blocking.Service) extends Database { }</span><br></span><span class="token-line"><span class="token plain">case class UserRepoImpl(logging: Logging, database: Database) extends UserRepo { } </span><br></span><span class="token-line"><span class="token plain">case class BlobStorageImpl(logging: Logging) extends BlobStorage { }</span><br></span><span class="token-line"><span class="token plain">case class DocRepoImpl(logging: Logging, database: Database, blobStorage: BlobStorage) extends DocRepo { }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We can&#x27;t compose these services together, because their constructors are not value. <code>ZLayer</code> can convert these services into values, then we can compose them together.</p><p>Let&#x27;s assume we have lifted these services into <code>ZLayer</code>s:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val logging: URLayer[Has[Console.Service], Has[Logging]] = </span><br></span><span class="token-line"><span class="token plain">  (LoggerImpl.apply _).toLayer</span><br></span><span class="token-line"><span class="token plain">val database: URLayer[Has[Blocking.Service], Has[Database]] = </span><br></span><span class="token-line"><span class="token plain">  (DatabaseImp(_)).toLayer</span><br></span><span class="token-line"><span class="token plain">val userRepo: URLayer[Has[Logging] with Has[Database], Has[UserRepo]] = </span><br></span><span class="token-line"><span class="token plain">  (UserRepoImpl(_, _)).toLayer</span><br></span><span class="token-line"><span class="token plain">val blobStorage: URLayer[Has[Logging], Has[BlobStorage]] = </span><br></span><span class="token-line"><span class="token plain">  (BlobStorageImpl(_)).toLayer</span><br></span><span class="token-line"><span class="token plain">val docRepo: URLayer[Has[Logging] with Has[Database] with Has[BlobStorage], Has[DocRepo]] = </span><br></span><span class="token-line"><span class="token plain">  (DocRepoImpl(_, _, _)).toLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Now, we can compose logging and database horizontally:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val newLayer: ZLayer[Has[Console.Service] with Has[Blocking.Service], Throwable, Has[Logging] with Has[Database]] = logging ++ database</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>And then we can compose the <code>newLayer</code> with <code>userRepo</code> vertically:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val myLayer: ZLayer[Has[Console.Service] with Has[Blocking.Service], Throwable, Has[UserRepo]] = newLayer &gt;&gt;&gt; userRepo</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="layer-memoization">Layer Memoization<a aria-hidden="true" class="hash-link" href="#layer-memoization" title="Direct link to heading">â€‹</a></h2><p>One important feature of <code>ZIO</code> layers is that <strong>they are shared by default</strong>, meaning that if the same layer is used twice, the layer will only be allocated a single time. </p><p>For every layer in our dependency graph, there is only one instance of it that is shared between all the layers that depend on it. </p><p>If we don&#x27;t want to share a module, we should create a fresh, non-shared version of it through <code>ZLayer#fresh</code>.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="updating-local-dependencies">Updating Local Dependencies<a aria-hidden="true" class="hash-link" href="#updating-local-dependencies" title="Direct link to heading">â€‹</a></h2><p>Given a layer, it is possible to update one or more components it provides. We update a dependency in two ways:</p><ol><li><strong>Using the <code>update</code> Method</strong> â€” This method allows us to replace one requirement with a different implementation:</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val withPostgresService = horizontal.update[UserRepo.Service]{ oldRepo  =&gt; new UserRepo.Service {</span><br></span><span class="token-line"><span class="token plain">      override def getUser(userId: UserId): IO[DBError, Option[User]] = UIO(???)</span><br></span><span class="token-line"><span class="token plain">      override def createUser(user: User): IO[DBError, Unit] = UIO(???)</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ol start="2"><li><strong>Using Horizontal Composition</strong> â€” Another way to update a requirement is to horizontally compose in a layer that provides the updated service. The resulting composition will replace the old layer with the new one:</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val dbLayer: Layer[Nothing, UserRepo] = ZLayer.succeed(new UserRepo.Service {</span><br></span><span class="token-line"><span class="token plain">    override def getUser(userId: UserId): IO[DBError, Option[User]] = ???</span><br></span><span class="token-line"><span class="token plain">    override def createUser(user: User): IO[DBError, Unit] = ???</span><br></span><span class="token-line"><span class="token plain">  })</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val updatedHorizontal2 = horizontal ++ dbLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="hidden-versus-passed-through-dependencies">Hidden Versus Passed Through Dependencies<a aria-hidden="true" class="hash-link" href="#hidden-versus-passed-through-dependencies" title="Direct link to heading">â€‹</a></h2><p>One design decision regarding building dependency graphs is whether to hide or pass through the upstream dependencies of a service. <code>ZLayer</code> defaults to hidden dependencies but makes it easy to pass through dependencies as well.</p><p>To illustrate this, consider the Postgres-based repository discussed above:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val connection: ZLayer[Any, Nothing, Has[Connection]] = connectionLayer</span><br></span><span class="token-line"><span class="token plain">val userRepo: ZLayer[Has[Connection], Nothing, UserRepo] = postgresLayer</span><br></span><span class="token-line"><span class="token plain">val layer: ZLayer[Any, Nothing, UserRepo] = connection &gt;&gt;&gt; userRepo</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Notice that in <code>layer</code>, the dependency <code>UserRepo</code> has on <code>Connection</code> has been &quot;hidden&quot;, and is no longer expressed in the type signature. From the perspective of a caller, <code>layer</code> just outputs a <code>UserRepo</code> and requires no inputs. The caller does not need to be concerned with the internal implementation details of how the <code>UserRepo</code> is constructed.</p><p>To provide only some inputs, we need to explicitly define what inputs still need to be provided:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">trait Configuration</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">val userRepoWithConfig: ZLayer[Has[Configuration] with Has[Connection], Nothing, UserRepo] = </span><br></span><span class="token-line"><span class="token plain">  ZLayer.succeed(new Configuration{}) ++ postgresLayer</span><br></span><span class="token-line"><span class="token plain">val partialLayer: ZLayer[Has[Configuration], Nothing, UserRepo] = </span><br></span><span class="token-line"><span class="token plain">  (ZLayer.identity[Has[Configuration]] ++ connection) &gt;&gt;&gt; userRepoWithConfig</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>In this example the requirement for a <code>Connection</code> has been satisfied, but <code>Configuration</code> is still required by <code>partialLayer</code>.</p><p>This achieves an encapsulation of services and can make it easier to refactor code. For example, say we want to refactor our application to use an in-memory database:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val updatedLayer: ZLayer[Any, Nothing, UserRepo] = dbLayer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>No other code will need to be changed, because the previous implementation&#x27;s dependency upon a <code>Connection</code> was hidden from users, and so they were not able to rely on it.</p><p>However, if an upstream dependency is used by many other services, it can be convenient to &quot;pass through&quot; that dependency, and include it in the output of a layer. This can be done with the <code>&gt;+&gt;</code> operator, which provides the output of one layer to another layer, returning a new layer that outputs the services of <em>both</em> layers.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">val layer: ZLayer[Any, Nothing, Has[Connection] with UserRepo] = connection &gt;+&gt; userRepo</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Here, the <code>Connection</code> dependency has been passed through, and is available to all downstream services. This allows a style of composition where the <code>&gt;+&gt;</code> operator is used to build a progressively larger set of services, with each new service able to depend on all the services before it.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">lazy val baker: ZLayer[Any, Nothing, Baker] = ???</span><br></span><span class="token-line"><span class="token plain">lazy val ingredients: ZLayer[Any, Nothing, Ingredients] = ???</span><br></span><span class="token-line"><span class="token plain">lazy val oven: ZLayer[Any, Nothing, Oven] = ???</span><br></span><span class="token-line"><span class="token plain">lazy val dough: ZLayer[Baker with Ingredients, Nothing, Dough] = ???</span><br></span><span class="token-line"><span class="token plain">lazy val cake: ZLayer[Baker with Oven with Dough, Nothing, Cake] = ???</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">lazy val all: ZLayer[Any, Nothing, Baker with Ingredients with Oven with Dough with Cake] =</span><br></span><span class="token-line"><span class="token plain">  baker &gt;+&gt;       // Baker</span><br></span><span class="token-line"><span class="token plain">  ingredients &gt;+&gt; // Baker with Ingredients</span><br></span><span class="token-line"><span class="token plain">  oven &gt;+&gt;        // Baker with Ingredients with Oven</span><br></span><span class="token-line"><span class="token plain">  dough &gt;+&gt;       // Baker with Ingredients with Oven with Dough</span><br></span><span class="token-line"><span class="token plain">  cake            // Baker with Ingredients with Oven with Dough with Cake</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>ZLayer</code> makes it easy to mix and match these styles. If you pass through dependencies and later want to hide them you can do so through a simple type ascription:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">lazy val hidden: ZLayer[Any, Nothing, Cake] = all</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>And if you do build your dependency graph more explicitly, you can be confident that layers used in multiple parts of the dependency graph will only be created once due to memoization and sharing.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="cyclic-dependencies">Cyclic Dependencies<a aria-hidden="true" class="hash-link" href="#cyclic-dependencies" title="Direct link to heading">â€‹</a></h2><p>The <code>ZLayer</code> mechanism makes it impossible to build cyclic dependencies, making the initialization process very linear, by construction.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="asynchronous-service-construction">Asynchronous Service Construction<a aria-hidden="true" class="hash-link" href="#asynchronous-service-construction" title="Direct link to heading">â€‹</a></h2><p>Another important note about <code>ZLayer</code> is that, unlike constructors which are synchronous, <code>ZLayer</code> is <em>asynchronous</em>. Constructors in classes are always synchronous. This is a drawback for non-blocking applications. Because sometimes we might want to use something that is blocking the inside constructor.</p><p>For example, when we are constructing some sort of Kafka streaming service, we might want to connect to the Kafka cluster in the constructor of our service, which takes some time. So that wouldn&#x27;t be a good idea to blocking inside a constructor. There are some workarounds for fixing this issue, but they are not perfect as the ZIO solution.</p><p>Well, with ZIO ZLayer, our constructor could be asynchronous, and they also can block definitely. And that is because <code>ZLayer</code> has the full power of ZIO. And as a result, we have strictly more power on our constructors with ZLayer. </p><p>We can acquire resources asynchronously or in a blocking fashion, and spend some time doing that, and we don&#x27;t need to worry about it. That is not an anti-pattern. This is the best practice with ZIO.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="examples">Examples<a aria-hidden="true" class="hash-link" href="#examples" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="the-simplest-zlayer-application">The simplest ZLayer application<a aria-hidden="true" class="hash-link" href="#the-simplest-zlayer-application" title="Direct link to heading">â€‹</a></h3><p>This application demonstrates a ZIO program with a single dependency on a simple string value:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object Example extends zio.App {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  // Define our simple ZIO program</span><br></span><span class="token-line"><span class="token plain">  val zio: ZIO[Has[String], Nothing, Unit] = for {</span><br></span><span class="token-line"><span class="token plain">    name &lt;- ZIO.access[Has[String]](_.get)</span><br></span><span class="token-line"><span class="token plain">    _    &lt;- UIO(println(s&quot;Hello, $name!&quot;))</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  // Create a ZLayer that produces a string and can be used to satisfy a string</span><br></span><span class="token-line"><span class="token plain">  // dependency that the program has</span><br></span><span class="token-line"><span class="token plain">  val nameLayer: ULayer[Has[String]] = ZLayer.succeed(&quot;Adam&quot;)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  // Run the program, providing the `nameLayer`</span><br></span><span class="token-line"><span class="token plain">  def run(args: List[String]): URIO[ZEnv, ExitCode] =</span><br></span><span class="token-line"><span class="token plain">    zio.provideLayer(nameLayer).as(ExitCode.success)</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="zlayer-application-with-dependencies">ZLayer application with dependencies<a aria-hidden="true" class="hash-link" href="#zlayer-application-with-dependencies" title="Direct link to heading">â€‹</a></h3><p>In the following example, our ZIO application has several dependencies:</p><ul><li><code>zio.clock.Clock</code></li><li><code>zio.console.Console</code></li><li><code>ModuleB</code></li></ul><p><code>ModuleB</code> in turn depends upon <code>ModuleA</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.clock._</span><br></span><span class="token-line"><span class="token plain">import zio.console._</span><br></span><span class="token-line"><span class="token plain">import zio.duration.Duration._</span><br></span><span class="token-line"><span class="token plain">import java.io.IOException</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object moduleA {</span><br></span><span class="token-line"><span class="token plain">  type ModuleA = Has[ModuleA.Service]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object ModuleA {</span><br></span><span class="token-line"><span class="token plain">    trait Service {</span><br></span><span class="token-line"><span class="token plain">      def letsGoA(v: Int): UIO[String]</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val any: ZLayer[ModuleA, Nothing, ModuleA] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.requires[ModuleA]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val live: Layer[Nothing, Has[Service]] = ZLayer.succeed {</span><br></span><span class="token-line"><span class="token plain">      new Service {</span><br></span><span class="token-line"><span class="token plain">        def letsGoA(v: Int): UIO[String] = UIO(s&quot;done: v = $v &quot;)</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def letsGoA(v: Int): URIO[ModuleA, String] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.accessM(_.get.letsGoA(v))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">import moduleA._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object moduleB {</span><br></span><span class="token-line"><span class="token plain">  type ModuleB = Has[ModuleB.Service]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object ModuleB {</span><br></span><span class="token-line"><span class="token plain">    trait Service {</span><br></span><span class="token-line"><span class="token plain">      def letsGoB(v: Int): UIO[String]</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val any: ZLayer[ModuleB, Nothing, ModuleB] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.requires[ModuleB]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val live: ZLayer[ModuleA, Nothing, ModuleB] = ZLayer.fromService { (moduleA: ModuleA.Service) =&gt;</span><br></span><span class="token-line"><span class="token plain">      new Service {</span><br></span><span class="token-line"><span class="token plain">        def letsGoB(v: Int): UIO[String] =</span><br></span><span class="token-line"><span class="token plain">          moduleA.letsGoA(v)</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def letsGoB(v: Int): URIO[ModuleB, String] =</span><br></span><span class="token-line"><span class="token plain">    ZIO.accessM(_.get.letsGoB(v))</span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object ZLayerApp0 extends zio.App {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  import moduleB._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val env = Console.live ++ Clock.live ++ (ModuleA.live &gt;&gt;&gt; ModuleB.live)</span><br></span><span class="token-line"><span class="token plain">  val program: ZIO[Console with Clock with moduleB.ModuleB, IOException, Unit] =</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- putStrLn(s&quot;Welcome to ZIO!&quot;)</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- sleep(Finite(1000))</span><br></span><span class="token-line"><span class="token plain">      r &lt;- letsGoB(10)</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- putStrLn(r)</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  def run(args: List[String]) =</span><br></span><span class="token-line"><span class="token plain">    program.provideLayer(env).exitCode</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">// output: </span><br></span><span class="token-line"><span class="token plain">// [info] running ZLayersApp </span><br></span><span class="token-line"><span class="token plain">// Welcome to ZIO!</span><br></span><span class="token-line"><span class="token plain">// done: v = 10 </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="zlayer-example-with-complex-dependencies">ZLayer example with complex dependencies<a aria-hidden="true" class="hash-link" href="#zlayer-example-with-complex-dependencies" title="Direct link to heading">â€‹</a></h3><p>In this example, we can see that <code>ModuleC</code> depends upon <code>ModuleA</code>, <code>ModuleB</code>, and <code>Clock</code>. The layer provided to the runnable application shows how dependency layers can be combined using <code>++</code> into a single combined layer. The combined layer will then be able to produce both of the outputs of the original layers as a single layer:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">import zio._</span><br></span><span class="token-line"><span class="token plain">import zio.clock._</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">object ZLayerApp1 extends scala.App {</span><br></span><span class="token-line"><span class="token plain">  val rt = Runtime.default</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  type ModuleA = Has[ModuleA.Service]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object ModuleA {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    trait Service {}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val any: ZLayer[ModuleA, Nothing, ModuleA] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.requires[ModuleA]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val live: ZLayer[Any, Nothing, ModuleA] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.succeed(new Service {})</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  type ModuleB = Has[ModuleB.Service]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object ModuleB {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    trait Service {}</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val any: ZLayer[ModuleB, Nothing, ModuleB] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.requires[ModuleB]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val live: ZLayer[Any, Nothing, ModuleB] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.succeed(new Service {})</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  type ModuleC = Has[ModuleC.Service]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  object ModuleC {</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    trait Service {</span><br></span><span class="token-line"><span class="token plain">      def foo: UIO[Int]</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val any: ZLayer[ModuleC, Nothing, ModuleC] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.requires[ModuleC]</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val live: ZLayer[ModuleA with ModuleB with Clock, Nothing, ModuleC] =</span><br></span><span class="token-line"><span class="token plain">      ZLayer.succeed {</span><br></span><span class="token-line"><span class="token plain">        new Service {</span><br></span><span class="token-line"><span class="token plain">          val foo: UIO[Int] = UIO.succeed(42)</span><br></span><span class="token-line"><span class="token plain">        }</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">    val foo: URIO[ModuleC, Int] =</span><br></span><span class="token-line"><span class="token plain">      ZIO.accessM(_.get.foo)</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val env = (ModuleA.live ++ ModuleB.live ++ ZLayer.identity[Clock]) &gt;&gt;&gt; ModuleC.live</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val res = ModuleC.foo.provideCustomLayer(env)</span><br></span><span class="token-line"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line"><span class="token plain">  val out = rt.unsafeRun(res)</span><br></span><span class="token-line"><span class="token plain">  println(out)</span><br></span><span class="token-line"><span class="token plain">  // 42</span><br></span><span class="token-line"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.x/datatypes/contextual/zlayer.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/version-1.x/datatypes/contextual/has"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« <!-- -->Has</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/version-1.x/datatypes/contextual/rlayer"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">RLayer<!-- --> Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#creation" class="table-of-contents__link toc-highlight">Creation</a><ul><li><a href="#from-simple-values" class="table-of-contents__link toc-highlight">From Simple Values</a></li><li><a href="#from-managed-resources" class="table-of-contents__link toc-highlight">From Managed Resources</a></li><li><a href="#from-zio-effects" class="table-of-contents__link toc-highlight">From ZIO Effects</a></li><li><a href="#from-another-service" class="table-of-contents__link toc-highlight">From another Service</a></li></ul></li><li><a href="#vertical-and-horizontal-composition" class="table-of-contents__link toc-highlight">Vertical and Horizontal Composition</a></li><li><a href="#layer-memoization" class="table-of-contents__link toc-highlight">Layer Memoization</a></li><li><a href="#updating-local-dependencies" class="table-of-contents__link toc-highlight">Updating Local Dependencies</a></li><li><a href="#hidden-versus-passed-through-dependencies" class="table-of-contents__link toc-highlight">Hidden Versus Passed Through Dependencies</a></li><li><a href="#cyclic-dependencies" class="table-of-contents__link toc-highlight">Cyclic Dependencies</a></li><li><a href="#asynchronous-service-construction" class="table-of-contents__link toc-highlight">Asynchronous Service Construction</a></li><li><a href="#examples" class="table-of-contents__link toc-highlight">Examples</a><ul><li><a href="#the-simplest-zlayer-application" class="table-of-contents__link toc-highlight">The simplest ZLayer application</a></li><li><a href="#zlayer-application-with-dependencies" class="table-of-contents__link toc-highlight">ZLayer application with dependencies</a></li><li><a href="#zlayer-example-with-complex-dependencies" class="table-of-contents__link toc-highlight">ZLayer example with complex dependencies</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><ul class="footer__items"><li class="footer__item">
                <img src="/img/navbar_brand.png" alt="zio">
            </li></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items"><li class="footer__item">
              <a href="https://github.com/zio/zio">
                <img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github">
              </a>
            </li></ul></div><div class="col footer__col"><div class="footer__title">Chat with us on Discord</div><ul class="footer__items"><li class="footer__item">
                <a href="https://discord.gg/2ccFBr4">
                  <img src="https://img.shields.io/discord/629491597070827530?logo=discord&style=social" alt="discord">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Follow us on Twitter</div><ul class="footer__items"><li class="footer__item">
                <a href="https://twitter.com/zioscala">
                  <img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&style=social" alt="twitter">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Additional resources</div><ul class="footer__items"><li class="footer__item"><a href="https://javadoc.io/doc/dev.zio/zio_2.12/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scaladoc of ZIO<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 ZIO Maintainers - Built with <a href="https://v2.docusaurus.io/">Docusaurus v2</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.a9287c7c.js"></script>
<script src="/assets/js/main.d278da23.js"></script>
</body>
</html>