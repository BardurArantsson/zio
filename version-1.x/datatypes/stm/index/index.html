<!doctype html>
<html class="docs-version-1.x" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.9">
<link rel="search" type="application/opensearchdescription+xml" title="ZIO" href="/opensearch.xml">
<link rel="stylesheet" href="/css/prism/prism-material-dark.css"><title data-react-helmet="true">Introduction | ZIO</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://zio.dev/version-1.x/datatypes/stm/index"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="1.x"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-1.x"><meta data-react-helmet="true" property="og:title" content="Introduction | ZIO"><meta data-react-helmet="true" name="description" content="Overview"><meta data-react-helmet="true" property="og:description" content="Overview"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://zio.dev/version-1.x/datatypes/stm/index"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/version-1.x/datatypes/stm/index" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/version-1.x/datatypes/stm/index" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.f4d50625.css">
<link rel="preload" href="/assets/js/runtime~main.a9287c7c.js" as="script">
<link rel="preload" href="/assets/js/main.d278da23.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_TMUO themedImage--dark_uzRr"></div></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/version-1.x/overview/overview_index">Overview</a><a class="navbar__item navbar__link" href="/version-1.x/datatypes/index">Data Types</a><a class="navbar__item navbar__link" href="/version-1.x/usecases/usecases_index">Use Cases</a><a class="navbar__item navbar__link" href="/version-1.x/howto/index">How to</a><a class="navbar__item navbar__link" href="/version-1.x/resources/index">Resources</a><a class="navbar__item navbar__link" href="/version-1.x/about/about_index">About</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/version-1.x/overview/overview_index">ZIO 1.x</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/next/datatypes/stm/index">ZIO 2.x (WIP)</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/version-1.x/datatypes/stm/index">ZIO 1.x</a></li></ul></div><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">ðŸŒœ</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">ðŸŒž</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div><div class="searchBox_NKBi"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Overview</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Core Data Types</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Contextual Types</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Fiber Primitives</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Concurrency Primitives</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">STM</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/version-1.x/datatypes/stm/index">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/stm">STM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/tarray">TArray</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/tset">TSet</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/tmap">TMap</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/tref">TRef</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/tpriorityqueue">TPriorityQueue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/tpromise">TPromise</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/tqueue">TQueue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/treentrantlock">TReentrantLock</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/version-1.x/datatypes/stm/tsemaphore">TSemaphore</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Resource Safety</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Streaming</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Miscellaneous</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->ZIO 1.x</span><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Introduction</h1></header><h2 class="anchor anchorWithStickyNavbar_y2LR" id="overview">Overview<a aria-hidden="true" class="hash-link" href="#overview" title="Direct link to heading">â€‹</a></h2><p>ZIO supports Software Transactional Memory (STM) which is a modular composable concurrency data structure. It allows us to combine and compose a group of memory operations and perform all of them in one single atomic operation.</p><p>Software Transactional Memory is an abstraction for concurrent communications. The main benefits of STM are composability and modularity. We can write concurrent abstractions that can be composed with any other abstraction built using STM, without exposing the details of how our abstraction ensures safety. This is typically not the case with the locking mechanism.</p><p>The idea of the transactional operation is not new, they have been the fundamental of distributed systems, and those databases that guarantee us an ACID property. Software transactional memory is just all about memory operations. All operations performed on memory. It is not related to a remote system or a database. Very similar to the database concept of ACID property, but the <em>durability</em>, is missing which doesn&#x27;t make sense for in-memory operations.</p><p>In transactional memory we get these aspects of ACID properties:</p><ul><li><p><strong>Atomicity</strong> â€” On write operations, we want <em>atomic update</em>, which means the update operation either should run at once or not at all.</p></li><li><p><strong>Consistency</strong> â€” On read operations, we want <em>consistent view</em> of the state of the program that ensures us all reference to the state, gets the same value whenever they get the state.</p></li><li><p><strong>Isolated</strong> â€” If we have multiple updates, we need to perform these updates in isolated transactions. So each transaction doesn&#x27;t affect other concurrent transactions. No matter how many fibers are running any number of transactions. None of them have to worry about what is happening in the other transactions.</p></li></ul><p>The ZIO STM API is inspired by Haskell&#x27;s <a href="http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM.html" target="_blank" rel="noopener noreferrer">STM library</a> although the implementation in ZIO is completely different.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="the-problem">The Problem<a aria-hidden="true" class="hash-link" href="#the-problem" title="Direct link to heading">â€‹</a></h2><p>Let&#x27;s start from a simple <code>inc</code> function, which takes a mutable reference of <code>Int</code> and increase it by <code>amount</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def inc(counter: Ref[Int], amount: Int) = for {</span><br></span><span class="token-line"><span class="token plain">  c &lt;- counter.get</span><br></span><span class="token-line"><span class="token plain">  _ &lt;- counter.set(c + amount)</span><br></span><span class="token-line"><span class="token plain">} yield c</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>If there is only one fiber in the world, it is not a problem. This function sounds correct. But what happens if in between reading the value of the counter and setting a new value, another fiber comes and mutates the value of the counter? Another fiber is just updating the counter just after we read the counter. So this function is subject to a race condition, we can test that with the following program:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">for {</span><br></span><span class="token-line"><span class="token plain">  counter &lt;- Ref.make(0)</span><br></span><span class="token-line"><span class="token plain">  _ &lt;- ZIO.collectAllPar(ZIO.replicate(10)(inc(counter, 1)))</span><br></span><span class="token-line"><span class="token plain">  value &lt;- counter.get</span><br></span><span class="token-line"><span class="token plain">} yield (value)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>As the above program runs 10 concurrent fibers to increase the counter value. However, we cannot expect this program to always return 10 as a result. </p><p>To fix this issue, we need to perform the <code>get</code> and <code>set</code> operation atomically. The <code>Ref</code> data type some other api like <code>update</code>, <code>updateAndGet</code>, and <code>modify</code> which perform the reading and writing atomically:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def inc(counter: Ref[Int], amount: Int) = counter.updateAndGet(_ + amount)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>The most important note about the <code>modify</code> operation is that it doesn&#x27;t use pessimistic locking. It doesn&#x27;t use any locking primitives for the critical section. It has an optimistic assumption on occurring collisions.</p><p>The <code>modify</code> function takes these three steps:</p><ol><li><p>It assumes that other fibers don&#x27;t change the shared state and don&#x27;t interferer in most cases. So it read the shared state without using any locking primitives.</p></li><li><p>It should be prepared itself for the worst cases. If another fiber was accessing at the same time, what would happen? So when we came to writing a new value it should check everything. It should make sure that it saw a consistent state of the universe and if it had, then it can change that value.</p></li><li><p>If it encounters an inconsistent value, it shouldn&#x27;t continue. So it aborts updating the shared state with invalidated assumption. It should retry the <code>modify</code> operation with an updated state.</p></li></ol><p>Let&#x27;s see how the <code>modify</code> function of <code>Ref</code> is implemented without any locking mechanism:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">  final case class Ref[A](value: AtomicReference[A]) { self =&gt;</span><br></span><span class="token-line"><span class="token plain">    def modify[B](f: A =&gt; (B, A)): UIO[B] = UIO.effectTotal {</span><br></span><span class="token-line"><span class="token plain">      var loop = true</span><br></span><span class="token-line"><span class="token plain">      var b: B = null.asInstanceOf[B]</span><br></span><span class="token-line"><span class="token plain">      while (loop) {</span><br></span><span class="token-line"><span class="token plain">        val current = value.get</span><br></span><span class="token-line"><span class="token plain">        val tuple   = f(current)</span><br></span><span class="token-line"><span class="token plain">        b = tuple._1</span><br></span><span class="token-line"><span class="token plain">        loop = !value.compareAndSet(current, tuple._2)</span><br></span><span class="token-line"><span class="token plain">      }</span><br></span><span class="token-line"><span class="token plain">      b</span><br></span><span class="token-line"><span class="token plain">    }</span><br></span><span class="token-line"><span class="token plain"> }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>As we see, the <code>modify</code> operation is implemented in terms of the <code>compare-and-swap</code> operation which helps us to perform read and update atomically.</p><p>Let&#x27;s rename the <code>inc</code> function to the <code>deposit</code> as follows to try the classic problem of transferring money from one account to another:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def deposit(accountBalance: Ref[Int], amount: Int) = accountBalance.update(_ + amount)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>And the <code>withdraw</code> function:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def withdraw(accountBalance: Ref[Int], amount: Int) = accountBalance.update(_ - amount) </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>It seems pretty good, but we also need to check that there is sufficient balance in the account to withdraw. So let&#x27;s add an invariant to check that:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def withdraw(accountBalance: Ref[Int], amount: Int) = for {</span><br></span><span class="token-line"><span class="token plain">  balance &lt;- accountBalance.get</span><br></span><span class="token-line"><span class="token plain">  _ &lt;- if (balance &lt; amount) ZIO.fail(&quot;Insufficient funds in you account&quot;) else</span><br></span><span class="token-line"><span class="token plain">    accountBalance.update(_ - amount)</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>What if in between checking and updating the balance, another fiber comes and withdraws all money in the account? This solution has a bug. It has the potential to reach a negative balance. </p><p>Suppose we finally reached a solution to do withdraw atomically, the problem remains. We need a way to compose <code>withdraw</code> with <code>deposit</code> atomically to create a `transfer function:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def transfer(from: Ref[Int], to: Ref[Int], amount: Int) = for {</span><br></span><span class="token-line"><span class="token plain">  _ &lt;- withdraw(from, amount)</span><br></span><span class="token-line"><span class="token plain">  _ &lt;- deposit(to, amount)</span><br></span><span class="token-line"><span class="token plain">} yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>In the above example, even we assume that the <code>withdraw</code> and <code>deposit</code> are atomic, we can&#x27;t compose these two transactions. They produce bugs in a concurrent environment. This code doesn&#x27;t guarantee us that both <code>withdraw</code> and <code>deposit</code> are performed in one single atomic operation. Other fibers which are executing this <code>transfer</code> method can override the shared state and introduce a race condition.</p><p>We need a solution to <strong>atomically compose transactions</strong>. This is where software transactional memory comes to into play.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="composable-concurrency">Composable Concurrency<a aria-hidden="true" class="hash-link" href="#composable-concurrency" title="Direct link to heading">â€‹</a></h2><p>Software transactional memory provides us a way to compose multiple transactions and perform them in one single transaction.</p><p>Let&#x27;s continue our last effort to convert our <code>withdraw</code> method to be one atomic operation. To solve the problem using STM, we replace <code>Ref</code> with <code>TRef</code>. <code>TRef</code> stands for <em>Transactional Reference</em>; it is a mutable reference contained in the <code>STM</code> world. <code>STM</code> is a monadic data structure that represents an effect that can be performed transactionally:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def withdraw(accountBalance: TRef[Int], amount: Int): STM[String, Unit] =</span><br></span><span class="token-line"><span class="token plain">  for {</span><br></span><span class="token-line"><span class="token plain">    balance &lt;- accountBalance.get</span><br></span><span class="token-line"><span class="token plain">    _ &lt;- if (balance &lt; amount)</span><br></span><span class="token-line"><span class="token plain">      STM.fail(&quot;Insufficient funds in you account&quot;)</span><br></span><span class="token-line"><span class="token plain">    else</span><br></span><span class="token-line"><span class="token plain">      accountBalance.update(_ - amount)</span><br></span><span class="token-line"><span class="token plain">  } yield ()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Although the <code>deposit</code> operation is atomic, to be able to compose with <code>withdraw</code> we need to refactor it to takes <code>TRef</code> and returns <code>STM</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def deposit(accountBalance: TRef[Int], amount: Int): STM[Nothing, Unit] =</span><br></span><span class="token-line"><span class="token plain">  accountBalance.update(_ + amount)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>In the <code>STM</code> world we can compose all operations and at the end of the world, we perform all of them in one single operation atomically. To be able to compose <code>withdraw</code> with <code>deposit</code> we need to stay in the <code>STM</code> world. Therefore, we didn&#x27;t perform <code>STM.atomically</code> or <code>STM#commit</code> methods on each of them.</p><p>Now we can define the <code>transfer</code> method by composing these two function in the <code>STM</code> world and converting them into the <code>IO</code> atomically:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar"><code class="codeBlockLines_1zSZ"><span class="token-line"><span class="token plain">def transfer(from: TRef[Int], to: TRef[Int], amount: Int): IO[String, Unit] =</span><br></span><span class="token-line"><span class="token plain">  STM.atomically {</span><br></span><span class="token-line"><span class="token plain">    for {</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- withdraw(from, amount)</span><br></span><span class="token-line"><span class="token plain">      _ &lt;- deposit(to, amount)</span><br></span><span class="token-line"><span class="token plain">    } yield ()</span><br></span><span class="token-line"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Assume we are in the middle of transferring money from one account to the other. If we withdraw the first account but haven&#x27;t deposited the second account, that kind of intermediate state is not visible to any external fibers. The transaction completely successful if there are not any conflicting changes. And if there are any conflicts or conflicting changes then the whole transaction, the entire STM will be retried.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="how-does-it-work">How Does it Work?<a aria-hidden="true" class="hash-link" href="#how-does-it-work" title="Direct link to heading">â€‹</a></h2><p>The <code>STM</code> uses the same idea of the <code>Ref#modify</code> function, but with a composability feature. The main goal of <code>STM</code> is to provide a mechanism to compose multiple transactions and perform them in one single atomic operation.</p><p>The mechanism behind the compositional part is obvious. The <code>STM</code> has its own world. It has lots of useful combinators like <code>flatMap</code> and <code>orElse</code> to compose multiple <code>STM</code> and create more elegant ones. After we perform a transaction with <code>STM#commit</code> or <code>STM.atomically</code> the runtime system does the following steps. These steps are not exactly accurate, but they draw an outline of what happens during the transaction:</p><ol><li><p><strong>Starting a Transaction</strong> â€” When we start a transaction, the runtime system creates a virtual space to keep track of the transaction logs which is build up by recording the reads and tentative writes that the transaction will perform during the transaction steps.</p></li><li><p><strong>Virtual Execution</strong> â€” The runtime starts speculating the execution of transactions on every read and write operation. It has two internal logs;  the read and the write log. On the read log, it saves the version of all variables it reads during the intermediate steps, and on the write log, it saves the intermediate result of the transaction. It doesn&#x27;t change the shared state on the main memory. Anything that is inside an atomic block is not executed immediately, it&#x27;s executed in the virtual world, just by putting stuff in the internal log, not in the main memory. In this particular model, we guarantee that all computations are isolated from one another.</p></li><li><p><strong>Commit Phase (Real Execution)</strong> â€” When it came to the end of the transaction the runtime system should check everything it has read. It should make sure that it saw a consistent state of the universe and if it had, then it atomically commits. As the STM is optimistic, it assumes that in the middle of a transaction the chance of interfering with the shared state by other fibers is very rare. But it must ready itself for the worst cases. It should validate its assumption in the final stage. It checks whether the transactional variables involved were modified by any other threads or not. If its assumption got invalidated in the meanwhile of the transaction, it should abandon the transaction and retry it again. It jumps to the start of the transaction with the original and default values and tries again until it succeeds; This is necessary to resolve conflicts. Otherwise, if there was no conflict, it commits the final value atomically to the memory and succeeds. From point of view of other fibers, all values in memory exchanging in one blink of an eye. It&#x27;s all atomic.</p></li></ol><p>Everything done within a transaction to other transactions looks like it happens at once or not at all. So no matter how many pieces of memory it touches during the transaction. From the other transaction perspective, all of these changes happen at once.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="stm-data-types">STM Data Types<a aria-hidden="true" class="hash-link" href="#stm-data-types" title="Direct link to heading">â€‹</a></h2><p>There are a variety of transactional data structures that can take part in an STM transaction:</p><ul><li><strong><a href="/version-1.x/datatypes/stm/tarray">TArray</a></strong> - A <code>TArray[A]</code> is an array of mutable references that can participate in transactions.</li><li><strong><a href="/version-1.x/datatypes/stm/tset">TSet</a></strong> - A <code>TSet</code> is a mutable set that can participate in transactions.</li><li><strong><a href="/version-1.x/datatypes/stm/tmap">TMap</a></strong> - A <code>TMap[A]</code> is a mutable map that can participate in transactions.</li><li><strong><a href="/version-1.x/datatypes/stm/tref">TRef</a></strong> - A <code>TRef</code> is a mutable reference to an immutable value that can participate in transactions.</li><li><strong><a href="/version-1.x/datatypes/stm/tpriorityqueue">TPriorityQueue</a></strong> - A <code>TPriorityQueue[A]</code> is a mutable priority queue that can participate in transactions.</li><li><strong><a href="/version-1.x/datatypes/stm/tpromise">TPromise</a></strong> - A <code>TPromise</code> is a mutable reference that can be set exactly once and can participate in transactions.</li><li><strong><a href="/version-1.x/datatypes/stm/tqueue">TQueue</a></strong> - A <code>TQueue</code> is a mutable queue that can participate in transactions.</li><li><strong><a href="/version-1.x/datatypes/stm/treentrantlock">TReentrantLock</a></strong> - A <code>TReentrantLock</code> is a reentrant read / write lock that can be composed.</li><li><strong><a href="/version-1.x/datatypes/stm/tsemaphore">TSemaphore</a></strong> - A <code>TSemaphore</code> is a semaphore that can participate in transactions.</li></ul><p>Since STM places a great emphasis on compositionality, we can build upon these data structures and define our very own concurrent data structures. For example, we can build a transactional priority queue using <code>TRef</code>, <code>TMap</code> and <code>TQueue</code>.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="advantage-of-using-stm">Advantage of Using STM<a aria-hidden="true" class="hash-link" href="#advantage-of-using-stm" title="Direct link to heading">â€‹</a></h2><ol><li><p><strong>Composable Transaction</strong> â€” Combining atomic operations using locking-oriented programming is almost impossible. ZIO provides the <code>STM</code> data type, which has lots of combinators to compose transactions.</p></li><li><p><strong>Declarative</strong> â€” ZIO STM is completely declarative. It doesn&#x27;t require us to think about low-level primitives. It doesn&#x27;t force us to think about the ordering of locks. Reasoning concurrent program in a declarative fashion is very simple. We can just focus on the logic of our program and run it in a concurrent environment deterministically. The user code is much simpler of course because it doesn&#x27;t have to deal with the concurrency at all. </p></li><li><p><strong>Optimistic Concurrency</strong> â€” In most cases, we are allowed to be optimistic, unless there is tremendous contention. So if we haven&#x27;t tremendous contention it really pays to be optimistic. It allows a higher volume of concurrent transactions.</p></li><li><p><strong>Lock-Free</strong> â€” All operations are non-blocking using lock-free algorithms.</p></li><li><p><strong>Fine-Grained Locking</strong>â€” Coarse-grained locking is very simple to implement, but it has a negative impact on performance, while fine-grained locking significantly has better performance, but it is very cumbersome, sophisticated, and error-prone even for experienced programmers. We would like to have the ease of use of coarse-grain locking, but at the same time, we would like to have the efficiency of fine-grain locking. ZIO provides several data types which are a very coarse way of using concurrency, but they are implemented as if every single word were lockable. So the granularity of concurrency is fine-grained. It increases the performance and concurrency. For example, if we have two fibers accessing the same <code>TArray</code>, one of them read and write on the first index of our array, and another one is read and write to the second index of that array, they will not conflict. It is just like as if we were locking the indices, not the whole array. </p></li></ol><h2 class="anchor anchorWithStickyNavbar_y2LR" id="implication-of-using-stm">Implication of Using STM<a aria-hidden="true" class="hash-link" href="#implication-of-using-stm" title="Direct link to heading">â€‹</a></h2><ol><li><p><strong>Running I/O Inside STM</strong>â€” There is a strict boundary between the <code>STM</code> world and the <code>ZIO</code> world. This boundary propagates even deeper because we are not allowed to execute arbitrary effects in the <code>STM</code> universe. Performing side effects and I/O operation inside a transaction is problematic. In the <code>STM</code> the only effect that exists is the <code>STM</code> itself. We cannot print something or launch a missile inside a transaction as it will nondeterministically get printed on every reties that transaction do that.</p></li><li><p><strong>Large Allocations</strong> â€” We should be very careful in choosing the best data structure using for using STM operations. For example, if we use a single data structure with <code>TRef</code> and that data structure occupies a big chunk of memory. Every time we are updating this data structure during the transaction, the runtime system needs a fresh copy of this chunk of memory.</p></li><li><p><strong>Running Expensive Operations</strong>â€” The beautiful feature of the <code>retry</code> combinator is when we decide to retry the transaction, the <code>retry</code> avoids the busy loop. It waits until any of the underlying transactional variables have changed. However, we should be careful about running expensive operations multiple times.</p></li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.x/datatypes/stm/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/version-1.x/datatypes/concurrency/semaphore"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« <!-- -->Semaphore</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/version-1.x/datatypes/stm/stm"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">STM<!-- --> Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#overview" class="table-of-contents__link toc-highlight">Overview</a></li><li><a href="#the-problem" class="table-of-contents__link toc-highlight">The Problem</a></li><li><a href="#composable-concurrency" class="table-of-contents__link toc-highlight">Composable Concurrency</a></li><li><a href="#how-does-it-work" class="table-of-contents__link toc-highlight">How Does it Work?</a></li><li><a href="#stm-data-types" class="table-of-contents__link toc-highlight">STM Data Types</a></li><li><a href="#advantage-of-using-stm" class="table-of-contents__link toc-highlight">Advantage of Using STM</a></li><li><a href="#implication-of-using-stm" class="table-of-contents__link toc-highlight">Implication of Using STM</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><ul class="footer__items"><li class="footer__item">
                <img src="/img/navbar_brand.png" alt="zio">
            </li></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items"><li class="footer__item">
              <a href="https://github.com/zio/zio">
                <img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github">
              </a>
            </li></ul></div><div class="col footer__col"><div class="footer__title">Chat with us on Discord</div><ul class="footer__items"><li class="footer__item">
                <a href="https://discord.gg/2ccFBr4">
                  <img src="https://img.shields.io/discord/629491597070827530?logo=discord&style=social" alt="discord">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Follow us on Twitter</div><ul class="footer__items"><li class="footer__item">
                <a href="https://twitter.com/zioscala">
                  <img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&style=social" alt="twitter">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Additional resources</div><ul class="footer__items"><li class="footer__item"><a href="https://javadoc.io/doc/dev.zio/zio_2.12/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scaladoc of ZIO<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 ZIO Maintainers - Built with <a href="https://v2.docusaurus.io/">Docusaurus v2</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.a9287c7c.js"></script>
<script src="/assets/js/main.d278da23.js"></script>
</body>
</html>